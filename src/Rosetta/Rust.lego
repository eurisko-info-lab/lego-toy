-----------------------------------------------------
-- Rust.lego: Rust AST Definition for Rosetta
--
-- This defines the Rust abstract syntax tree as a Lego specification.
-- It serves as the TARGET representation for rosetta2rust transformation.
--
-- Rust features:
-- - enum for ADTs
-- - impl blocks for methods
-- - trait for interfaces
-- - match expressions
-- - ownership and borrowing
-- - Result/Option for error handling
--
-- BIDIRECTIONAL: parse . print = print . parse = id
-- Layout markers (@nl, @indent, @dedent, @sp, @nsp) guide printing.
-----------------------------------------------------
lang Rust :=

-----------------------------------------------------
-- Core Expressions
-- Basic Rust expressions
-----------------------------------------------------
piece CoreExprs
  expr ::= 
    -- Variables and literals
    <ident>                             → var
    | <number>                          → intLit
    | <string>                          → strLit
    | "true"                            → trueLit
    | "false"                           → falseLit
    | "()"                              → unitLit
    -- Application/call
    | expr @nsp "(" @nsp exprList @nsp ")" → call
    | expr @nsp "::" @nsp "<" @nsp typeList @nsp ">" @nsp "(" @nsp exprList @nsp ")" → turbofish
    -- Method call
    | expr @nsp "." @nsp <ident> @nsp "(" @nsp exprList @nsp ")" → methodCall
    | expr @nsp "." @nsp <ident>        → fieldAccess
    | expr @nsp "." @nsp <number>       → tupleAccess
    -- Closure
    | "|" @nsp paramList @nsp "|" @sp expr → closure
    | "|" @nsp paramList @nsp "|" @sp "{" @nl @indent stmtList @dedent "}" → closureBlock
    | "move" @sp "|" @nsp paramList @nsp "|" @sp expr → moveClosure
    -- If-else
    | "if" expr block elseClause?       → ifExpr
    | "if" "let" pattern @sp "=" @sp expr block elseClause? → ifLetExpr
    -- Match
    | "match" expr @sp "{" @nl @indent matchArm* @dedent "}" → matchExpr
    -- Loops
    | "loop" block                      → loopExpr
    | "while" expr block                → whileExpr
    | "while" "let" pattern @sp "=" @sp expr block → whileLetExpr
    | "for" pattern "in" expr block     → forExpr
    -- Block
    | block                             → blockExpr
    -- Let
    | "let" pattern typeAnn? @sp "=" @sp expr → letExpr
    | "let" "mut" pattern typeAnn? @sp "=" @sp expr → letMutExpr
    -- Tuples
    | "(" @nsp exprList @nsp ")"        → tuple
    -- Arrays/Vectors
    | "[" @nsp exprList @nsp "]"        → arrayLit
    | "vec!" @nsp "[" @nsp exprList @nsp "]" → vecLit
    -- Option
    | "None"                            → noneLit
    | "Some" @nsp "(" @nsp expr @nsp ")" → someLit
    -- Result
    | "Ok" @nsp "(" @nsp expr @nsp ")"  → okLit
    | "Err" @nsp "(" @nsp expr @nsp ")" → errLit
    -- Operators (arithmetic)
    | expr @sp "+" @sp expr             → add
    | expr @sp "-" @sp expr             → sub
    | expr @sp "*" @sp expr             → mul
    | expr @sp "/" @sp expr             → div
    | expr @sp "%" @sp expr             → mod
    | "-" @nsp expr                     → neg
    -- Operators (comparison)
    | expr @sp "==" @sp expr            → eq
    | expr @sp "!=" @sp expr            → neq
    | expr @sp "<" @sp expr             → lt
    | expr @sp ">" @sp expr             → gt
    | expr @sp "<=" @sp expr            → le
    | expr @sp ">=" @sp expr            → ge
    -- Operators (logical)
    | expr @sp "&&" @sp expr            → and
    | expr @sp "||" @sp expr            → or
    | "!" @nsp expr                     → not
    -- References
    | "&" @nsp expr                     → ref
    | "&" "mut" expr                    → refMut
    | "*" @nsp expr                     → deref
    -- Box
    | "Box" @nsp "::" @nsp "new" @nsp "(" @nsp expr @nsp ")" → boxNew
    -- Return/break/continue
    | "return" expr?                    → returnExpr
    | "break" expr?                     → breakExpr
    | "continue"                        → continueExpr
    -- Panic/unreachable
    | "panic!" @nsp "(" @nsp <string> @nsp ")" → panicExpr
    | "unreachable!" @nsp "(" @nsp ")"  → unreachableExpr
    | "todo!" @nsp "(" @nsp ")"         → todoExpr
    -- Question mark (error propagation)
    | expr @nsp "?"                     → tryExpr
    -- Parentheses
    | "(" @nsp expr @nsp ")"            → paren
    -- Range
    | expr @nsp ".." @nsp expr          → range
    | expr @nsp "..=" @nsp expr         → rangeInclusive
    -- Struct literal
    | <ident> @sp "{" @sp fieldInit* @sp "}" → structLit
    | <ident> @sp "{" @sp fieldInit* @sp ".." @sp expr @sp "}" → structUpdate
    -- Macro invocation
    | <ident> @nsp "!" @nsp "(" @nsp exprList @nsp ")" → macroCall
    | <ident> @nsp "!" @nsp "[" @nsp exprList @nsp "]" → macroCallBracket
    ;

  exprList ::= expr ("," @sp expr)*     → exprList ;
  block ::= "{" @nl @indent stmtList @dedent "}" → block ;
  stmtList ::= stmt* expr?              → stmtList ;
  stmt ::= expr ";" @nl                 → stmtExpr
         | "let" pattern typeAnn? @sp "=" @sp expr ";" @nl → stmtLet
         | "let" "mut" pattern typeAnn? @sp "=" @sp expr ";" @nl → stmtLetMut
         | item                         → stmtItem
         ;
  elseClause ::= @sp "else" @sp block   → elseBlock
               | @sp "else" @sp ifExpr  → elseIf
               ;

-----------------------------------------------------
-- Types
-- Rust type expressions
-----------------------------------------------------
piece Types
  type ::= <ident>                      → tyPath
         | <ident> @nsp "<" @nsp typeList @nsp ">" → tyGeneric
         | "&" lifetime? "mut"? type    → tyRef
         | "*" "const" type             → tyRawConst
         | "*" "mut" type               → tyRawMut
         | "(" @nsp typeList @nsp ")"   → tyTuple
         | "[" @nsp type @nsp "]"       → tySlice
         | "[" @nsp type ";" @sp <number> @nsp "]" → tyArray
         | "fn" @nsp "(" @nsp typeList @nsp ")" @sp "->" @sp type → tyFn
         | "impl" <ident>               → tyImpl
         | "dyn" <ident>                → tyDyn
         | "Box" @nsp "<" @nsp type @nsp ">" → tyBox
         | "Option" @nsp "<" @nsp type @nsp ">" → tyOption
         | "Result" @nsp "<" @nsp type "," @sp type @nsp ">" → tyResult
         | "Vec" @nsp "<" @nsp type @nsp ">" → tyVec
         | "()"                         → tyUnit
         | "!"                          → tyNever
         | "_"                          → tyInfer
         ;
  typeList ::= type ("," @sp type)*     → typeList ;
  typeAnn ::= @sp ":" @sp type          → typeAnn ;
  lifetime ::= "'" @nsp <ident>         → lifetime ;

-----------------------------------------------------
-- Patterns
-- Match patterns
-----------------------------------------------------
piece Patterns
  pattern ::= <ident>                   → patIdent
            | "_"                       → patWild
            | <number>                  → patLit
            | <string>                  → patStr
            | "true"                    → patTrue
            | "false"                   → patFalse
            | "()"                      → patUnit
            | <ident> @sp "{" @sp fieldPat* @sp "}" → patStruct
            | <ident> @nsp "(" @nsp patternList @nsp ")" → patTupleStruct
            | "(" @nsp patternList @nsp ")" → patTuple
            | "[" @nsp patternList @nsp "]" → patSlice
            | pattern @sp "|" @sp pattern → patOr
            | pattern @sp "@" @sp pattern → patAt
            | "ref" pattern             → patRef
            | "ref" "mut" pattern       → patRefMut
            | "mut" pattern             → patMut
            | "&" @nsp pattern          → patDeref
            | pattern @nsp ".." @nsp pattern → patRange
            | ".."                      → patRest
            ;
  patternList ::= pattern ("," @sp pattern)* → patternList ;
  fieldPat ::= <ident> @sp ":" @sp pattern → fieldPat
             | <ident>                  → fieldPatShort
             ;
  matchArm ::= pattern guard? @sp "=>" @sp expr "," @nl → matchArm ;
  guard ::= @sp "if" expr               → guard ;

-----------------------------------------------------
-- Parameters
-----------------------------------------------------
piece Parameters
  param ::= <ident> @sp ":" @sp type    → param
          | "mut" <ident> @sp ":" @sp type → paramMut
          | "&" "self"                  → selfRef
          | "&" "mut" "self"            → selfRefMut
          | "self"                      → selfOwned
          ;
  paramList ::= param ("," @sp param)*  → paramList ;
  typeParam ::= <ident>                 → typeParam
              | <ident> @sp ":" @sp typeBound → typeParamBound
              ;
  typeParamList ::= "<" @nsp typeParam ("," @sp typeParam)* @nsp ">" → typeParamList ;
  typeBound ::= <ident> ("+" @sp <ident>)* → typeBound ;
  whereClause ::= "where" wherePred ("," @sp wherePred)* → whereClause ;
  wherePred ::= type @sp ":" @sp typeBound → wherePred ;

-----------------------------------------------------
-- Field Initializers
-----------------------------------------------------
piece Fields
  fieldInit ::= <ident> @sp ":" @sp expr → fieldInit
              | <ident>                 → fieldInitShort
              ;

-----------------------------------------------------
-- Items (Declarations)
-----------------------------------------------------
piece Items
  item ::= 
    -- Enum (ADT)
    visibility? "enum" <ident> typeParamList? whereClause? @sp "{" @nl @indent enumVariant* @dedent "}" @nl @nl
      → enumItem
    -- Struct
    | visibility? "struct" <ident> typeParamList? whereClause? @sp "{" @nl @indent structField* @dedent "}" @nl
      → structItem
    | visibility? "struct" <ident> typeParamList? @nsp "(" @nsp tupleField* @nsp ")" ";" @nl
      → tupleStructItem
    | visibility? "struct" <ident> ";" @nl
      → unitStructItem
    -- Trait
    | visibility? "trait" <ident> typeParamList? superTraits? whereClause? @sp "{" @nl @indent traitItem* @dedent "}" @nl
      → traitItem
    -- Impl
    | "impl" typeParamList? type whereClause? @sp "{" @nl @indent implItem* @dedent "}" @nl
      → implBlock
    | "impl" typeParamList? <ident> "for" type whereClause? @sp "{" @nl @indent implItem* @dedent "}" @nl
      → implTraitBlock
    -- Function
    | visibility? "fn" <ident> typeParamList? @nsp "(" @nsp paramList @nsp ")" returnType? whereClause? @sp block @nl
      → fnItem
    | visibility? "const" "fn" <ident> typeParamList? @nsp "(" @nsp paramList @nsp ")" returnType? @sp block @nl
      → constFnItem
    | visibility? "async" "fn" <ident> typeParamList? @nsp "(" @nsp paramList @nsp ")" returnType? @sp block @nl
      → asyncFnItem
    -- Const/static
    | visibility? "const" <ident> @sp ":" @sp type @sp "=" @sp expr ";" @nl
      → constItem
    | visibility? "static" "mut"? <ident> @sp ":" @sp type @sp "=" @sp expr ";" @nl
      → staticItem
    -- Type alias
    | visibility? "type" <ident> typeParamList? @sp "=" @sp type ";" @nl
      → typeAliasItem
    -- Use/mod
    | visibility? "use" usePath ";" @nl
      → useItem
    | visibility? "mod" <ident> ";" @nl
      → modDeclItem
    | visibility? "mod" <ident> @sp "{" @nl @indent item* @dedent "}" @nl
      → modDefItem
    -- Comments (for generated code)
    | "//" <ident>* @nl
      → lineComment
    ;

  visibility ::= "pub"                  → pubVis
               | "pub" @nsp "(" @nsp "crate" @nsp ")" → pubCrateVis
               | "pub" @nsp "(" @nsp "super" @nsp ")" → pubSuperVis
               ;
  enumVariant ::= <ident> "," @nl       → enumVariantUnit
                | <ident> @nsp "(" @nsp tupleField ("," @sp tupleField)* @nsp ")" "," @nl → enumVariantTuple
                | <ident> @sp "{" @nl @indent structField* @dedent "}" "," @nl → enumVariantStruct
                ;
  structField ::= visibility? <ident> @sp ":" @sp type "," @nl → structField ;
  tupleField ::= visibility? type       → tupleField ;
  returnType ::= @sp "->" @sp type      → returnType ;
  superTraits ::= @sp ":" @sp typeBound → superTraits ;
  traitItem ::= "fn" <ident> @nsp "(" @nsp paramList @nsp ")" returnType? ";" @nl → traitFnSig
              | "fn" <ident> @nsp "(" @nsp paramList @nsp ")" returnType? @sp block @nl → traitFnDefault
              | "type" <ident> typeBounds? ";" @nl → traitTypeAssoc
              ;
  typeBounds ::= @sp ":" @sp typeBound  → typeBounds ;
  implItem ::= visibility? "fn" <ident> @nsp "(" @nsp paramList @nsp ")" returnType? @sp block @nl → implFn
             | "type" <ident> @sp "=" @sp type ";" @nl → implType
             ;
  usePath ::= <ident> (@nsp "::" @nsp <ident>)* → usePath
            | <ident> @nsp "::" @nsp "*" → useGlob
            | <ident> @nsp "::" @nsp "{" @nsp useTree ("," @sp useTree)* @nsp "}" → useGroup
            ;
  useTree ::= <ident>                   → useTreeIdent
            | <ident> "as" <ident>      → useTreeRename
            ;

-----------------------------------------------------
-- Module
-- Top-level structure
-----------------------------------------------------
piece Module
  module ::= item*                      → module ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------
test "closure": (closure (paramList (param x (tyPath i32))) (add (var x) (intLit 1))) ;
test "enum": (enumItem (pubVis) Term (enumVariantUnit Var) (enumVariantTuple App (tupleField (tyPath Term)) (tupleField (tyPath Term)))) ;
test "fn": (fnItem (pubVis) id (typeParamList (typeParam T)) (paramList (param x (tyPath T))) (returnType (tyPath T)) (block (stmtList (var x)))) ;
test "match": (matchExpr (var opt) (matchArm (patTupleStruct Some (patternList (patIdent x))) (var x)) (matchArm (patIdent None) (intLit 0))) ;
test "impl": (implBlock (tyPath MyStruct) (implFn (pubVis) new (paramList) (returnType (tyPath Self)) (block (stmtList (structLit MyStruct))))) ;

