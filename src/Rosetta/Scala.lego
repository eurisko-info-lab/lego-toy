-----------------------------------------------------
-- Scala.lego: Scala 3 Grammar Definition
--
-- Bidirectional grammar for Scala 3:
-- - PARSING: tokenizer + parser for .scala files
-- - PRINTING: layout markers for code generation
--
-- Scala 3 features:
-- - enum for ADTs (replaces sealed trait + case class)
-- - given/using for implicits
-- - extension methods
-- - match types
-- - union/intersection types
-----------------------------------------------------
lang Scala :=

-----------------------------------------------------
-- Token: Character-level grammar (lexer)
-- Defines Scala 3 tokenization including comments
-----------------------------------------------------
token Token
  -- Basic ASCII character classes
  digit  ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
  lower  ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
           | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
           | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
  upper  ::= 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
           | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
           | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
  alpha  ::= lower | upper | '_' | '$' ;
  
  -- Symbol characters (for operators)
  symch  ::= '+' | '-' | '*' | '/' | '=' | '<' | '>' | '!' | '@' | '#'
           | '%' | '^' | '&' | '|' | '~' | '?' | ':' | ';' | ','
           | '.' | '[' | ']' | '(' | ')' | '{' | '}' | '`' | '\\' ;
  
  -- Identifiers (Scala allows $ and backticks)
  ident  ::= alpha (alpha | digit)* ;
  -- Backtick identifiers for reserved words: `type`, `match`, etc.
  btident ::= '`' (alpha | digit | ' ')+ '`' ;
  
  -- Numbers (including underscores in Scala 3)
  number ::= digit (digit | '_')* ;
  hexnum ::= '0' ('x' | 'X') (digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f'
                                    | 'A' | 'B' | 'C' | 'D' | 'E' | 'F')+ ;
  
  -- String literals
  string ::= '"' strchar* '"' ;
  strchar ::= '\\' escape | alpha | digit | symch | ' ' | '\'' | '\t' ;
  escape ::= 'n' | 't' | 'r' | '\\' | '"' | '\'' | '0' | 'b' | 'f' ;
  
  -- Raw/interpolated strings (s"...", f"...", raw"...")
  interpstr ::= ('s' | 'f' | 'r' 'a' 'w') '"' strchar* '"' ;
  
  -- Multi-line strings
  mlstring ::= '"' '"' '"' mlchar* '"' '"' '"' ;
  mlchar ::= alpha | digit | symch | ' ' | '\t' | '\n' | '\r' | '\'' ;
  
  -- Character literals
  char ::= '\'' charinner '\'' ;
  charinner ::= '\\' escape | alpha | digit | symch | ' ' ;
  
  -- Whitespace
  ws ::= ' ' | '\t' | '\n' | '\r' ;
  
  -- Line comments: // ...
  comment ::= '/' '/' nonnl* ;
  nonnl ::= alpha | digit | symch | ' ' | '\t' | '\'' | '"' | '`' ;
  
  -- Block comments: /* ... */ (including doc comments /** ... */)
  blockComment ::= '/' '*' blockInner* '*' '/' ;
  blockInner ::= alpha | digit | symch | ' ' | '\t' | '\n' | '\r' | '\'' | '"' | '*' | '/' | '@' ;
  
  -- Operators (maximal munch)
  operator ::= #longest[
      '=' '>' '=',     -- =>=
      '=' '=' '=',     -- ===
      '!' '=' '=',     -- !==
      '<' '-' '-',     -- <--
      '-' '-' '>',     -- -->
      '.' '_' '1',     -- ._1
      '.' '_' '2',     -- ._2
      '=' '>',         -- =>
      '<' '-',         -- <-
      '-' '>',         -- -> (for type lambdas)
      '=' '=',         -- ==
      '!' '=',         -- !=
      '<' '=',         -- <=
      '>' '=',         -- >=
      '<' ':',         -- <: (upper bound)
      '>' ':',         -- >: (lower bound)
      '+' ':',         -- +: (prepend)
      ':' '+',         -- :+ (append)
      '+' '+',         -- ++ (concat)
      ':' ':',         -- :: (cons)
      '&' '&',         -- && (and)
      '|' '|',         -- || (or)
      '|' '>',         -- |> (pipe)
      '.' '_',         -- ._ (tuple proj prefix)
      '@' '@',         -- @@ (annotation)
      '?',             -- ? (optional type)
      '+', '-', '*', '/', '%',
      '<', '>', '=', '!',
      '&', '|', '^', '~',
      '(', ')', '[', ']', '{', '}',
      ',', '.', ':', ';', '_', '@'
    ] ;

-----------------------------------------------------
-- Core Terms
-- Basic Scala expressions
-- Structured for precedence: term > orExpr > andExpr > cmpExpr > addExpr > mulExpr > unaryExpr > postfixExpr > atomExpr
--
-- BIDIRECTIONAL: parse . print = print . parse = id
-- Layout markers (@nl, @indent, @dedent, @sp, @nsp) guide printing.
-----------------------------------------------------
piece CoreTerms
  -- Top level: function types (right-associative)
  term ::= orExpr @sp "=>" @sp term        → tyFun
         | orExpr                          → term
         ;
  
  -- Logical or
  orExpr ::= andExpr @sp "||" @sp orExpr   → or
           | andExpr                       → orExpr
           ;
  
  -- Logical and
  andExpr ::= cmpExpr @sp "&&" @sp andExpr → and
            | cmpExpr                      → andExpr
            ;
  
  -- Comparison (non-associative)
  cmpExpr ::= addExpr @sp "==" @sp addExpr → eq
            | addExpr @sp "!=" @sp addExpr → neq
            | addExpr @sp "<" @sp addExpr  → lt
            | addExpr @sp ">" @sp addExpr  → gt
            | addExpr @sp "<=" @sp addExpr → le
            | addExpr @sp ">=" @sp addExpr → ge
            | addExpr                      → cmpExpr
            ;
  
  -- Additive (left-associative via iteration)
  addExpr ::= mulExpr addOp*               → addExpr ;
  addOp ::= @sp "+" @sp mulExpr            → addOp
          | @sp "-" @sp mulExpr            → subOp
          | @sp "++" @sp mulExpr           → concatOp
          | @sp "::" @sp mulExpr           → consOp
          ;
  
  -- Multiplicative
  mulExpr ::= unaryExpr mulOp*             → mulExpr ;
  mulOp ::= @sp "*" @sp unaryExpr          → mulOp
          | @sp "/" @sp unaryExpr          → divOp
          | @sp "%" @sp unaryExpr          → modOp
          ;
  
  -- Unary
  unaryExpr ::= "!" @nsp postfixExpr       → not
              | "-" @nsp postfixExpr       → neg
              | postfixExpr                → unaryExpr
              ;
  
  -- Postfix: method calls, field access, projections
  postfixExpr ::= appExpr postfixOp*       → postfixExpr ;
  postfixOp ::= @nsp "." @nsp <ident> @nsp "(" @nsp termList? @nsp ")" → methodCall
              | @nsp "." @nsp <ident>      → select
              | @nsp "._1"                 → fst
              | @nsp "._2"                 → snd
              | @nsp "." "_" @nsp <number> → projN
              | @sp "match" @sp "{" @nl @indent caseClause* @dedent "}" → matchOp
              ;
  
  -- Application and type application
  appExpr ::= atomExpr appArg*             → appExpr ;
  appArg ::= @nsp "(" @nsp termList? @nsp ")" → appArg
           | @nsp "[" @nsp typeList @nsp "]" → typeArg
           ;
  
  -- Atoms: literals, identifiers, compound expressions
  atomExpr ::= 
    -- Identifiers and literals
    <ident>                                → var
    | <number>                             → intLit
    | <string>                             → strLit
    | "true"                               → trueLit
    | "false"                              → falseLit
    | "()"                                 → unitLit
    | "None"                               → noneLit
    | "Nil"                                → nilLit
    | "_"                                  → hole
    -- Lambdas
    | "(" @nsp paramList @nsp ")" @sp "=>" @sp term → lam
    | <ident> @sp "=>" @sp term            → lamSimple
    | "{" @sp paramList @sp "=>" @sp term @sp "}" → lamBlock
    -- Conditionals
    | "if" term "then" @sp term @sp "else" @sp term → ifExpr
    | "if" @sp "(" @nsp term @nsp ")" @sp term @sp "else" @sp term → ifExprParen
    -- For comprehensions
    | "for" @sp "{" @nl @indent forGen* @dedent "}" @sp "yield" @sp term → forYield
    | "for" @sp "{" @nl @indent forGen* @dedent "}" @sp term → forDo
    -- Option/List constructors
    | "Some" @nsp "(" @nsp term @nsp ")"   → someLit
    | "List" @nsp "(" @nsp termList? @nsp ")" → listLit
    -- New/throw/try
    | "new" <ident> @nsp "(" @nsp termList? @nsp ")" → newExpr
    | "throw" term                         → throwExpr
    | "try" @sp term @sp "catch" @sp "{" @nl @indent caseClause* @dedent "}" finallyClause? → tryExpr
    -- Block and val expressions
    | "{" @nl @indent stmt* term @dedent "}" → block
    | "val" <ident> typeAnn? @sp "=" @sp term term? → valExpr
    -- Tuple/parens (disambiguation handled by termList)
    | "(" @nsp term @nsp ")"               → paren
    | "(" @nsp termList @nsp ")"           → tuple
    ;

  termList ::= term ("," @sp term)*        → termList ;
  stmt ::= term ";"? @nl                   → stmtExpr
         | "val" <ident> typeAnn? @sp "=" @sp term ";"? @nl → stmtVal
         | "var" <ident> typeAnn? @sp "=" @sp term ";"? @nl → stmtVar
         ;

-----------------------------------------------------
-- Types
-- Scala type expressions with proper precedence
-- type > unionTy > intersectTy > funTy > atomTy
--
-- BIDIRECTIONAL: parse . print = print . parse = id
-----------------------------------------------------
piece Types
  type ::= unionTy                         → type ;
  
  unionTy ::= intersectTy @sp "|" @sp unionTy → tyUnion
            | intersectTy                  → unionTy
            ;
  
  intersectTy ::= funTy @sp "&" @sp intersectTy → tyIntersect
                | funTy                    → intersectTy
                ;
  
  funTy ::= atomTy @sp "=>" @sp funTy      → tyFun
          | atomTy                         → funTy
          ;
  
  atomTy ::= <ident> @nsp "[" @nsp typeList @nsp "]" → tyApp
           | <ident>                       → tyVar
           | "(" @nsp typeList @nsp ")"    → tyTuple
           | "(" @nsp type @nsp ")"        → tyParen
           | "Any"                         → tyAny
           | "Nothing"                     → tyNothing
           | "Unit"                        → tyUnit
           | "?" @sp "=>" @sp type         → tyContextFun
           ;
  
  typeList ::= type ("," @sp type)*        → typeList ;
  typeAnn ::= @sp ":" @sp type             → typeAnn ;

-----------------------------------------------------
-- Parameters
-- Function/method parameters with defaults and variance
-----------------------------------------------------
piece Parameters
  param ::= <ident> @sp ":" @sp type @sp "=" @sp term → paramDefault
          | <ident> @sp ":" @sp type       → param
          | <ident>                        → paramUntyped
          | "using" <ident> @sp ":" @sp type → paramUsing
          ;
  paramList ::= (param ("," @sp param)*)?  → paramList ;
  
  -- Type parameters with variance and bounds
  typeParam ::= "+" @nsp <ident> boundClause? → typeParamCovar
              | "-" @nsp <ident> boundClause? → typeParamContra
              | <ident> boundClause?       → typeParam
              ;
  boundClause ::= @sp "<:" @sp type        → upperBound
                | @sp ">:" @sp type        → lowerBound
                | @sp "<:" @sp type @sp ">:" @sp type → bothBounds
                ;
  typeParamList ::= "[" @nsp typeParam ("," @sp typeParam)* @nsp "]" → typeParamList ;
  
  -- Visibility modifiers
  visibility ::= "private" scopeQual?      → visPrivate
               | "protected" scopeQual?    → visProtected
               | "override"                → visOverride
               | "final"                   → visFinal
               | "abstract"                → visAbstract
               | "implicit"                → visImplicit
               | "inline"                  → visInline
               | "transparent"             → visTransparent
               ;
  scopeQual ::= "[" <ident> "]"            → scopeQual ;

-----------------------------------------------------
-- Patterns
-- Match patterns
-----------------------------------------------------
piece Patterns
  pattern ::= <ident>                   → patVar
            | "_"                       → patWild
            | <number>                  → patLit
            | <string>                  → patStr
            | <ident> @nsp "(" @nsp patternList @nsp ")" → patCtor
            | "(" @nsp patternList @nsp ")" → patTuple
            | pattern @sp "::" @sp pattern → patCons
            | pattern @sp "@" @sp pattern → patAs
            | pattern @sp ":" @sp type  → patTyped
            ;
  patternList ::= pattern ("," @sp pattern)* → patternList ;
  caseClause ::= "case" pattern guard? @sp "=>" @sp term @nl → caseClause ;
  guard ::= @sp "if" term               → guard ;

-----------------------------------------------------
-- For Comprehension
-----------------------------------------------------
piece ForComprehension
  forGen ::= <ident> @sp "<-" @sp term @nl → forBind
           | "if" term @nl              → forFilter
           | <ident> @sp "=" @sp term @nl → forVal
           ;

-----------------------------------------------------
-- Declarations
-- Top-level declarations with visibility modifiers
-----------------------------------------------------
piece Declarations
  decl ::= 
    -- Annotations
    annotation* declBody                  → decl
    ;
  
  annotation ::= "@" <ident> annotArgs?   → annotation ;
  annotArgs ::= "(" termList? ")"         → annotArgs ;
  
  declBody ::=
    -- Enum (Scala 3 ADT)
    visibility* "enum" <ident> typeParamList? extendsClause? enumCases
      → enumDecl
    -- Sealed trait + case class (Scala 2 style)
    | visibility* "sealed" "trait" <ident> typeParamList? extendsClause? @nl @nl
      → sealedTraitDecl
    | visibility* "case" "class" <ident> typeParamList? @nsp "(" paramList ")" extendsClause? @nl
      → caseClassDecl
    | visibility* "case" "object" <ident> extendsClause? @nl
      → caseObjectDecl
    -- Regular class/object
    | visibility* "class" <ident> typeParamList? @nsp "(" paramList ")" extendsClause? classBody?
      → classDecl
    | visibility* "object" <ident> extendsClause? classBody?
      → objectDecl
    | visibility* "trait" <ident> typeParamList? extendsClause? classBody?
      → traitDecl
    -- Definitions (with body)
    | visibility* "def" <ident> typeParamList? @nsp "(" paramList ")" ":" type "=" @nl @indent term @dedent @nl
      → defDeclBlock
    | visibility* "def" <ident> typeParamList? @nsp "(" paramList ")" ":" type "=" term @nl
      → defDecl
    -- Abstract definitions (no body)
    | visibility* "def" <ident> typeParamList? @nsp "(" paramList ")" ":" type @nl
      → defDeclAbstract
    | visibility* "val" <ident> ":" type "=" term @nl
      → valDecl
    | visibility* "var" <ident> ":" type "=" term @nl
      → varDecl
    | visibility* "lazy" "val" <ident> ":" type "=" term @nl
      → lazyValDecl
    -- Type alias
    | visibility* "type" <ident> typeParamList? "=" type @nl
      → typeAliasDecl
    | visibility* "type" <ident> typeParamList? @nl
      → typeAbstract
    -- Given/using (Scala 3 implicits)
    | "given" <ident>? ":" type "=" term @nl
      → givenDecl
    | "given" <ident>? ":" type "with" classBody
      → givenWithDecl
    -- Extension
    | "extension" @nsp "(" <ident> ":" type ")" @nl @indent defDecl* @dedent
      → extensionDecl
    -- Package/import
    | "package" modulePath @nl
      → packageDecl
    | "import" importPath @nl
      → importDecl
    -- Comments (for generated code)
    | "//" <ident>* @nl
      → lineComment
    ;
  
  classBody ::= "{" @nl @indent member* @dedent "}" @nl → classBody
              | ":" @nl @indent member* @dedent        → classBodyIndent
              ;

  enumCases ::= "{" @nl @indent enumCase* @dedent "}" @nl → enumCases ;
  enumCase ::= "case" <ident> @nsp "(" paramList ")" @nl → enumCaseParams
             | "case" <ident> @nl                       → enumCaseSimple
             ;
  member ::= decl ;
  extendsClause ::= "extends" type withClause* → extendsClause ;
  withClause ::= "with" type                  → withClause ;
  
  -- Import paths with wildcards and selectors
  importPath ::= modulePath importSel?        → importPath ;
  modulePath ::= <ident> ("." <ident>)*       → modulePath ;
  importSel ::= "." "{" importItem ("," importItem)* "}" → importSelMulti
              | "." "*"                       → importAll
              | "." "_"                       → importAllUnderscore
              | "." <ident>                   → importOne
              ;
  importItem ::= <ident> "=>" <ident>         → importRename
               | <ident> "=>" "_"             → importHide
               | <ident>                      → importItem
               | "*"                          → importWild
               ;
  finallyClause ::= "finally" term            → finallyClause ;

-----------------------------------------------------
-- Module
-- Top-level structure
-----------------------------------------------------
piece Module
  module ::= decl*                      → module ;

-----------------------------------------------------
-- Tests
-- Test cases using the new precedence-aware grammar
-----------------------------------------------------
test "var": (var x) ;
test "intLit": (intLit 42) ;
test "strLit": (strLit "hello") ;
test "trueLit": (trueLit) ;
test "add": (addExpr (mulExpr (unaryExpr (postfixExpr (appExpr (var x)))))
                     (addOp (mulExpr (unaryExpr (postfixExpr (appExpr (intLit 1))))))) ;
test "lam": (lam (paramList (param x (tyVar Int))) 
                 (addExpr (mulExpr (unaryExpr (postfixExpr (appExpr (var x)))))
                          (addOp (mulExpr (unaryExpr (postfixExpr (appExpr (intLit 1)))))))) ;
test "app": (appExpr (var foo) (appArg (termList (var x) (var y)))) ;
test "select": (postfixExpr (appExpr (var x)) (select name)) ;
test "match": (postfixExpr (appExpr (var x)) 
                           (matchOp (caseClause (patCtor Some (patternList (patVar v))) (var v))
                                    (caseClause (patVar None) (intLit 0)))) ;
test "tyApp": (tyApp (tyVar List) (typeList (tyVar Int))) ;
test "tyFun": (tyFun (tyVar Int) (tyFun (tyVar Int) (tyVar Int))) ;
test "tyUnion": (tyUnion (tyVar Int) (tyVar String)) ;
test "enumDecl": (decl (enumDecl Term (enumCaseSimple Var) 
                                       (enumCaseParams App (paramList (param f (tyVar Term)) (param a (tyVar Term)))))) ;
test "defDecl": (decl (defDecl id (typeParamList (typeParam A)) (paramList (param x (tyVar A))) (tyVar A) (var x))) ;
test "import": (decl (importDecl (importPath (modulePath scala collection mutable)))) ;
test "packageDecl": (decl (packageDecl (modulePath cubical runtime))) ;

