-----------------------------------------------------
-- rosetta2scala.lego: Transform Rosetta IR to Scala Code
--
-- This transforms the Rosetta intermediate representation into 
-- Scala 3 syntax as defined in Scala.lego.
--
-- Pipeline: Lego source → lego2rosetta → Rosetta IR → rosetta2scala → Scala
--
-- Input: Rosetta constructs (from Rosetta.lego)
-- Output: Scala constructs (from Scala.lego)
--
-- NOTES on Scala-specific concerns:
-- - Use brace syntax {} for multiline definitions (not Python-style colon)
-- - enum cases need explicit constructor syntax (case Foo vs case Foo(x))
-- - for-comprehensions need braces: for { x <- ... } yield ...
-- - Scala 3 extension methods and given/using for implicits
-----------------------------------------------------
import Rosetta
import Scala

lang RosettaToScala :=

-----------------------------------------------------
-- FileTransform
-- Entry point: handle file-level (seq) wrapper
-----------------------------------------------------
piece FileTransform
  -- File is a sequence of declarations - transform each
  @file rule fileToScala: (toScala (seq $decls)) ~~>
    (scalaFile (toScalaDecls $decls)) ;
  
  -- Transform declaration list
  rule declsToScala: (toScalaDecls ($decl $rest)) ~~>
    ((toScalaDecl $decl) (toScalaDecls $rest)) ;
  rule declsToScalaSingle: (toScalaDecls $decl) ~~>
    (toScalaDecl $decl) ;
  
  -- Route declarations to appropriate transformers  
  @decl rule declAdtToScala: (toScalaDecl (adtDef $kw $name $lb $constrs $rb)) ~~>
    (toScala (adtDef $kw $name $lb $constrs $rb)) ;

-----------------------------------------------------
-- ADTTransform
-- Transform Rosetta ADT definitions to Scala sealed trait + case classes
-- Structure: (adtDef "adt" Name "{" constr1 (seq "," constr2) ... "}")
-----------------------------------------------------
piece ADTTransform
  -- adtDef → sealed trait with case classes
  @decl rule adtToScala: (toScala (adtDef $kw $name $lb $constrs $rb)) ~~>
    (sealedTrait $name (toScalaCtors $name $constrs)) ;
  
  -- Transform constructor sequence - handle (seq "," next)
  rule ctorsToScalaSeqComma: (toScalaCtors $parent (seq "," $next)) ~~>
    (toScalaCtors $parent $next) ;
  -- Handle multiple constructors: first constr followed by (seq "," ...)
  rule ctorsToScalaFirst: (toScalaCtors $parent ((constr $name ":" $ty) $rest)) ~~>
    ((caseClass $name (toScalaParams $ty) $parent) (toScalaCtors $parent $rest)) ;
  -- Single constructor
  rule ctorsToScalaSingle: (toScalaCtors $parent (constr $name ":" $ty)) ~~>
    (caseClass $name (toScalaParams $ty) $parent) ;
  rule ctorsToScalaNil: (toScalaCtors $parent ()) ~~> () ;
  
  -- Transform type to params (for constructor fields)
  rule typeToParams: (toScalaParams (typeExpr $left -> $right)) ~~>
    ((toScalaType $left) (toScalaParams $right)) ;
  rule typeToParamsBase: (toScalaParams (typeExpr $t)) ~~> () ;
  rule typeToParamsApp: (toScalaParams (typeApp $t)) ~~> () ;

-----------------------------------------------------
-- CoreTransform
-- Transform Rosetta core terms to Scala terms
-----------------------------------------------------
piece CoreTransform
  -- Universe → Any (Scala's top type)
  rule univToScala: (toScala Univ) ~~> (tyAny) ;
  
  -- Variable → var
  rule varToScala: (toScala (Var $x)) ~~> (var $x) ;
  
  -- Application → app (uncurried)
  rule appToScala: (toScala (App $f $a)) ~~> 
    (app (toScala $f) (termList (toScala $a))) ;
  
  -- Curried application → nested app
  rule appCurriedToScala: (toScala (App (App $f $a) $b)) ~~>
    (app (toScala $f) (termList (toScala $a) (toScala $b))) ;
  
  -- Substitution → val binding in block (with braces)
  rule substToScala: (toScala (Subst $x $s $body)) ~~>
    (blockBraces (stmtVal $x (toScala $s)) (toScala $body)) ;

-----------------------------------------------------
-- BinderTransform
-- Transform Rosetta binders to Scala lambda
-----------------------------------------------------
piece BinderTransform
  -- Lambda → Scala lambda
  rule lamToScala: (toScala (Lam $x . $body)) ~~>
    (lamSimple $x (toScala $body)) ;
  
  -- Typed lambda → lambda with typed param
  rule lamTypedToScala: (toScala (Lam ($x : $A) . $body)) ~~>
    (lam (paramList (param $x (toScalaType $A))) (toScala $body)) ;
  
  -- Pi type → function type
  rule piToScala: (toScala (Pi ($x : $A) $B)) ~~>
    (tyFun (toScalaType $A) (toScalaType $B)) ;
  
  -- Arrow type → function type
  rule arrowToScala: (toScala (Arrow $A $B)) ~~>
    (tyFun (toScalaType $A) (toScalaType $B)) ;

-----------------------------------------------------
-- ProductTransform
-- Transform Rosetta pairs/products to Scala tuples
-----------------------------------------------------
piece ProductTransform
  -- Pair → tuple
  rule pairToScala: (toScala (Pair $a $b)) ~~>
    (tuple (termList (toScala $a) (toScala $b))) ;
  
  -- Fst → ._1
  rule fstToScala: (toScala (Fst $p)) ~~> (fst (toScala $p)) ;
  
  -- Snd → ._2
  rule sndToScala: (toScala (Snd $p)) ~~> (snd (toScala $p)) ;
  
  -- Product type → tuple type
  rule prodToScala: (toScala (Prod $A $B)) ~~>
    (tyTuple (typeList (toScalaType $A) (toScalaType $B))) ;

-----------------------------------------------------
-- ADTTransform
-- Transform Rosetta ADT definitions to Scala enum
-----------------------------------------------------
piece ADTTransform
  -- adtDef → enum (Scala 3 style)
  rule adtToScala: (toScala (adtDef $name { $constrs })) ~~>
    (enumDecl $name (toScalaCases $constrs)) ;
  
  -- Transform constructor list
  rule casesToScala: (toScalaCases ($c $rest)) ~~>
    ((toScalaCase $c) (toScalaCases $rest)) ;
  rule casesToScalaNil: (toScalaCases ()) ~~> () ;
  
  -- Transform single constructor
  -- No args → enumCaseSimple
  rule caseSimpleToScala: (toScalaCase ($name : $ty)) ~~>
    (enumCaseSimple $name)
    when (isBaseType $ty) ;
  
  -- With args → enumCaseParams
  rule caseParamsToScala: (toScalaCase ($name : $ty)) ~~>
    (enumCaseParams $name (toScalaParams $ty)) ;
  
  -- Extract params from arrow type
  rule paramsFromArrow: (toScalaParams (Arrow $A $B)) ~~>
    (paramList (param arg (toScalaType $A)) (toScalaParams $B)) ;
  rule paramsFromBase: (toScalaParams $T) ~~> (paramList) ;

-----------------------------------------------------
-- RewriteTransform
-- Transform Rosetta rewrite rules to Scala defs with match
-----------------------------------------------------
piece RewriteTransform
  -- Rewrite rule → def with pattern match
  rule rewriteToScala: (toScala (rewriteRule $name ":" $pat ~~> $repl)) ~~>
    (defDecl $name
      (paramList (param t (tyVar Term)))
      (tyVar Term)
      (matchExpr (var t)
        (caseClause (toScalaPat $pat) (toScala $repl))
        (caseClause (patWild) (var t)))) ;
  
  -- Pattern transforms
  rule patVarToScala: (toScalaPat (Var $x)) ~~> (patVar $x) ;
  rule patCtorToScala: (toScalaPat ($f $args)) ~~>
    (patCtor $f (toScalaPats $args)) ;
  rule patWildToScala: (toScalaPat _) ~~> (patWild) ;
  rule patsToScala: (toScalaPats ($p $rest)) ~~>
    (patternList (toScalaPat $p) (toScalaPats $rest)) ;
  rule patsToScalaNil: (toScalaPats ()) ~~> (patternList) ;

-----------------------------------------------------
-- JudgmentTransform
-- Transform Rosetta type judgments to Scala (comments/docs)
-----------------------------------------------------
piece JudgmentTransform
  -- Type judgment → documented def returning Boolean
  rule typeToScala: (toScala (typeDecl $name ":" $term ":" $ty when $conds)) ~~>
    (defDecl $name
      (toScalaCondParams $conds)
      (tyVar Boolean)
      (trueLit)) ;
  
  -- Transform conditions to given parameters
  rule condParamsToScala: (toScalaCondParams (($t : $T) $rest)) ~~>
    (paramList (param evidence (tyVar HasType))
               (toScalaCondParams $rest)) ;
  rule condParamsToScalaNil: (toScalaCondParams ()) ~~> (paramList) ;

-----------------------------------------------------
-- TestTransform
-- Transform Rosetta tests to Scala assertions
-----------------------------------------------------
piece TestTransform
  -- test → assert with equals
  rule testToScala: (toScala (testDecl $name ":" $lhs ~~> $rhs)) ~~>
    (defDecl $name
      (paramList)
      (tyUnit)
      (methodCall (var assert)
        (termList (eq (toScala $lhs) (toScala $rhs))))) ;

-----------------------------------------------------
-- ModuleTransform
-- Transform Rosetta modules to Scala objects
-----------------------------------------------------
piece ModuleTransform
  -- module → object
  rule moduleToScala: (toScala (moduleDecl $name { $decls })) ~~>
    (objectDecl $name (toScalaDecls $decls)) ;
  
  -- import → import
  rule importToScala: (toScala (importDecl $name)) ~~>
    (importDecl (modulePath $name) (importAll)) ;
  
  -- Transform decl list
  rule declsToScala: (toScalaDecls ($d $rest)) ~~>
    ((toScala $d) (toScalaDecls $rest)) ;
  rule declsToScalaNil: (toScalaDecls ()) ~~> () ;

-----------------------------------------------------
-- BuiltinTransform
-- Transform Rosetta builtins to Scala equivalents
-----------------------------------------------------
piece BuiltinTransform
  -- Bool
  rule boolTyToScala: (toScalaType Bool) ~~> (tyVar Boolean) ;
  rule trueToScala: (toScala true) ~~> (trueLit) ;
  rule falseToScala: (toScala false) ~~> (falseLit) ;
  
  -- Nat → Int
  rule natTyToScala: (toScalaType Nat) ~~> (tyVar Int) ;
  rule zeroToScala: (toScala zero) ~~> (intLit 0) ;
  rule succToScala: (toScala (succ $n)) ~~> (add (toScala $n) (intLit 1)) ;
  
  -- If-then-else
  rule ifToScala: (toScala (if $c $t $f)) ~~>
    (ifExpr (toScala $c) (toScala $t) (toScala $f)) ;

-----------------------------------------------------
-- ListTransform
-- Transform Rosetta lists to Scala List
-----------------------------------------------------
piece ListTransform
  rule nilToScala: (toScala Nil) ~~> (nilLit) ;
  rule consToScala: (toScala (Cons $h $t)) ~~>
    (cons (toScala $h) (toScala $t)) ;
  rule listToScala: (toScala (List $items)) ~~>
    (listLit (toScalaTermList $items)) ;

-----------------------------------------------------
-- ErrorTransform
-- Transform Rosetta errors to Scala throw
-----------------------------------------------------
piece ErrorTransform
  rule errorToScala: (toScala (Error $msg)) ~~>
    (throwExpr (newExpr RuntimeException (termList (strLit $msg)))) ;
  rule stuckToScala: (toScala (Stuck $t)) ~~>
    (ctorApp Stuck (termList (toScala $t))) ;

-----------------------------------------------------
-- TypeTransform
-- Transform Rosetta types to Scala types
-----------------------------------------------------
piece TypeTransform
  -- Source syntax: typeExpr with arrow
  rule typeExprArrowToScala: (toScalaType (typeExpr $left -> $right)) ~~>
    (tyFun (toScalaType $left) (toScalaType $right)) ;
  -- Source syntax: simple typeExpr
  rule typeExprBaseToScala: (toScalaType (typeExpr $t)) ~~>
    (toScalaType $t) ;
  -- Source syntax: typeApp (type application)
  rule typeAppSingleToScala: (toScalaType (typeApp $t)) ~~>
    (tyVar $t) ;
  rule typeAppMultiToScala: (toScalaType (typeApp $t $args)) ~~>
    (tyApp (toScalaType $t) (toScalaType $args)) ;
  -- IR syntax: Var, App
  rule typeVarToScala: (toScalaType (Var $x)) ~~> (tyVar $x) ;
  rule typeAppToScala: (toScalaType (App $f $a)) ~~>
    (tyApp (toScalaType $f) (typeList (toScalaType $a))) ;
  rule typeUnivToScala: (toScalaType Univ) ~~> (tyAny) ;
  -- Fallback for simple identifiers
  rule typeIdentToScala: (toScalaType $t) ~~> (tyVar $t) ;

-----------------------------------------------------
-- Entry Point
-----------------------------------------------------
piece Entry
  rule transformProgram: (rosettaToScala $program) ~~> (toScala $program) ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------
test "lamToScala": (toScala (Lam x . (Var x))) ~~>
  (lamSimple x (var x)) ;

test "pairToScala": (toScala (Pair (Var a) (Var b))) ~~>
  (tuple (termList (var a) (var b))) ;

test "enumToScala": (toScala (adtDef Option { (None : Option) (Some : (arrowTy Term Option)) })) ~~>
  (enumDecl Option (enumCaseSimple None) (enumCaseParams Some (paramList (param arg (tyVar Term))))) ;

