-----------------------------------------------------
-- Lean.lego: Lean 4 Grammar Definition
--
-- This defines the Lean 4 syntax as a Lego grammar specification.
-- Used for:
-- 1. Parsing .lean files
-- 2. Code generation target (pretty-printing Lean code)
--
-- Note: Reserved keywords (def, end, namespace, etc.) are automatically
-- detected from the grammar literals and tokenized as symbols.
-----------------------------------------------------
lang Lean :=

-----------------------------------------------------
-- Token: Character-level grammar (lexer)
-- Defines Lean-specific tokenization including comments
-----------------------------------------------------
token Token
  -- Basic ASCII character classes
  digit  ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
  lower  ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
           | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
           | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
  upper  ::= 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
           | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
           | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
  alpha  ::= lower | upper | '_' ;
  
  -- Symbol characters (for operators)
  symch  ::= '+' | '-' | '*' | '/' | '=' | '<' | '>' | '!' | '@' | '#'
           | '$' | '%' | '^' | '&' | '|' | '~' | '?' | ':' | ';' | ','
           | '.' | '[' | ']' | '(' | ')' | '{' | '}' | '`' | '\\' ;
  
  -- Identifiers
  ident  ::= alpha (alpha | digit | '\'' | '?' | '!' | '«' | '»')* ;
  
  -- Numbers  
  number ::= digit+ ;
  
  -- String literals
  string ::= '"' strchar* '"' ;
  strchar ::= '\\' escape | alpha | digit | symch | ' ' | '\'' | '\t' ;
  escape ::= 'n' | 't' | 'r' | '\\' | '"' | '\'' | '0' ;
  
  -- Whitespace
  ws     ::= ' ' | '\t' | '\n' | '\r' ;
  
  -- Line comments: -- ...
  comment ::= '-' '-' nonnl* ;
  nonnl  ::= alpha | digit | symch | ' ' | '\t' | '\'' | '"' ;
  
  -- Block comments: /- ... -/
  -- Note: Block comments can contain any characters including '/' and '-'
  -- The tokenizer uses the grammar but manually handles the end sequence
  blockComment ::= '/' '-' blockInner* '-' '/' ;
  blockInner ::= alpha | digit | symch | ' ' | '\t' | '\n' | '\r' | '\'' | '"' | '-' | '/' ;
  
  -- Operators
  operator ::= #longest[
      ':' ':' '=',   -- ::=
      '~' '~' '>',   -- ~~>
      ':' '=',       -- :=
      '~' '>',       -- ~>
      '-' '>',       -- ->
      '→',           -- Unicode arrow
      '<' '-',       -- <-
      '←',           -- Unicode left arrow
      '=' '>',       -- =>
      '⇒',           -- Unicode double arrow
      '|' '>',       -- |>
      '<' '|',       -- <|
      '&' '&',       -- &&
      '|' '|',       -- ||
      '=' '=',       -- ==
      '!' '=',       -- !=
      '<' '=',       -- <=
      '≤',           -- Unicode <=
      '>' '=',       -- >=
      '≥',           -- Unicode >=
      '+' '+',       -- ++
      ':' ':',       -- ::
      '.' '1',       -- .1
      '.' '2',       -- .2
      '∀',           -- forall
      '∃',           -- exists
      'Π',           -- Pi
      'Σ',           -- Sigma
      '×',           -- product
      '⟨',           -- angle bracket open
      '⟩',           -- angle bracket close
      '↑',           -- coercion
      '#' '[',       -- array literal
      '#' 'c' 'h' 'e' 'c' 'k',  -- #check
      '#' 'e' 'v' 'a' 'l',       -- #eval
      '#' 'p' 'r' 'i' 'n' 't',   -- #print
      '@' '[',       -- attribute start
      '@',           -- explicit
      '$',           -- dollar
      '+', '-', '*', '/', '%',
      '<', '>', '=', '!',
      '(', ')', '[', ']', '{', '}',
      ',', '.', ':', ';', '|', '_'
    ] ;

-----------------------------------------------------
-- Core Terms
-- Basic Lean expressions
-- Grammar is structured to avoid left-recursion:
--   term -> arrowExpr -> orExpr -> andExpr -> cmpExpr -> addExpr -> mulExpr -> unaryExpr -> appExpr -> atomExpr
-----------------------------------------------------
piece CoreTerms
  -- Top level: arrow types (right-associative)
  term ::= arrowExpr                              → term ;
  
  arrowExpr ::= orExpr "→" arrowExpr              → arrowTy
              | orExpr "×" arrowExpr              → prodTy
              | orExpr                            → arrowExpr
              ;
  
  -- Logical or
  orExpr ::= andExpr "||" orExpr                  → or
           | andExpr                              → orExpr
           ;
  
  -- Logical and
  andExpr ::= cmpExpr "&&" andExpr                → and
            | cmpExpr                             → andExpr
            ;
  
  -- Comparison operators (non-associative)
  cmpExpr ::= addExpr "==" addExpr                → beq
            | addExpr "!=" addExpr                → bne
            | addExpr "<" addExpr                 → lt
            | addExpr ">" addExpr                 → gt
            | addExpr "<=" addExpr                → le
            | addExpr ">=" addExpr                → ge
            | addExpr                             → cmpExpr
            ;
  
  -- Additive operators (left-to-right via iteration)
  addExpr ::= mulExpr addOp*                      → addExpr ;
  addOp ::= "+" mulExpr                           → addOp
          | "-" mulExpr                           → subOp
          | "++" mulExpr                          → appendOp
          | "::" mulExpr                          → consOp
          ;
  
  -- Multiplicative operators
  mulExpr ::= unaryExpr mulOp*                    → mulExpr ;
  mulOp ::= "*" unaryExpr                         → mulOp
          | "/" unaryExpr                         → divOp
          | "%" unaryExpr                         → modOp
          ;
  
  -- Unary operators
  unaryExpr ::= "-" unaryExpr                     → neg
              | "!" unaryExpr                     → not
              | "↑" unaryExpr                     → coeUp
              | appExpr                           → unaryExpr
              ;
  
  -- Application (juxtaposition, left-associative via iteration)
  -- Includes postfix operators like projections
  appExpr ::= primaryExpr postfixOp*              → appExpr ;
  postfixOp ::= "@" primaryExpr                   → explicitArg
              | argExpr                           → appArg
              | ".1"                              → fstOp
              | ".2"                              → sndOp
              | ".fst"                            → fstOp
              | ".snd"                            → sndOp
              | "." <ident>                       → projOp
              | "$" term                          → dollarOp
              | "|>" term                         → pipeRightOp
              | "<|" term                         → pipeLeftOp
              | "with" "{" fieldAssign* "}"       → structUpdateOp
              ;

  -- Argument expressions: subset of primaryExpr that doesn't include
  -- control-flow keywords (do, if, match, by, fun, let)
  -- This prevents greedy consumption in contexts like "for x in xs do ..."
  argExpr ::=
    -- Universes
    "Type" level?                                 → typeUniv
    | "Prop"                                      → propUniv
    | "Sort" level?                               → sortUniv
    -- Variables and literals
    | <ident>                                     → var
    | <number>                                    → numLit
    | <string>                                    → strLit
    | "true"                                      → trueLit
    | "false"                                     → falseLit
    | "()"                                        → unitLit
    | "Unit.unit"                                 → unitLit
    -- Lists and arrays
    | "[" termList? "]"                           → listLit
    | "#[" termList? "]"                          → arrayLit
    -- Option
    | "none"                                      → noneLit
    | "some" argExpr                              → someLit
    | "Option" argExpr                            → optionTy
    -- Parenthesized expressions (can contain anything)
    | "(" term ")"                                → paren
    | "(" term "," term ")"                       → pair
    -- Anonymous constructors
    | "⟨" termList "⟩"                            → anonCtor
    -- Structure literals
    | "{" fieldAssign* "}"                        → structLit
    -- Hole
    | "_"                                         → hole
    ;
  
  -- Primary expressions (no left recursion)
  primaryExpr ::= 
    -- Universes
    "Type" level?                                 → typeUniv
    | "Prop"                                      → propUniv
    | "Sort" level?                               → sortUniv
    -- Variables and literals
    | <ident>                                     → var
    | <number>                                    → numLit
    | <string>                                    → strLit
    | "true"                                      → trueLit
    | "false"                                     → falseLit
    | "()"                                        → unitLit
    | "Unit.unit"                                 → unitLit
    -- Anonymous dot constructor (type-directed)
    | "." <ident>                                 → dotCtor
    -- Lambda and function
    | "fun" binder+ "=>" term                     → lam
    | "λ" binder+ "=>" term                       → lamUnicode
    -- Pi/forall/sigma types
    | "∀" binder+ "," term                        → forallTy
    | "Π" binder+ "," term                        → piTy
    | "Σ" binder+ "," term                        → sigmaTy
    -- Let expressions
    | "let" <ident> typeAnn? ":=" term "in"? term → letExpr
    | "let" "rec" <ident> typeAnn? ":=" term "in"? term → letRecExpr
    -- Conditionals
    | "if" term "then" term "else" term           → ifExpr
    | "if" "let" pattern ":=" term "then" term "else" term → ifLetExpr
    -- Match (including monadic match with ←)
    | "match" termList "with" matchAlt*           → matchExpr
    | "match" "←" term "with" matchAlt*           → matchBindExpr
    -- Lists and arrays
    | "[" termList? "]"                           → listLit
    | "#[" termList? "]"                          → arrayLit
    -- Option
    | "none"                                      → noneLit
    | "some" primaryExpr                          → someLit
    | "Option" primaryExpr                        → optionTy
    -- Do notation
    | "do" doElem+                                → doBlock
    -- Tactics
    | "by" tactic+                                → byTactic
    -- Parenthesized expressions
    | "(" term ")"                                → paren
    | "(" term "," term ")"                       → pair
    -- Anonymous constructors
    | "⟨" termList "⟩"                            → anonCtor
    -- Structure literals
    | "{" fieldAssign* "}"                        → structLit
    -- Hole and sorry
    | "_"                                         → hole
    | "sorry"                                     → sorryTerm
    | "panic!" <string>                           → panic
    ;

  termList ::= term ("," term)*                   → termList ;
  level ::= <number>                              → levelLit
          | "max" level level                     → levelMax
          | "imax" level level                    → levelIMax
          | level "+" <number>                    → levelSucc
          ;

-----------------------------------------------------
-- Binders
-- Lambda/forall binders
-----------------------------------------------------
piece Binders
  binder ::= <ident>                              → simpleBinder
           | "(" <ident> ":" term ")"             → explicitBinder
           | "{" <ident> ":" term "}"             → implicitBinder
           | "[" <ident> ":" term "]"             → instBinder
           | "(" <ident> ")"                      → parenBinder
           ;
  typeAnn ::= ":" term                            → typeAnn ;

-----------------------------------------------------
-- Patterns
-- Match patterns
-----------------------------------------------------
piece Patterns
  pattern ::= <ident>                             → patVar
            | "_"                                 → patWild
            | <number>                            → patNum
            | <string>                            → patStr
            | "." <ident>                         → patCtor
            | <ident> pattern*                    → patApp
            | "some" pattern                      → patSome
            | "none"                              → patNone
            | "(" patternList ")"                 → patTuple
            | "⟨" patternList "⟩"                 → patAnon
            | "[" patternList? "]"                → patList
            | "#[" patternList? "]"               → patArray
            | pattern "::" pattern                → patCons
            | pattern "+" <number>                → patSucc
            ;
  patternList ::= pattern ("," pattern)*          → patternList ;
  -- Match alternatives can contain either a single term or a sequence of doElems
  matchAlt ::= "|" patternList "=>" doElem+       → matchAltDo
             | "|" patternList "=>" term          → matchAlt
             ;

-----------------------------------------------------
-- Do Notation
-- Monadic do blocks
-----------------------------------------------------
piece DoNotation
  doElem ::= "let" <ident> "←" term               → doLetBind
           | "let" <ident> ":=" term              → doLetPure
           | <ident> "←" term                     → doBind
           | "return" term                        → doReturn
           | "pure" term                          → doPure
           | "if" term "then" doElem+ "else"? doElem* → doIf
           | "for" <ident> "in" appExpr "do" doElem+ → doFor
           | term                                 → doExpr
           ;

-----------------------------------------------------
-- Tactics
-- Proof tactics
-----------------------------------------------------
piece Tactics
  tactic ::= "rfl"                                → tacRfl
           | "sorry"                              → tacSorry
           | "trivial"                            → tacTrivial
           | "decide"                             → tacDecide
           | "assumption"                         → tacAssumption
           | "intro" <ident>*                     → tacIntro
           | "exact" term                         → tacExact
           | "apply" term                         → tacApply
           | "simp" simpArgs?                     → tacSimp
           | "cases" term                         → tacCases
           | "induction" term "with" inductAlt*  → tacInduction
           | "constructor"                        → tacConstructor
           | "rw" "[" rwRule* "]"                 → tacRewrite
           | <ident> term*                        → tacApp
           ;
  simpArgs ::= "[" term* "]"                      → simpArgs ;
  inductAlt ::= "|" <ident> <ident>* "=>" tactic+ → inductAlt ;
  rwRule ::= "←"? term                            → rwRule ;

-----------------------------------------------------
-- Declarations
-- Top-level declarations
-- Note: Layout markers (@nl, @indent, @dedent) are for pretty-printing only.
-- During parsing, they are ignored - block structure is determined by keywords.
-----------------------------------------------------
piece Declarations
  decl ::= 
    -- Inductive types
    "inductive" <ident> param* whereCtors? derivingClause?
      → inductiveDecl
    -- Structures  
    | "structure" <ident> param* extendsClause? "where" fieldDecl* derivingClause?
      → structureDecl
    -- Classes
    | "class" <ident> param* extendsClause? "where" fieldDecl*
      → classDecl
    -- Instances
    | "instance" instName? ":" term "where" fieldDef*
      → instanceDecl
    -- Definitions - these are the key ones
    | "def" <ident> param* typeAnn? whereClause? ":=" term
      → defDecl
    | "partial" "def" <ident> param* typeAnn? ":=" term
      → partialDefDecl
    | "abbrev" <ident> param* typeAnn? ":=" term
      → abbrevDecl
    -- Theorems
    | "theorem" <ident> param* ":" term ":=" term
      → theoremDecl
    | "lemma" <ident> param* ":" term ":=" term
      → lemmaDecl
    | "example" ":" term ":=" term
      → exampleDecl
    -- Namespaces - use 'end' keyword as explicit delimiter
    | "namespace" modulePath nsBody "end" modulePath
      → namespaceDecl
    | "section" <ident>? nsBody "end" <ident>?
      → sectionDecl
    -- Imports and opens  
    | "import" modulePath
      → importDecl
    | "open" modulePath inClause?
      → openDecl
    -- Variables
    | "variable" varDecl+
      → variableDecl
    -- Attributes
    | "attribute" "[" <ident> "]" <ident>
      → attributeDecl
    -- Set options
    | "set_option" modulePath term
      → setOptionDecl
    -- Notation and macros
    | "macro" <ident> param* ":" <ident> ":=" term
      → macroDecl
    | "notation" <string> ":=" term
      → notationDecl
    | "syntax" term* ":" <ident>
      → syntaxDecl
    -- Private/protected modifiers
    | "private" decl
      → privateDecl
    | "protected" decl
      → protectedDecl
    -- @[simp] style attributes
    | "@[" <ident> "]" decl
      → attrDecl
    -- #check, #eval, #print commands
    | "#check" term
      → checkCmd
    | "#eval" term
      → evalCmd
    | "#print" <ident> @nl
      → printCmd
    ;

  param ::= <ident>                               → simpleParam
          | "(" @nsp <ident> ":" term ")" @sp     → explicitParam
          | "{" @nsp <ident> ":" term "}" @sp     → implicitParam
          | "[" @nsp <ident> ":" term "]" @sp     → instParam
          ;
  whereCtors ::= "where" @nl @indent ctor* @dedent → whereCtors ;
  ctor ::= "|" <ident> param* ":" term @nl        → ctor ;
  derivingClause ::= "deriving" <ident> ("," <ident>)* → derivingClause ;
  fieldDecl ::= <ident> ":" term defaultVal?      → fieldDecl ;
  fieldDef ::= <ident> ":=" term                  → fieldDef ;
  -- Field assignments in struct literals
  fieldAssign ::= <ident> ":=" term               → fieldAssign ;
  defaultVal ::= term                             → defaultVal ;
  extendsClause ::= "extends" term                → extendsClause ;
  instName ::= <ident>                            → instName ;
  modulePath ::= <ident> ("." <ident>)*           → modulePath ;
  inClause ::= "in" term                          → inClause ;
  varDecl ::= "(" <ident> ":" term ")"            → explicitVarDecl
            | "{" <ident> ":" term "}"            → implicitVarDecl
            ;
  whereClause ::= "where" letDecl*                → whereClause ;
  letDecl ::= <ident> ":=" term                   → letDecl ;
  -- Namespace body: declarations until 'end' keyword
  nsBody ::= decl*                                → nsBody ;

-----------------------------------------------------
-- Module
-- Top-level module structure
-----------------------------------------------------
piece Module
  module ::= decl*                                → module ;

-----------------------------------------------------
-- Rosetta IR Support
-- These productions PARSE Rosetta IR syntax and PRINT Lean syntax.
-- For printing: the AST structure matches what Rosetta produces.
-- When emitting, we output Lean keywords but consume Rosetta structure.
--
-- Key insight: printGrammar emits literals without consuming AST.
-- So we use the SAME literals that Rosetta uses ("adt", "{", etc.)
-- but they get emitted as-is. To emit DIFFERENT text, we need
-- transformation rules BEFORE printing.
--
-- For now: just accept Rosetta IR and print it (won't look like Lean).
-----------------------------------------------------
piece RosettaIR
  -- Accept adtDef from Rosetta - prints the Rosetta syntax
  rosettaDecl ::= "adt" <ident> rosettaTypeParams? "{" rosettaConstrs "}" → adtDef ;
  rosettaTypeParams ::= "(" rosettaParamGroup* ")" → typeParams | "(" ")" → unit ;
  rosettaParamGroup ::= <ident>+ ":" rosettaType → paramGroup ;
  rosettaConstrs ::= rosettaConstr ("," rosettaConstr)* → seq ;
  rosettaConstr ::= <ident> ":" rosettaType → constr ;
  
  -- Rewrite rule from Rosetta
  rosettaDecl ::= "rewrite" <ident> ":" rosettaTerm "~>" rosettaTerm ";" → rewriteRule ;
  
  -- Type expressions  
  rosettaType ::= rosettaTypeApp (rosettaArrow rosettaType)? → typeExpr ;
  rosettaArrow ::= "→" | "->" ;
  rosettaTypeApp ::= <ident> rosettaType* → typeApp ;
  rosettaType ::= "$" <ident> → typeVar ;
  
  -- Term expressions
  rosettaTerm ::= <ident> rosettaTerm* → app
               | "$" <ident> → metavar
               | <string> → strLit
               | <number> → numLit
               ;
  
  -- A file is a sequence of declarations
  rosettaFile ::= rosettaDecl* → seq ;
  decl ::= rosettaDecl ;

-----------------------------------------------------
-- Tests
-- Syntax validation examples
-----------------------------------------------------
test "lam": (lam (explicitBinder x Nat) (add (var x) (numLit 1))) ;
test "forall": (forallTy (explicitBinder x Type) (arrowTy (var x) (var x))) ;
test "inductive": (inductiveDecl Term (whereCtors (ctor Var (explicitParam x Nat) (var Term)))) ;
test "def": (defDecl id (explicitParam A Type) (explicitParam x (var A)) (typeAnn (var A)) (var x)) ;
test "match": (matchExpr (termList (var x)) (matchAlt (patVar n) (add (var n) (numLit 1)))) ;

