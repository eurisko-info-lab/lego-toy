-- Equational quantum circuit calculus (C12)
-- Based on: "Picturing Quantum Processes" (Coecke & Kissinger)
---------------------------------------------------------

import Quantum ;

-----------------------------------------------------
-- Primitive gates
--
-- Original Agda-style:
--   data Gate : QTy → QTy → Set where
--     H    : Gate QBit QBit
--     X    : Gate QBit QBit
--     CNOT : Gate (Tensor QBit QBit) (Tensor QBit QBit)
-----------------------------------------------------

type Gate-Set : (Gate $A $B) : Set
  when $A : QTy, $B : QTy ;

type H-intro : H : (Gate QBit QBit) ;
type X-intro : X : (Gate QBit QBit) ;
type CNOT-intro : CNOT : (Gate (Tensor QBit QBit) (Tensor QBit QBit)) ;

-----------------------------------------------------
-- Gate application (extends QTm)
--
-- Original Agda-style:
--   data QTm where
--     gate : Gate A B → QTm (G , A) B
-----------------------------------------------------

type gate-intro : (gate $g) : (QTm (ext $G $A) $B)
  when $g : (Gate $A $B), $G : QCtx ;

-----------------------------------------------------
-- Equational laws as paths
--
-- Original Agda-style:
--   H² : Unitary (gate H compose gate H) id
--   H² = refl
--   CNOT² : Unitary (gate CNOT compose gate CNOT) id
--   CNOT² = refl
-----------------------------------------------------

type H²-sig : H² : (Unitary (compose (gate H) (gate H)) id) ;
rule H²-def : H² ~> refl ;

type CNOT²-sig : CNOT² : (Unitary (compose (gate CNOT) (gate CNOT)) id) ;
rule CNOT²-def : CNOT² ~> refl ;

-----------------------------------------------------
-- Sequential composition (categorical)
--
-- Original Agda-style:
--   *compose* : QTm G A → QTm D B → QTm (G , D) B
--   *compose* = {!!}
-----------------------------------------------------

type compose-sig : (compose $t $u) : (QTm (ext $G $D) $B)
  when $t : (QTm $G $A), $u : (QTm $D $B) ;

-- Composition is associative (placeholder)
type compose-assoc : (compose-assoc $t $u $v) : (Path (QTm $Ctx $D) (compose (compose $t $u) $v) (compose $t (compose $u $v)))
  when $t : (QTm $G $A), $u : (QTm $D $B), $v : (QTm $E $C) ;

-----------------------------------------------------
-- Identity circuit
-----------------------------------------------------

type id-intro : id : (QTm (ext $G $A) $A)
  when $G : QCtx, $A : QTy ;

-- id is left/right unit for composition
type id-left : (id-left $t) : (Path (QTm $Ctx $A) (compose id $t) $t)
  when $t : (QTm $G $A) ;
type id-right : (id-right $t) : (Path (QTm $Ctx $A) (compose $t id) $t)
  when $t : (QTm $G $A) ;

-----------------------------------------------------
-- Acceptance predicate
--
-- Original Agda-style:
--   accepts : ∀{G A} → QTm G A → Set
--   accepts t = ∃ nf , eval t ≡ nf
-----------------------------------------------------

type accepts-sig : (accepts $t) : Set
  when $t : (QTm $G $A) ;

-- accepts t = ∃ nf : NF A, eval t ≡ nf
-- Using (Exists T $x . P) for dependent sum
rule accepts-def : (accepts $t) ~> (Exists (NF $A) $nf . (Path (NF $A) (eval $t) $nf))
  when $t : (QTm $G $A) ;

-----------------------------------------------------
-- Evaluation function (placeholder)
-----------------------------------------------------

type eval-sig : (eval $t) : (NF $A)
  when $t : (QTm $G $A) ;
