-- CubicalProofs.lego: Using Cubical Type Theory in .lego files
--
-- This example demonstrates how to leverage cubical TT features:
-- 1. Path types for propositional equality
-- 2. Equivalences for isomorphic representations  
-- 3. Verified rules with cubical proofs
-- 4. Transport and univalence
--
-- These features let language designers:
-- - Prove optimizations preserve semantics
-- - Switch between equivalent representations
-- - Transport properties across isomorphisms

lang CubicalProofs (Lego) :=

-----------------------------------------------------
-- PATH TYPES
-- Identity types with computational content
-----------------------------------------------------

piece PathExamples
  term ::= "Nat"                       → nat
         | "zero"                      → zero
         | "suc" term                  → suc
         | "add" term term             → add
         | "mul" term term             → mul
         | "List" term                 → list
         | "nil"                       → nil
         | "cons" term term            → cons
         | "append" term term          → append
         | "Bool"                      → bool
         | "true"                      → true
         | "false"                     → false ;

  -- Standard evaluation rules
  rule add_zero: (add zero $n) ~> $n ;
  rule add_suc: (add (suc $m) $n) ~> (suc (add $m $n)) ;
  rule append_nil: (append nil $xs) ~> $xs ;
  rule append_cons: (append (cons $x $xs) $ys) ~> (cons $x (append $xs $ys)) ;

-----------------------------------------------------
-- VERIFIED RULES WITH REFLEXIVITY
-- Using refl to prove identity preserving transforms
-----------------------------------------------------

piece ReflProofs
  -- Identity optimization: simplify redundant constructs
  -- add n zero = n (right identity)
  
  -- The proof uses refl: Path Nat (add n zero) (add n zero)
  -- Then we need to show add n zero reduces to n
  verified rule add_zero_right:
    (add $n zero) ~> $n
    via (refl $n) ;

  -- List identity: append xs nil = xs
  verified rule append_nil_right:
    (append $xs nil) ~> $xs
    via (refl $xs) ;

  -- Nested optimization: redundant double negation
  -- not (not b) = b for booleans
  verified rule double_neg:
    (not (not $b)) ~> $b
    via (refl $b) ;

-----------------------------------------------------
-- SYMMETRY PROOFS
-- Using sym to reverse equations
-----------------------------------------------------

piece SymmetryProofs
  term ::= "comm_add_proof" term term  → commAddProof
         | "comm_mul_proof" term term  → commMulProof ;

  -- If we have: add a b = add b a
  -- Then sym gives: add b a = add a b
  
  -- Commutativity of addition
  -- The proof term: sym (comm_add_proof a b) : Path Nat (add b a) (add a b)
  type commAddProofType: (comm_add_proof $a $b) : (Path Nat (add $a $b) (add $b $a))
    when $a : Nat, $b : Nat ;

  -- Verified rule using symmetry
  -- We prove add b a ~> add a b by reversing the commutativity proof
  verified rule comm_add_rev:
    (add $b $a) ~> (add $a $b)
    via (sym (comm_add_proof $a $b)) ;

-----------------------------------------------------
-- TRANSITIVITY PROOFS
-- Using trans to chain equations
-----------------------------------------------------

piece TransitivityProofs
  term ::= "assoc_proof" term term term → assocProof ;

  -- Associativity gives us a chain:
  -- (a + b) + c = a + (b + c)
  -- 
  -- With transitivity we can compose:
  -- If p : x = y and q : y = z, then trans p q : x = z

  type assocProofType: (assoc_proof $a $b $c) 
    : (Path Nat (add (add $a $b) $c) (add $a (add $b $c)))
    when $a : Nat, $b : Nat, $c : Nat ;

  -- Multi-step reasoning: ((a + b) + c) + d = a + (b + (c + d))
  -- Step 1: ((a + b) + c) + d = (a + (b + c)) + d  (assoc on inner)
  -- Step 2: (a + (b + c)) + d = a + ((b + c) + d)  (assoc on outer)  
  -- Step 3: a + ((b + c) + d) = a + (b + (c + d))  (assoc on (b+c)+d)
  
  verified rule add_reassoc:
    (add (add (add $a $b) $c) $d) ~> (add $a (add $b (add $c $d)))
    via (trans (assoc_proof (add $a $b) $c $d) 
         (trans (cong (Lam x . (add x $d)) (assoc_proof $a $b $c))
                (assoc_proof $a $b (add $c $d)))) ;

-----------------------------------------------------
-- CONGRUENCE PROOFS
-- Using cong to apply functions to equalities
-----------------------------------------------------

piece CongruenceProofs
  term ::= "double" term               → double
         | "square" term               → square ;

  rule double_def: (double $n) ~> (add $n $n) ;
  rule square_def: (square $n) ~> (mul $n $n) ;

  -- If a = b, then f(a) = f(b) via cong
  -- cong f p : Path B (f a) (f b)  when p : Path A a b

  -- Verified: if n = m then double n = double m
  -- The proof uses: cong double (proof_n_eq_m)
  
  -- Example: double (add a zero) = double a
  -- We have: add a zero = a (via add_zero_right proof)
  -- Apply cong double: double (add a zero) = double a
  verified rule double_add_zero:
    (double (add $a zero)) ~> (double $a)
    via (cong (Lam n . (double n)) (refl $a)) ;

-----------------------------------------------------
-- EQUIVALENCES
-- Quasi-invertible functions between types
-----------------------------------------------------

piece EquivalenceExamples
  term ::= "BinaryNat"                 → binaryNat
         | "bz"                        → bz
         | "b0" term                   → b0
         | "b1" term                   → b1
         | "nat_to_bin" term           → natToBin
         | "bin_to_nat" term           → binToNat ;

  -- Conversions
  rule nat_to_bin_zero: (nat_to_bin zero) ~> bz ;
  rule bin_to_nat_bz: (bin_to_nat bz) ~> zero ;

  -- Nat ≃ BinaryNat: same information, different representation
  -- idEquiv gives identity: A ≃ A
  -- compEquiv composes: A ≃ B → B ≃ C → A ≃ C
  -- invEquiv inverts: A ≃ B → B ≃ A

  -- Representation equivalence: Nat and BinaryNat are equivalent
  repr Nat ≃ BinaryNat
    via (mkEquiv nat_to_bin bin_to_nat
         (Lam n . (refl n))
         (Lam b . (refl b))) ;

-----------------------------------------------------
-- UNIVALENCE
-- Equivalence → Path in Type
-----------------------------------------------------

piece UnivalenceExamples
  term ::= "Unit"                      → unit
         | "tt"                        → tt
         | "unit_nat_equiv"            → unitNatEquiv ;

  -- ua : Equiv A B → Path Univ A B
  -- This is the univalence axiom: equivalent types are equal types

  -- Example: Bool ≃ Bool via identity
  -- ua (idEquiv Bool) : Path Univ Bool Bool
  -- This reduces to refl Bool

  -- Transport along ua lets us move values between equivalent types:
  -- If e : A ≃ B and a : A, then transport (ua e) a : B

  type unitNatEquivType: unit_nat_equiv : (Equiv Unit Nat) ;

  -- Using ua: Path Univ Unit Nat (unusual but valid if we have the equiv!)
  -- This shows types with equivalence are "the same" in the type theory

-----------------------------------------------------
-- PATH COMBINATORS IN PROOFS
-----------------------------------------------------

piece PathCombinatorProofs
  term ::= "funext_proof" term         → funextProof ;

  -- funExt : ((x : A) → Path B (f x) (g x)) → Path (A → B) f g
  -- Function extensionality: pointwise equal functions are equal

  -- If for all x, f x = g x, then f = g
  
  -- Example: (λn. add n zero) = (λn. n)
  -- Proof: funExt (λn. add_zero_right_proof n)
  type funextProofType: (funext_proof $h) 
    : (Path (Arrow Nat Nat) (Lam n . (add n zero)) (Lam n . n))
    when $h : (Arrow Nat (Path Nat (add $n zero) $n)) ;

-----------------------------------------------------
-- TESTS BLOCK
-----------------------------------------------------

piece Tests
  tests
    -- Basic arithmetic  
    "add_1_2" ~> suc(suc(suc(zero)))
    "add_zero" ~> zero
    
    -- List operations
    "append_nil" ~> nil
    "cons_elem" ~> cons(zero, nil)
    
    -- Binary representation
    "nat_to_bin_zero" ~> bz
  end

-----------------------------------------------------
-- TYPE RULES FOR CUBICAL CONSTRUCTS
-----------------------------------------------------

piece CubicalTypes
  -- Path type formation
  type pathForm: (Path $A $a $b) : Univ when $A : Univ, $a : $A, $b : $A ;
  
  -- refl: a = a
  type reflType: (refl $a) : (Path $A $a $a) when $a : $A ;
  
  -- sym: a = b → b = a  
  type symType: (sym $p) : (Path $A $b $a) when $p : (Path $A $a $b) ;
  
  -- trans: a = b → b = c → a = c
  type transType: (trans $p $q) : (Path $A $a $c) 
    when $p : (Path $A $a $b), $q : (Path $A $b $c) ;
  
  -- cong: a = b → f a = f b
  type congType: (cong $f $p) : (Path $B (App $f $a) (App $f $b))
    when $f : (Arrow $A $B), $p : (Path $A $a $b) ;
  
  -- Equivalence formation
  type equivForm: (Equiv $A $B) : Univ when $A : Univ, $B : Univ ;
  
  -- idEquiv: A ≃ A
  type idEquivType: (idEquiv $A) : (Equiv $A $A) when $A : Univ ;
  
  -- invEquiv: A ≃ B → B ≃ A
  type invEquivType: (invEquiv $e) : (Equiv $B $A) when $e : (Equiv $A $B) ;
  
  -- compEquiv: A ≃ B → B ≃ C → A ≃ C
  type compEquivType: (compEquiv $e1 $e2) : (Equiv $A $C)
    when $e1 : (Equiv $A $B), $e2 : (Equiv $B $C) ;
  
  -- ua: Equiv A B → Path Univ A B (univalence)
  type uaType: (ua $e) : (Path Univ $A $B) when $e : (Equiv $A $B) ;

-----------------------------------------------------
-- ADVANCED: QUOTIENT TYPES
-----------------------------------------------------

piece QuotientTypes
  term ::= "Quot" term term            → quot
         | "quotIn" term               → quotIn
         | "quotEq" term term term     → quotEq ;

  -- Quot A R = A quotiented by equivalence relation R
  -- quotIn a : Quot A R when a : A
  -- quotEq a b p : Path (Quot A R) (quotIn a) (quotIn b) when p : R a b

  -- Example: Integers as Nat × Nat quotiented by (a,b) ~ (c,d) iff a+d = b+c
  
  type quotForm: (Quot $A $R) : Univ when $A : Univ, $R : (Arrow $A (Arrow $A Univ)) ;
  type quotInType: (quotIn $a) : (Quot $A $R) when $a : $A ;
  type quotEqType: (quotEq $a $b $p) : (Path (Quot $A $R) (quotIn $a) (quotIn $b))
    when $a : $A, $b : $A, $p : (App (App $R $a) $b) ;

-----------------------------------------------------
-- SUMMARY
-- 
-- Cubical features available in .lego files:
--
-- PATHS (equality):
--   Path A a b     - the type of paths from a to b in A
--   refl a         - reflexivity proof: a = a
--   sym p          - symmetry: a = b → b = a
--   trans p q      - transitivity: a = b → b = c → a = c
--   cong f p       - congruence: a = b → f a = f b
--   funExt h       - function extensionality
--
-- EQUIVALENCES (isomorphisms):
--   Equiv A B      - the type of equivalences between A and B
--   idEquiv A      - identity: A ≃ A
--   invEquiv e     - inversion: A ≃ B → B ≃ A
--   compEquiv e f  - composition: A ≃ B → B ≃ C → A ≃ C
--
-- UNIVALENCE:
--   ua e           - Equiv A B → Path Univ A B
--
-- USE IN VERIFIED RULES:
--   verified rule name: lhs ~> rhs via proof ;
--   where proof : Path _ lhs rhs
--
-- USE IN REPR EQUIVALENCES:
--   repr A ≃ B via equiv ;
--   where equiv : Equiv A B
-----------------------------------------------------
