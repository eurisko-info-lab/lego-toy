-----------------------------------------------------
-- Lego.Attr: Semantic Extensions via Attribute Grammars
--
-- Architecture:
--   Language = Syntax + Semantics
--   
--   Syntax (bidirectional, structural):
--     Char* ⇌ Token*  (tokenizer/detokenizer)
--     Token* ⇌ AST    (parser/printer)
--   
--   Semantics (forward-only, modular algebras):
--     Attributes are semantic extensions to grammar pieces.
--     Each attribute is a named F-algebra computing one aspect.
--
-- Separation of Concerns:
--   1. DECLARATION - what semantics exist (per piece)
--   2. SELECTION   - which semantics a use-case needs
--   3. STRATEGY    - when/how to compute them
--
-- Mathematical Foundation:
--   Synthesized (Syn) = Catamorphism: cata alg : μF → A
--   Inherited   (Inh) = Paramorphism: para alg : μF → A
--   Both        = Hylomorphism: hylo alg coalg
--
-- See Algebra.rosetta for: FAlgebra, cata, para, ana, hylo
-----------------------------------------------------

import Algebra;

-----------------------------------------------------
-- Semantic Extensions: Attributes as Piece Extensions
--
-- A SemanticAttr declares one semantic aspect (e.g., "type").
-- It attaches F-algebra rules to grammar productions.
-- Multiple attrs can be declared per piece, composed per use.
-----------------------------------------------------

adt SemanticAttr {
  -- A named semantic attribute with rules per production
  MkSemanticAttr : String       -- attribute name
                -> AttrFlow     -- flow direction (Syn/Inh)
                -> List AttrRule -- rules per production
                -> SemanticAttr
}

-- Semantic extension to a grammar piece
adt SemanticPiece {
  -- Piece + its semantic attributes
  MkSemanticPiece : String           -- piece name
                 -> List SemanticAttr -- semantic extensions
                 -> SemanticPiece
}

-- A semantic language bundles pieces with their semantics
adt SemanticLang {
  MkSemanticLang : String              -- language name
                -> List SemanticPiece  -- pieces with semantics
                -> SemanticLang
}

-----------------------------------------------------
-- Use Cases: Semantic Bundles for Different Tools
--
-- A LanguageUse specifies which semantics are needed.
-- Tools request different attribute subsets:
--   LSP     = types + symbols + hover
--   Lint    = warnings + style
--   Compile = types + codegen
--   Format  = layout hints
--   Debug   = source maps
-----------------------------------------------------

adt LanguageUse {
  UseLSP      : LanguageUse,
  UseLint     : LanguageUse,
  UseCompile  : LanguageUse,
  UseFormat   : LanguageUse,
  UseDebug    : LanguageUse,
  UseCustom   : List String -> LanguageUse  -- custom attribute set
}

-- Get required attributes for a use case
rewrite useRequiredAttrs:
  (useRequiredAttrs UseLSP) ~> (List "type" "symbols" "hover" "completion") ;

rewrite useRequiredAttrsLint:
  (useRequiredAttrs UseLint) ~> (List "warnings" "style") ;

rewrite useRequiredAttrsCompile:
  (useRequiredAttrs UseCompile) ~> (List "type" "codegen") ;

rewrite useRequiredAttrsFormat:
  (useRequiredAttrs UseFormat) ~> (List "layout") ;

rewrite useRequiredAttrsDebug:
  (useRequiredAttrs UseDebug) ~> (List "sourcemap" "symbols") ;

rewrite useRequiredAttrsCustom:
  (useRequiredAttrs (UseCustom $attrs)) ~> $attrs ;

-----------------------------------------------------
-- Execution Strategies: When/How to Compute
--
-- Given a language use, we need an execution plan:
--   Interleaved - compute during parsing (streaming)
--   PostHoc     - compute after full parse (batch)
--   Lazy        - compute on demand (query-driven)
--
-- The choice depends on:
--   - Attribute dependencies (some need full tree)
--   - Tool requirements (LSP needs incremental)
--   - Performance (batch is simpler, lazy saves work)
-----------------------------------------------------

adt EvalStrategy {
  Interleaved : EvalStrategy,  -- parse + eval simultaneously
  PostHoc     : EvalStrategy,  -- parse then eval
  Lazy        : EvalStrategy   -- eval on query
}

-- Execution plan: strategy + ordered attribute list
adt ExecutionPlan {
  MkExecutionPlan : EvalStrategy -> List String -> ExecutionPlan
}

-- Plan attribute evaluation based on use and strategy
rewrite planExecution:
  (planExecution $lang $use $strategy) ~>
    (MkExecutionPlan $strategy (sortByDeps $lang (useRequiredAttrs $use))) ;

-- Sort attributes by dependency order (topological)
-- Attributes that depend on others must come after
rewrite sortByDeps:
  (sortByDeps $lang $attrs) ~>
    (topoSort (attrDepGraph $lang $attrs)) ;

-- Build dependency graph from attribute rules
rewrite attrDepGraph:
  (attrDepGraph (MkSemanticLang $name $pieces) $attrs) ~>
    (foldl (graph attr . (addAttrDeps graph attr $pieces)) EmptyDepGraph $attrs) ;

-- Recommend strategy based on use case
rewrite recommendStrategy:
  (recommendStrategy UseLSP)     ~> Lazy ;        -- incremental, on-demand
  
rewrite recommendStrategyLint:
  (recommendStrategy UseLint)    ~> PostHoc ;     -- batch, all warnings
  
rewrite recommendStrategyCompile:
  (recommendStrategy UseCompile) ~> PostHoc ;     -- batch, full codegen
  
rewrite recommendStrategyFormat:
  (recommendStrategy UseFormat)  ~> Interleaved ; -- streaming OK
  
rewrite recommendStrategyDebug:
  (recommendStrategy UseDebug)   ~> Lazy ;        -- on-demand

-----------------------------------------------------
-- Pipeline Integration: Parse Events + Semantic Hooks
--
-- For interleaved evaluation, we hook into parse events:
--   OnShift   - token consumed
--   OnReduce  - production completed
--   OnAccept  - parse complete
--
-- Each event can trigger attribute computation.
-----------------------------------------------------

adt ParseEvent {
  OnShift   : String -> ParseEvent,           -- shifted token
  OnReduce  : String -> List Term -> ParseEvent, -- reduced production
  OnAccept  : Term -> ParseEvent              -- parse complete
}

-- Hook: what to compute on each event
adt SemanticHook {
  MkHook : ParseEvent -> List String -> SemanticHook  -- event → attrs to compute
}

-- Generate hooks from execution plan for interleaved strategy
rewrite generateHooks:
  (generateHooks (MkExecutionPlan Interleaved $attrs)) ~>
    (map (attr . (MkHook (OnReduce "any" Empty) (List $attr))) $attrs) ;

rewrite generateHooksPostHoc:
  (generateHooks (MkExecutionPlan PostHoc $attrs)) ~>
    (List (MkHook (OnAccept (Var "tree")) $attrs)) ;

rewrite generateHooksLazy:
  (generateHooks (MkExecutionPlan Lazy $attrs)) ~>
    Empty ; -- no hooks, compute on explicit query

-----------------------------------------------------
-- Attribute Flow Direction
--
-- Determines which recursion scheme to use:
--   Syn    → cata (bottom-up fold)
--   Inh    → para (top-down with context)
--   SynInh → both passes
-----------------------------------------------------

adt AttrFlow {
  Syn    : AttrFlow,
  Inh    : AttrFlow,
  SynInh : AttrFlow
}

-----------------------------------------------------
-- Attribute Paths and References
-----------------------------------------------------

-- Path to attribute: [] = this node, ["body"] = child body
adt AttrPath {
  Empty   : AttrPath,
  PathCon : String -> AttrPath -> AttrPath
}

-- Reference to an attribute (local or child)
adt AttrRef {
  MkAttrRef : AttrPath -> String -> AttrRef
}

-- AttrRef constructors
rewrite attrRefSelf:
  (attrRefSelf $name) ~> (MkAttrRef Empty $name) ;

rewrite attrRefChild:
  (attrRefChild $child $name) ~> (MkAttrRef (PathCon $child Empty) $name) ;

-----------------------------------------------------
-- Attribute Definitions
-----------------------------------------------------

-- Attribute equation: Production.target = expr
adt AttrRule {
  MkAttrRule : String -> AttrPath -> Term -> AttrRule
}

-- Attribute definition: syn type : Type { rules... }
adt AttrDef {
  MkAttrDef : String -> AttrFlow -> Option Term -> List AttrRule -> AttrDef
}

-- AttrDef constructors
rewrite emptyAttrDef:
  (emptyAttrDef $name $flow) ~> (MkAttrDef $name $flow None Nil) ;

rewrite addAttrRule:
  (addAttrRule (MkAttrDef $name $flow $ty $rules) $rule) ~>
    (MkAttrDef $name $flow $ty (append $rules (Cons $rule Nil))) ;

-----------------------------------------------------
-- Attribute Environment
-----------------------------------------------------

-- Maps (path, attr-name) to computed value
adt AttrEnv {
  EmptyAttrEnv : AttrEnv,
  AttrEnvCons  : AttrPath -> String -> Term -> AttrEnv -> AttrEnv
}

-- Lookup in environment
rewrite attrEnvLookupEmpty:
  (attrEnvLookup Empty $path $name) ~> None ;

rewrite attrEnvLookupFound:
  (attrEnvLookup (AttrEnvCons $path $name $val $rest) $path $name) ~>
    (Some $val) ;

rewrite attrEnvLookupMiss:
  (attrEnvLookup (AttrEnvCons $p1 $n1 $val $rest) $p2 $n2) ~>
    (attrEnvLookup $rest $p2 $n2)
  when (not (and (eq $p1 $p2) (eq $n1 $n2))) ;

-- Insert into environment
rewrite attrEnvInsert:
  (attrEnvInsert $env $path $name $val) ~>
    (AttrEnvCons $path $name $val $env) ;

-- Get local attribute
rewrite attrEnvGetLocal:
  (attrEnvGetLocal $env $name) ~> (attrEnvLookup $env Empty $name) ;

-- Get child attribute
rewrite attrEnvGetChild:
  (attrEnvGetChild $env $child $name) ~>
    (attrEnvLookup $env (PathCon $child Empty) $name) ;

-- Merge environments (second wins)
rewrite attrEnvMergeEmpty:
  (attrEnvMerge $env1 EmptyAttrEnv) ~> $env1 ;

rewrite attrEnvMergeCons:
  (attrEnvMerge $env1 (AttrEnvCons $path $name $val $rest)) ~>
    (attrEnvMerge (AttrEnvCons $path $name $val $env1) $rest) ;

-----------------------------------------------------
-- Attribute Evaluation
-----------------------------------------------------

-- Evaluate attribute expression in environment
rewrite evalAttrExprVar:
  (evalAttrExpr (Var $name) $env) ~>
    (if (startsWith $name "$")
        (match (attrEnvLookup $env Empty (drop 1 $name))
          (Some $v) $v
          None (Con "error" (Cons (Lit (concat "undefined: " $name)) Nil)))
        (Var $name)) ;

rewrite evalAttrExprCon:
  (evalAttrExpr (Con $c $args) $env) ~>
    (Con $c (map (x . (evalAttrExpr $x $env)) $args)) ;

rewrite evalAttrExprLit:
  (evalAttrExpr (Lit $s) $env) ~> (Lit $s) ;

-----------------------------------------------------
-- Find Rule for Production
-----------------------------------------------------

rewrite findRuleEmpty:
  (findRule $prod $target Nil) ~> None ;

rewrite findRuleFound:
  (findRule $prod $target (Cons (MkAttrRule $prod $target $expr) $rest)) ~>
    (Some (MkAttrRule $prod $target $expr)) ;

rewrite findRuleMiss:
  (findRule $prod $target (Cons (MkAttrRule $p2 $t2 $e) $rest)) ~>
    (findRule $prod $target $rest)
  when (not (and (eq $prod $p2) (eq $target $t2))) ;

-----------------------------------------------------
-- Catamorphism: Synthesized Attribute Evaluation
--
-- Uses cata from Algebra.rosetta.
-- Synthesized = bottom-up fold: children evaluated first,
-- then parent rule uses child results.
-----------------------------------------------------

-- Convert AttrDef to FAlgebra for synthesized evaluation
rewrite attrDefToSynAlgebra:
  (attrDefToSynAlgebra (MkAttrDef $attrName $flow $ty $rules)) ~>
    (MkFAlgebra
      (Lam x . EmptyAttrEnv)  -- Var: no attributes
      (Lam s . EmptyAttrEnv)  -- Lit: no attributes
      (Lam prod childEnvs .   -- Con: merge child envs, apply rule
        (let env (foldl attrEnvMerge EmptyAttrEnv childEnvs)
         (match (findRule prod Empty $rules)
           (Some (MkAttrRule $p $t $expr))
             (attrEnvInsert env Empty $attrName (evalAttrExpr $expr env))
           None env)))) ;

-- Evaluate synthesized attribute using cata
rewrite evalSyn:
  (evalSyn $def $term) ~>
    (cata (attrDefToSynAlgebra $def) $term) ;

-- Legacy direct rules (for compatibility)
rewrite evalSynVar:
  (evalSyn $def (Var $x)) ~> EmptyAttrEnv ;

rewrite evalSynLit:
  (evalSyn $def (Lit $s)) ~> EmptyAttrEnv ;

rewrite evalSynCon:
  (evalSyn (MkAttrDef $attrName $flow $ty $rules) (Con $prod $children)) ~>
    (evalSynConHelper $attrName $flow $ty $rules $prod $children 0) ;

-- Helper to process children with index
rewrite evalSynConHelper:
  (evalSynConHelper $attrName $flow $ty $rules $prod $children $idx) ~>
    (let $childEnvs (mapWithIndex (i child . 
         (prefixEnv (concat "child" (toString $i)) 
                    (evalSyn (MkAttrDef $attrName $flow $ty $rules) $child)))
         $children)
     (let $env (foldl attrEnvMerge EmptyAttrEnv $childEnvs)
      (match (findRule $prod Empty $rules)
        (Some (MkAttrRule $p $t $expr))
          (attrEnvInsert $env Empty $attrName (evalAttrExpr $expr $env))
        None $env))) ;

-----------------------------------------------------
-- Paramorphism: Inherited Attribute Evaluation
--
-- Uses para from Algebra.rosetta.
-- Inherited = top-down with context: parent evaluated first,
-- then child rules can reference parent environment.
-----------------------------------------------------

-- Convert AttrDef to ParaAlgebra for inherited evaluation
rewrite attrDefToInhAlgebra:
  (attrDefToInhAlgebra (MkAttrDef $attrName $flow $ty $rules) $parentEnv) ~>
    (MkParaAlgebra
      (Lam x . $parentEnv)        -- Var: inherit parent env
      (Lam s . $parentEnv)        -- Lit: inherit parent env
      (Lam prod childPairs .      -- Con: compute child envs from parent + rules
        (foldWithIndex
          (Lam idx pair env .
            (let child (Fst pair)
             (let childResult (Snd pair)
              (match (findRule prod (PathCon (concat "child" (toString idx)) Empty) $rules)
                (Some (MkAttrRule $p $t $expr))
                  (attrEnvMerge env (attrEnvInsert EmptyAttrEnv $t $attrName (evalAttrExpr $expr env)))
                None (attrEnvMerge env childResult)))))
          $parentEnv
          childPairs))) ;

-- Evaluate inherited attribute using para
rewrite evalInh:
  (evalInh $def $term $parentEnv) ~>
    (para (attrDefToInhAlgebra $def $parentEnv) $term) ;

-- Legacy direct rules (for compatibility)
rewrite evalInhVar:
  (evalInh $def (Var $x) $parentEnv) ~> $parentEnv ;

rewrite evalInhLit:
  (evalInh $def (Lit $s) $parentEnv) ~> $parentEnv ;

rewrite evalInhCon:
  (evalInh (MkAttrDef $attrName $flow $ty $rules) (Con $prod $children) $parentEnv) ~>
    (evalInhConHelper $attrName $flow $ty $rules $prod $children $parentEnv 0) ;

-----------------------------------------------------
-- Combined Evaluation
-----------------------------------------------------

-- Two-pass: inherited (top-down) then synthesized (bottom-up)
rewrite evalAttrs:
  (evalAttrs $defs $term) ~>
    (let $synDefs (filter (d . (eq (attrDefFlow $d) Syn)) $defs)
     (let $inhDefs (filter (d . (eq (attrDefFlow $d) Inh)) $defs)
      (let $inhEnv (foldl (env def . (evalInh $def $term $env)) EmptyAttrEnv $inhDefs)
       (foldl (env def . (attrEnvMerge $env (evalSyn $def $term))) $inhEnv $synDefs)))) ;

-----------------------------------------------------
-- Generic Catamorphism over Term
-----------------------------------------------------

-- cata alg t = alg (fmap (cata alg) (unTerm t))
rewrite cataTermVar:
  (cataTerm $alg (Var $x)) ~> ($alg $x Nil) ;

rewrite cataTermLit:
  (cataTerm $alg (Lit $s)) ~> ($alg $s Nil) ;

rewrite cataTermCon:
  (cataTerm $alg (Con $c $args)) ~>
    ($alg $c (map (a . (cataTerm $alg $a)) $args)) ;

-----------------------------------------------------
-- Generic Paramorphism over Term
-----------------------------------------------------

-- para coalg t = coalg (fmap (λx. (x, para coalg x)) (unTerm t))
rewrite paraTermVar:
  (paraTerm $coalg (Var $x)) ~> ($coalg $x Nil) ;

rewrite paraTermLit:
  (paraTerm $coalg (Lit $s)) ~> ($coalg $s Nil) ;

rewrite paraTermCon:
  (paraTerm $coalg (Con $c $args)) ~>
    ($coalg $c (map (a . (Pair $a (paraTerm $coalg $a))) $args)) ;

-----------------------------------------------------
-- Attributed Language
-----------------------------------------------------

-- Language with attribute definitions
adt AttrLanguage {
  MkAttrLanguage : String -> List GrammarProduction -> List AttrDef -> AttrLanguage
}

-- Get synthesized attributes
rewrite attrLangSynAttrs:
  (attrLangSynAttrs (MkAttrLanguage $name $pieces $attrs)) ~>
    (filter (d . (eq (attrDefFlow $d) Syn)) $attrs) ;

-- Get inherited attributes
rewrite attrLangInhAttrs:
  (attrLangInhAttrs (MkAttrLanguage $name $pieces $attrs)) ~>
    (filter (d . (eq (attrDefFlow $d) Inh)) $attrs) ;

-- Evaluate all attributes
rewrite attrLangEval:
  (attrLangEval (MkAttrLanguage $name $pieces $attrs) $term) ~>
    (evalAttrs $attrs $term) ;

-- Pushout of attributed languages
rewrite attrLangPushout:
  (attrLangPushout (MkAttrLanguage $n1 $p1 $a1) (MkAttrLanguage $n2 $p2 $a2)) ~>
    (MkAttrLanguage (concat (concat $n1 "_") $n2) (append $p1 $p2) (append $a1 $a2)) ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------

test "empty attr env lookup" :
  (attrEnvLookup EmptyAttrEnv Empty "x") ~~> None ;

test "attr env insert and lookup" :
  (attrEnvLookup (AttrEnvCons Empty "x" (Lit "42") EmptyAttrEnv) Empty "x")
  ~~> (Some (Lit "42")) ;

test "attr ref self" :
  (attrRefSelf "type") ~~> (MkAttrRef Empty "type") ;

test "attr ref child" :
  (attrRefChild "body" "type") ~~> (MkAttrRef (PathCon "body" Empty) "type") ;
