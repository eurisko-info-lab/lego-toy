-----------------------------------------------------
-- rosetta2rust.lego: Transform Rosetta AST to Rust AST
--
-- Rosetta is the portable IR; Rust.lego defines Rust syntax.
-- This file bridges them with rewrite rules.
--
-- Usage: 
--   1. Parse .rosetta file with Rosetta.lego grammar
--   2. Apply these rules to transform AST
--   3. Print with Rust.lego grammar
-----------------------------------------------------

lang RosettaToRust :=

-----------------------------------------------------
-- Import declarations
-- Rosetta: (DImport "import" (modulePath (ident Name) ...) ";")
-- Rust: (useItem (usePath Name))
-- Note: Rust uses "use" instead of "import"
-----------------------------------------------------
piece ImportTransformRust
  rule importToRust: (DImport "import" (modulePath (ident $name) $rest) ";")
    ~~> (useItem (usePath $name)) ;

-----------------------------------------------------
-- ADT to Enum
-- Rosetta AST structure from parser:
--   (adtDef "adt" Name (unit|typeParams) "{" constr1 (seq "," constr2)... "}")
--
-- Rust target AST:
--   (enumItem visibility? Name enumVariant1 enumVariant2...)
-- Based on test: (enumItem (pubVis) Term (enumVariantUnit Var) (enumVariantTuple App ...))
-- 
-- Grammar: visibility? "enum" <ident> typeParamList? whereClause? "{" enumVariant* "}"
-----------------------------------------------------
piece AdtToEnumRust
  -- Variadic ADT transformation using @map
  rule adtToEnumRust: (adtDef "adt" $name (unit) "{" $constrs... "}")
    ~~> (enumItem (pubVis) $name @map transformConstrRust $constrs...) ;
  
  -- Helper to normalize seq wrappers from comma-separated constructors
  rule normalizeSeqRust: (transformConstrRust (seq "," $c))
    ~~> (transformConstrRust $c) ;

-----------------------------------------------------
-- Constructor transformation
-- Rosetta: (constr Name ":" Type)
-- Rust grammar: enumVariant ::= <ident> "," | <ident> "(" tupleField* ")" ","
-- For simple types (same as ADT name), use enumVariantUnit
-- For types with args, use enumVariantTuple
--
-- Actual AST from Rosetta parser:
--   Simple: (typeExpr (typeApp GrammarExpr))
--   One arrow: (typeExpr (typeApp A) "->" (typeExpr (typeApp B)) (unit))
--   Two arrows: (typeExpr (typeApp A) "->" (typeExpr (typeApp B) "->" (typeExpr (typeApp C)) (unit)) (unit))
--   Note: The trailing (unit) comes from the optional (typeArrow type)? in the grammar
-----------------------------------------------------
piece ConstrTransformRust
  -- Constructor with simple type (no args) -> enumVariantUnit
  -- Pattern: (constr Name ":" (typeExpr (typeApp ReturnType)))
  rule transformConstrRustSimple: (transformConstrRust (constr $name ":" (typeExpr (typeApp $type))))
    ~~> (enumVariantUnit $name) ;

  -- Constructor with ONE arrow: A -> Result (with trailing unit)
  rule transformConstrRustOneArg: (transformConstrRust (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $ret)) (unit))))
    ~~> (enumVariantTuple $name (tupleField (tyPath $a))) ;

  -- Constructor with ONE arrow where arg is type application: List Term -> Result (with trailing unit)
  rule transformConstrRustOneArgApp: (transformConstrRust (constr $name ":" (typeExpr (typeApp $a $aArg) "->" (typeExpr (typeApp $ret)) (unit))))
    ~~> (enumVariantTuple $name (tupleField (tyGeneric $a (typeList (tyPath $aArg))))) ;

  -- Constructor with TWO arrows: A -> B -> Result (with nested units)
  rule transformConstrRustTwoArgs: (transformConstrRust (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $b) "->" (typeExpr (typeApp $ret)) (unit)) (unit))))
    ~~> (enumVariantTuple $name (tupleField (tyPath $a)) (tupleField (tyPath $b))) ;

  -- Constructor with TWO arrows, second arg is type app: A -> List B -> Result (with nested units)
  rule transformConstrRustTwoArgsSecondApp: (transformConstrRust (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $b $bArg) "->" (typeExpr (typeApp $ret)) (unit)) (unit))))
    ~~> (enumVariantTuple $name (tupleField (tyPath $a)) (tupleField (tyGeneric $b (typeList (tyPath $bArg))))) ;

  -- Constructor with THREE arrows: A -> B -> C -> Result (with nested units)
  rule transformConstrRustThreeArgs: (transformConstrRust (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $b) "->" (typeExpr (typeApp $c) "->" (typeExpr (typeApp $ret)) (unit)) (unit)) (unit))))
    ~~> (enumVariantTuple $name (tupleField (tyPath $a)) (tupleField (tyPath $b)) (tupleField (tyPath $c))) ;

  -- Direct pass through (fallback)
  rule transformConstrRustDirect: (constr $name ":" $type)
    ~~> (enumVariantUnit $name) ;

-----------------------------------------------------
-- Type wrapping for Rust's grammar (for other contexts)
-----------------------------------------------------
piece TypeWrapRust
  rule wrapTypeRustApp: (wrapTypeRust (typeExpr (typeApp $name)))
    ~~> (tyPath $name) ;
  
  rule wrapTypeRustSimple: (wrapTypeRust (typeApp $name))
    ~~> (tyPath $name) ;

  rule wrapTypeRustAppTwo: (wrapTypeRust (typeExpr (typeApp $name $arg)))
    ~~> (tyGeneric $name (typeList (tyPath $arg))) ;

  rule wrapTypeRustExpr: (wrapTypeRust (typeExpr $inner $rest))
    ~~> (tyPath $inner) ;

-----------------------------------------------------
-- Rewrite Rule transformation
-- Rosetta: (rewriteRule "rewrite" name ":" lhs "~>" rhs ";")
-- Rust: fn name(x: Term) -> Term { match x { pattern => rhs } }
--
-- Rosetta compound AST: (compound "(" f arg1 arg2... ")")
-----------------------------------------------------
piece RewriteTransformRust
  -- Simple rewrite: (fname (Ctor $vars...)) ~> body
  rule rewriteToFnRust: (rewriteRule "rewrite" $name ":" (compound "(" $fname $arg ")") "~>" $rhs ";")
    ~~> (fnItem (pubVis) $name (paramList (param "x" (tyPath Term))) (returnType (tyPath Term))
              (block (stmtList (matchExpr (var "x") 
                (matchArm (transformPatternRust $arg) (transformTermRust $rhs)))))) ;

  -- Fallback: produce a comment
  rule rewriteToCommentRust: (rewriteRule "rewrite" $name ":" $lhs "~>" $rhs ";")
    ~~> (lineComment "//" "rewrite" $name) ;

-----------------------------------------------------
-- Pattern transformation (Rosetta patterns to Rust patterns)
-----------------------------------------------------
piece PatternTransformRust
  -- Metavariable: (metavar "$" x) becomes x
  rule transformPatternRustMeta: (transformPatternRust (metavar "$" $x))
    ~~> (patIdent $x) ;

  -- Constructor pattern: (compound "(" Ctor args... ")")
  rule transformPatternRustCtor: (transformPatternRust (compound "(" $ctor $args... ")"))
    ~~> (patTupleStruct $ctor @map transformPatternRust $args...) ;

  -- Simple identifier
  rule transformPatternRustIdent: (transformPatternRust $x)
    ~~> (patIdent $x) ;

-----------------------------------------------------
-- Term transformation (Rosetta terms to Rust terms)
-----------------------------------------------------
piece TermTransformRust
  -- Metavariable: (metavar "$" x) becomes var x
  rule transformTermRustMeta: (transformTermRust (metavar "$" $x))
    ~~> (var $x) ;

  -- Constructor/Application: (compound "(" f args... ")")
  rule transformTermRustApp: (transformTermRust (compound "(" $f $args... ")"))
    ~~> (callExpr (var $f) @map transformTermRust $args...) ;

  -- Simple identifier
  rule transformTermRustIdent: (transformTermRust $x)
    ~~> (var $x) ;

