-----------------------------------------------------
-- rosetta2haskell.lego: Transform Rosetta AST to Haskell AST
--
-- Rosetta is the portable IR; Haskell.lego defines Haskell syntax.
-- This file bridges them with rewrite rules.
--
-- Usage: 
--   1. Parse .rosetta file with Rosetta.lego grammar
--   2. Apply these rules to transform AST
--   3. Print with Haskell.lego grammar
-----------------------------------------------------

lang RosettaToHaskell :=

-----------------------------------------------------
-- Import declarations
-- Rosetta: (DImport "import" (modulePath (ident Grammar) (unit)) ";")
-- Haskell: (importDecl (modulePath Grammar))
-- Note: Rosetta modulePath wraps idents, Haskell expects bare idents
-----------------------------------------------------
piece ImportTransformHaskell
  rule importToHaskell: (DImport "import" (modulePath (ident $name) $rest) ";")
    ~~> (importDecl (modulePath $name)) ;

-----------------------------------------------------
-- ADT to Data Declaration
-- Rosetta AST structure from parser:
--   (adtDef "adt" Name (unit|typeParams) "{" constr1 (seq "," constr2)... "}")
--
-- Haskell target AST:
--   (dataDecl Name tyVarList? dataCon1 dataCon2...)
-- Based on test: (dataDecl Maybe (tyVarList a) (dataCon Nothing) (dataCon Just (tyVar a)))
-- 
-- Grammar: "data" <ident> tyVarList? @nl @indent "=" dataCon @nl ("|" dataCon @nl)* @dedent
-----------------------------------------------------
piece AdtToData
  -- Variadic ADT transformation using @map
  rule adtToData: (adtDef "adt" $name (unit) "{" $constrs... "}")
    ~~> (dataDecl $name @map transformConstrHaskell $constrs...) ;
  
  -- Helper to normalize seq wrappers from comma-separated constructors
  rule normalizeSeqHaskell: (transformConstrHaskell (seq "," $c))
    ~~> (transformConstrHaskell $c) ;

-----------------------------------------------------
-- Constructor transformation
-- Rosetta: (constr Name ":" Type)
-- Haskell grammar: dataCon ::= <ident> type*
-- dataCon has name followed by zero or more types
--
-- Actual AST from Rosetta parser:
--   Simple: (typeExpr (typeApp GrammarExpr))
--   One arrow: (typeExpr (typeApp A) "->" (typeExpr (typeApp B)) (unit))
--   Two arrows: (typeExpr (typeApp A) "->" (typeExpr (typeApp B) "->" (typeExpr (typeApp C)) (unit)) (unit))
--   Note: The trailing (unit) comes from the optional (typeArrow type)? in the grammar
-----------------------------------------------------
piece ConstrTransformHaskell
  -- Constructor with simple type (no args) -> dataCon with no type args
  -- Pattern: (constr Name ":" (typeExpr (typeApp ReturnType)))
  rule transformConstrHaskellSimple: (transformConstrHaskell (constr $name ":" (typeExpr (typeApp $type))))
    ~~> (dataCon $name) ;

  -- Constructor with ONE arrow: A -> Result (with trailing unit)
  rule transformConstrHaskellOneArg: (transformConstrHaskell (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $ret)) (unit))))
    ~~> (dataCon $name (tyVar $a)) ;

  -- Constructor with ONE arrow where arg is type application: List Term -> Result (with trailing unit)
  rule transformConstrHaskellOneArgApp: (transformConstrHaskell (constr $name ":" (typeExpr (typeApp $a $aArg) "->" (typeExpr (typeApp $ret)) (unit))))
    ~~> (dataCon $name (tyApp $a (tyVar $aArg))) ;

  -- Constructor with TWO arrows: A -> B -> Result (with nested units)
  rule transformConstrHaskellTwoArgs: (transformConstrHaskell (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $b) "->" (typeExpr (typeApp $ret)) (unit)) (unit))))
    ~~> (dataCon $name (tyVar $a) (tyVar $b)) ;

  -- Constructor with TWO arrows, second arg is type app: A -> List B -> Result (with nested units)
  rule transformConstrHaskellTwoArgsSecondApp: (transformConstrHaskell (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $b $bArg) "->" (typeExpr (typeApp $ret)) (unit)) (unit))))
    ~~> (dataCon $name (tyVar $a) (tyApp $b (tyVar $bArg))) ;

  -- Constructor with THREE arrows: A -> B -> C -> Result (with nested units)
  rule transformConstrHaskellThreeArgs: (transformConstrHaskell (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $b) "->" (typeExpr (typeApp $c) "->" (typeExpr (typeApp $ret)) (unit)) (unit)) (unit))))
    ~~> (dataCon $name (tyVar $a) (tyVar $b) (tyVar $c)) ;

  -- Constructor with FOUR arrows: A -> B -> C -> D -> Result
  -- For LoadedGrammar: List Production -> List Production -> List String -> String -> LoadedGrammar
  rule transformConstrHaskellFourArgs: (transformConstrHaskell (constr $name ":" (typeExpr (typeApp $a $aArg) "->" (typeExpr (typeApp $b $bArg) "->" (typeExpr (typeApp $c $cArg) "->" (typeExpr (typeApp $d) "->" (typeExpr (typeApp $ret)) (unit)) (unit)) (unit)) (unit))))
    ~~> (dataCon $name (tyApp $a (tyVar $aArg)) (tyApp $b (tyVar $bArg)) (tyApp $c (tyVar $cArg)) (tyVar $d)) ;

  -- Direct pass through (fallback) 
  rule transformConstrHaskellDirect: (constr $name ":" $type)
    ~~> (dataCon $name) ;

-----------------------------------------------------
-- Type wrapping for Haskell's grammar (for other contexts)
-----------------------------------------------------
piece TypeWrapHaskell
  rule wrapTypeHaskellApp: (wrapTypeHaskell (typeExpr (typeApp $name)))
    ~~> (tyVar $name) ;
  
  rule wrapTypeHaskellSimple: (wrapTypeHaskell (typeApp $name))
    ~~> (tyVar $name) ;

  rule wrapTypeHaskellAppTwo: (wrapTypeHaskell (typeExpr (typeApp $name $arg)))
    ~~> (tyApp $name (tyVar $arg)) ;

  rule wrapTypeHaskellExpr: (wrapTypeHaskell (typeExpr $inner $rest))
    ~~> (tyVar $inner) ;

-----------------------------------------------------
-- Rewrite Rule transformation
-- Rosetta: (rewriteRule "rewrite" name ":" lhs "~>" rhs ";")
-- Haskell: name pattern = rhs
--
-- Rosetta compound AST: (compound "(" f arg1 arg2... ")")
-----------------------------------------------------
piece RewriteTransformHaskell
  -- Simple rewrite: (fname (Ctor $vars...)) ~> body
  rule rewriteToFunHaskell: (rewriteRule "rewrite" $name ":" (compound "(" $fname $arg ")") "~>" $rhs ";")
    ~~> (funDecl $name (transformPatternHaskell $arg) (transformTermHaskell $rhs)) ;

  -- Fallback: produce a comment
  rule rewriteToCommentHaskell: (rewriteRule "rewrite" $name ":" $lhs "~>" $rhs ";")
    ~~> (comment "--" "rewrite" $name) ;

-----------------------------------------------------
-- Pattern transformation (Rosetta patterns to Haskell patterns)
-----------------------------------------------------
piece PatternTransformHaskell
  -- Metavariable: (metavar "$" x) becomes x
  rule transformPatternHaskellMeta: (transformPatternHaskell (metavar "$" $x))
    ~~> (patVar $x) ;

  -- Constructor pattern: (compound "(" Ctor args... ")")
  rule transformPatternHaskellCtor: (transformPatternHaskell (compound "(" $ctor $args... ")"))
    ~~> (patCtor $ctor @map transformPatternHaskell $args...) ;

  -- Simple identifier
  rule transformPatternHaskellIdent: (transformPatternHaskell $x)
    ~~> (patVar $x) ;

-----------------------------------------------------
-- Term transformation (Rosetta terms to Haskell terms)
-- Haskell uses curried (binary) application: f x y = ((f x) y)
-- So (app e1 e2) not (app f x y...)
-----------------------------------------------------
piece TermTransformHaskell
  -- Metavariable: (metavar "$" x) becomes var x
  rule transformTermHaskellMeta: (transformTermHaskell (metavar "$" $x))
    ~~> (var $x) ;

  -- Constructor/Application: (compound "(" f args... ")")
  -- Build left-associative curried application
  rule transformTermHaskellApp: (transformTermHaskell (compound "(" $f $args... ")"))
    ~~> (foldApp (var $f) $args...) ;

  -- Simple identifier
  rule transformTermHaskellIdent: (transformTermHaskell $x)
    ~~> (var $x) ;

-----------------------------------------------------
-- Fold application helper for curried Haskell apps
-- foldApp acc arg1 arg2... -> (app (app acc arg1) arg2)...
-- Note: compound args need paren wrapping for correct grouping
-----------------------------------------------------
piece FoldAppHaskell
  -- Base case: no more args, return accumulator
  rule foldAppBase: (foldApp $acc)
    ~~> $acc ;

  -- Compound arg: wrap in parens
  rule foldAppStepCompound: (foldApp $acc (compound "(" $inner... ")") $rest...)
    ~~> (foldApp (app $acc (paren (transformTermHaskell (compound "(" $inner... ")")))) $rest...) ;

  -- Simple arg (metavar or ident): no parens needed
  rule foldAppStepSimple: (foldApp $acc $arg $rest...)
    ~~> (foldApp (app $acc (transformTermHaskell $arg)) $rest...) ;

