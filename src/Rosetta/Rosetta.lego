-----------------------------------------------------
-- Rosetta: Bidirectional Translation Layer
--
-- Extends Lego with:
-- - Partial Isomorphisms (bidirectional transforms)
-- - Grammar representation (parsing/printing)
-- - Language-to-language translation via universal AST
--
-- Inherits from Lego: CorePrimitives, Binders, Products,
-- ADTDef, RewriteRules, Judgments, Tests, Modules, 
-- Errors, Annotations, Builtins
-----------------------------------------------------

lang Rosetta (Lego) :=

-----------------------------------------------------
-- Partial Isomorphisms
-- Bidirectional transformations with forward/backward
-----------------------------------------------------

piece Isomorphisms
  term ::= "iso" term term             → iso       -- iso fwd bwd
         | "forward" term term         → forward   -- forward iso x
         | "backward" term term        → backward  -- backward iso x
         | "comp" term term            → isoComp   -- iso composition
         | "sym" term                  → isoSym ;  -- iso reversal

  rule isoForward: (forward (iso $fwd $bwd) $x) ~~> (App $fwd $x) ;
  rule isoBackward: (backward (iso $fwd $bwd) $x) ~~> (App $bwd $x) ;
  rule isoCompFwd: (forward (comp (iso $f1 $b1) (iso $f2 $b2)) $x) ~~>
    (forward (iso $f2 $b2) (forward (iso $f1 $b1) $x)) ;
  rule isoSym: (sym (iso $fwd $bwd)) ~~> (iso $bwd $fwd) ;

-----------------------------------------------------
-- Grammar Representation
-- Abstract grammars for parsing/printing
-----------------------------------------------------

piece Grammars
  term ::= "Terminal" <string>         → terminal
         | "NonTerminal" <ident>       → nonTerminal
         | "Epsilon"                   → epsilon
         | "Seq" term term             → seqSym
         | "Alt" term term             → altSym
         | "Star" term                 → star
         | "Production" <ident> term <ident> → production
         | "Grammar" term*             → grammar ;

-----------------------------------------------------
-- Language Definition
-- A language is a grammar + parse/print iso
-----------------------------------------------------

piece Languages
  term ::= "Language" <ident> term term → language ;  -- Language name grammar iso

  -- Core Rosetta operation: translate between languages
  rule translate: (translate (Language $n1 $g1 $iso1) (Language $n2 $g2 $iso2) $src) ~~>
    (forward $iso2 (backward $iso1 $src)) ;

  -- Round-trip property
  rule roundtrip: (roundtrip (Language $n $g $iso) $src) ~~>
    (forward $iso (backward $iso $src)) ;

-----------------------------------------------------
-- File Structure
-- Top-level .rosetta file (uses Lego's decl types)
-----------------------------------------------------

piece File
  rosettaFile ::= decl* ;
  decl ::= adtDecl | algebraDecl | typeclassDecl | rewriteDecl | testDecl | moduleDecl | importDecl ;
  
  -- ADT declaration: adt Name (params) { Ctor1 : Type Ctor2 : Type }
  -- Constructors MUST be separated by commas to avoid type ambiguity
  -- (appType is greedy and would parse "Term Lit" as a type application)
  adtDecl ::= "adt" <ident> typeParams? "{" constr ("," constr)* "}" → adtDef ;
  typeclassDecl ::= "type" <ident> ":" "$" <ident> "when" methodDecl ("," methodDecl)* ";" → typeclassDecl ;
  methodDecl ::= "hasMethod" <ident> ":" type → methodDecl ;
  typeParams ::= "(" paramGroup ("," paramGroup)* ")" → typeParams
              |  "(" paramGroup+ ")" → typeParams ;
  paramGroup ::= <ident>+ ":" type → paramGroup ;
  constr ::= <ident> ":" type → constr ;
  
  -- Algebra declaration: algebra Name for Type { laws... }
  algebraDecl ::= "algebra" <ident> "for" <ident> "{" algebraLaw* "}" → algebraDecl ;
  algebraLaw ::= <ident> ":" term "=" term ";" → algebraLaw ;
  
  -- Type: avoid left recursion by making -> right-associative
  -- Support type application: F a b is (F a) b
  -- Accept both ASCII "->" and Unicode "→" arrows, and product types with "×"
  type ::= appType (typeArrow type)? → typeExpr ;
  typeArrow ::= "->" | "→" ;
  appType ::= baseType+ → typeApp ;
  baseType ::= <ident> | "$" <ident> → typeVar | "(" type "×" type ")" → prodType | "(" type ")" ;
  
  -- Rewrite rule: rewrite name: pattern ~> template ;
  rewriteDecl ::= "rewrite" <ident> ":" pattern "~>" term guardClause? ";" → rewriteRule ;
  guardClause ::= "when" term → guard ;
  pattern ::= term | "_" → wildcard ;
  
  -- Term expressions (S-expressions with binder support)
  -- Supports: atoms, applications, binders (x . body), case expressions, and compound expressions
  term ::= caseExpr | binder | compound | atom ;
  caseExpr ::= "(" "case" term caseArm+ ")" → caseExpr ;
  caseArm ::= "(" <ident> casePatArg* ")" "=>" term → caseArm
            | <ident> "=>" term → caseArm ;
  casePatArg ::= "$" <ident> → metavar | <ident> → ident ;
  binder ::= <ident> "." term → binder ;
  compound ::= "(" term+ ")" → compound ;
  atom ::= <ident> | "$" <ident> → metavar | <string> | <number> ;
  
  -- Test declaration
  testDecl ::= "test" <string> ":" term "~~>" term ";" → testDecl ;
  
  -- Module declaration
  moduleDecl ::= "module" <ident> "{" decl* "}" → moduleDecl ;
  
  -- Import declaration  
  importDecl ::= "import" <ident> ";" → importDecl ;
