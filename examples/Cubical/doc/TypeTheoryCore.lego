-----------------------------------------------------
-- TypeTheoryCore.lego: Core type theory implementation
--
-- A simplified version of TypeTheoryFromMath that uses
-- only syntax supported by the current tolean generator.
--
-- This implements:
-- - Contexts and types
-- - Terms with de Bruijn indices
-- - Substitution and shifting
-- - Bidirectional type checking
-- - Normalization by evaluation
-- - Conversion checking
-----------------------------------------------------

import Lego.Algebra ;

lang TypeTheoryCore :=

-----------------------------------------------------
-- CONTEXTS
-----------------------------------------------------
piece Ctx
  ctx ::= "ctxEmpty" → ctxEmpty
        | "ctxExtend" ctx type → ctxExtend ;
  
  -- Context lookup
  rule lookupZero: (ctxLookup (ctxExtend $Γ $A) 0) ~> $A ;
  rule lookupSucc: (ctxLookup (ctxExtend $Γ $A) (succ $n)) ~> (ctxLookup $Γ $n) ;

-----------------------------------------------------
-- UNIVERSE LEVELS
-----------------------------------------------------
piece Level
  level ::= "lzero" → lzero
          | "lsuc" level → lsuc
          | "lmax" level level → lmax ;
  
  rule lmaxIdem: (lmax $l $l) ~> $l ;
  rule lmaxZeroL: (lmax lzero $l) ~> $l ;
  rule lmaxZeroR: (lmax $l lzero) ~> $l ;
  rule lmaxComm: (lmax $l $m) ~> (lmax $m $l) ;

-----------------------------------------------------
-- TYPES
-----------------------------------------------------
piece Type
  type ::= "tyBase" → tyBase
         | "tyArr" type type → tyArr
         | "tyPi" type type → tyPi
         | "tySigma" type type → tySigma
         | "tyUniv" level → tyUniv ;
  
  -- Arrow is non-dependent Pi
  rule arrToPi: (tyArr $A $B) ~> (tyPi $A (tyWeaken $B)) when ($B not free in 0) ;

-----------------------------------------------------
-- TERMS (de Bruijn indexed)
-----------------------------------------------------
piece Term
  term ::= "tmVar" <number> → tmVar
         | "tmLam" term → tmLam
         | "tmApp" term term → tmApp
         | "tmPair" term term → tmPair
         | "tmFst" term → tmFst
         | "tmSnd" term → tmSnd
         | "tmLet" type term term → tmLet ;
  
  -- Beta reduction
  rule beta: (tmApp (tmLam $body) $arg) ~> (tmSubst $body $arg) ;
  
  -- Eta (when possible)
  rule etaLam: (tmLam (tmApp $f (tmVar 0))) ~> $f when ($f not free in 0) ;
  
  -- Sigma elimination
  rule fstBeta: (tmFst (tmPair $a $b)) ~> $a ;
  rule sndBeta: (tmSnd (tmPair $a $b)) ~> $b ;
  rule pairEta: (tmPair (tmFst $p) (tmSnd $p)) ~> $p ;
  
  -- Let elimination
  rule letBeta: (tmLet $A $v $body) ~> (tmSubst $body $v) ;

-----------------------------------------------------
-- SUBSTITUTION
-----------------------------------------------------
piece Subst
  subst ::= "substId" → substId
          | "substCons" term subst → substCons
          | "substWeak" subst → substWeak
          | "substComp" subst subst → substComp ;
  
  -- Single substitution: subst t[s] 
  rule substVar0: (tmSubst (tmVar 0) $v) ~> $v ;
  rule substVarS: (tmSubst (tmVar (succ $n)) $v) ~> (tmVar $n) ;
  rule substLam: (tmSubst (tmLam $body) $v) ~> (tmLam (tmSubst $body (tmShift $v))) ;
  rule substApp: (tmSubst (tmApp $f $a) $v) ~> (tmApp (tmSubst $f $v) (tmSubst $a $v)) ;
  rule substPair: (tmSubst (tmPair $a $b) $v) ~> (tmPair (tmSubst $a $v) (tmSubst $b $v)) ;
  rule substFst: (tmSubst (tmFst $p) $v) ~> (tmFst (tmSubst $p $v)) ;
  rule substSnd: (tmSubst (tmSnd $p) $v) ~> (tmSnd (tmSubst $p $v)) ;
  
  -- Shifting (weakening)
  rule shiftVar: (tmShift (tmVar $n)) ~> (tmVar (succ $n)) ;
  rule shiftLam: (tmShift (tmLam $body)) ~> (tmLam (tmShift $body)) ;
  rule shiftApp: (tmShift (tmApp $f $a)) ~> (tmApp (tmShift $f) (tmShift $a)) ;
  rule shiftPair: (tmShift (tmPair $a $b)) ~> (tmPair (tmShift $a) (tmShift $b)) ;
  rule shiftFst: (tmShift (tmFst $p)) ~> (tmFst (tmShift $p)) ;
  rule shiftSnd: (tmShift (tmSnd $p)) ~> (tmSnd (tmShift $p)) ;
  
  -- Type substitution
  rule tySubstBase: (tySubst tyBase $v) ~> tyBase ;
  rule tySubstArr: (tySubst (tyArr $A $B) $v) ~> (tyArr (tySubst $A $v) (tySubst $B $v)) ;
  rule tySubstPi: (tySubst (tyPi $A $B) $v) ~> (tyPi (tySubst $A $v) (tySubst $B (tmShift $v))) ;
  rule tySubstSigma: (tySubst (tySigma $A $B) $v) ~> (tySigma (tySubst $A $v) (tySubst $B (tmShift $v))) ;
  rule tySubstUniv: (tySubst (tyUniv $l) $v) ~> (tyUniv $l) ;
  
  -- Type weakening
  rule tyWeakenBase: (tyWeaken tyBase) ~> tyBase ;
  rule tyWeakenArr: (tyWeaken (tyArr $A $B)) ~> (tyArr (tyWeaken $A) (tyWeaken $B)) ;
  rule tyWeakenPi: (tyWeaken (tyPi $A $B)) ~> (tyPi (tyWeaken $A) (tyWeaken $B)) ;
  rule tyWeakenSigma: (tyWeaken (tySigma $A $B)) ~> (tySigma (tyWeaken $A) (tyWeaken $B)) ;
  rule tyWeakenUniv: (tyWeaken (tyUniv $l)) ~> (tyUniv $l) ;

-----------------------------------------------------
-- NORMAL FORMS
-----------------------------------------------------
piece Normal
  nf ::= "nfNeu" neutral → nfNeu
       | "nfLam" nf → nfLam
       | "nfPair" nf nf → nfPair ;
  
  neutral ::= "neVar" <number> → neVar
            | "neApp" neutral nf → neApp
            | "neFst" neutral → neFst
            | "neSnd" neutral → neSnd ;
  
  -- Normalization
  rule normVar: (normalize (tmVar $n)) ~> (nfNeu (neVar $n)) ;
  rule normLam: (normalize (tmLam $body)) ~> (nfLam (normalize $body)) ;
  rule normApp: (normalize (tmApp $f $a)) ~> (normApp' (normalize $f) (normalize $a)) ;
  rule normPair: (normalize (tmPair $a $b)) ~> (nfPair (normalize $a) (normalize $b)) ;
  rule normFst: (normalize (tmFst $p)) ~> (normFst' (normalize $p)) ;
  rule normSnd: (normalize (tmSnd $p)) ~> (normSnd' (normalize $p)) ;
  
  -- Apply to normal form
  rule normAppLam: (normApp' (nfLam $body) $arg) ~> (normalize (tmSubst (reify $body) (reify $arg))) ;
  rule normAppNeu: (normApp' (nfNeu $n) $arg) ~> (nfNeu (neApp $n $arg)) ;
  
  -- Project from normal form
  rule normFstPair: (normFst' (nfPair $a $b)) ~> $a ;
  rule normFstNeu: (normFst' (nfNeu $n)) ~> (nfNeu (neFst $n)) ;
  rule normSndPair: (normSnd' (nfPair $a $b)) ~> $b ;
  rule normSndNeu: (normSnd' (nfNeu $n)) ~> (nfNeu (neSnd $n)) ;
  
  -- Reification: nf → term
  rule reifyLam: (reify (nfLam $body)) ~> (tmLam (reify $body)) ;
  rule reifyPair: (reify (nfPair $a $b)) ~> (tmPair (reify $a) (reify $b)) ;
  rule reifyNeu: (reify (nfNeu $n)) ~> (reifyNe $n) ;
  rule reifyNeVar: (reifyNe (neVar $n)) ~> (tmVar $n) ;
  rule reifyNeApp: (reifyNe (neApp $n $a)) ~> (tmApp (reifyNe $n) (reify $a)) ;
  rule reifyNeFst: (reifyNe (neFst $n)) ~> (tmFst (reifyNe $n)) ;
  rule reifyNeSnd: (reifyNe (neSnd $n)) ~> (tmSnd (reifyNe $n)) ;

-----------------------------------------------------
-- BIDIRECTIONAL TYPE CHECKING
-----------------------------------------------------
piece Typing
  mode ::= "modeInfer" → modeInfer
         | "modeCheck" type → modeCheck ;
  
  -- Synthesis (infer mode)
  rule synthVar: (synth $Γ (tmVar $n)) ~> (ctxLookup $Γ $n) ;
  rule synthApp: (synth $Γ (tmApp $f $a)) ~> (tySubst (piCod (synth $Γ $f)) $a)
    when (check $Γ $a (piDom (synth $Γ $f))) ;
  rule synthFst: (synth $Γ (tmFst $p)) ~> (sigmaFst (synth $Γ $p)) ;
  rule synthSnd: (synth $Γ (tmSnd $p)) ~> (tySubst (sigmaSnd (synth $Γ $p)) (tmFst $p)) ;
  
  -- Type accessors
  rule piDom: (piDom (tyPi $A $B)) ~> $A ;
  rule piCod: (piCod (tyPi $A $B)) ~> $B ;
  rule sigmaFst: (sigmaFst (tySigma $A $B)) ~> $A ;
  rule sigmaSnd: (sigmaSnd (tySigma $A $B)) ~> $B ;
  
  -- Checking
  rule checkLam: (check $Γ (tmLam $body) (tyPi $A $B)) 
    ~> (check (ctxExtend $Γ $A) $body $B) ;
  rule checkPair: (check $Γ (tmPair $a $b) (tySigma $A $B))
    ~> (checkBoth (check $Γ $a $A) (check $Γ $b (tySubst $B $a))) ;
  rule checkSynth: (check $Γ $t $A) ~> (conv (synth $Γ $t) $A) ;

-----------------------------------------------------
-- CONVERSION
-----------------------------------------------------
piece Conv
  conv ::= "convTrue" → convTrue
         | "convFalse" → convFalse ;
  
  rule convRefl: (conv $A $A) ~> convTrue ;
  
  -- Structural conversion
  rule convPi: (conv (tyPi $A $B) (tyPi $A' $B')) 
    ~> (convBoth (conv $A $A') (conv $B $B')) ;
  rule convSigma: (conv (tySigma $A $B) (tySigma $A' $B'))
    ~> (convBoth (conv $A $A') (conv $B $B')) ;
  rule convArr: (conv (tyArr $A $B) (tyArr $A' $B'))
    ~> (convBoth (conv $A $A') (conv $B $B')) ;
  rule convUniv: (conv (tyUniv $l) (tyUniv $l')) ~> (convLevel $l $l') ;
  
  -- Level conversion
  rule convLevelRefl: (convLevel $l $l) ~> convTrue ;
  
  -- Conjunction of results
  rule convBothTT: (convBoth convTrue convTrue) ~> convTrue ;
  rule convBothTF: (convBoth convTrue convFalse) ~> convFalse ;
  rule convBothFT: (convBoth convFalse convTrue) ~> convFalse ;
  rule convBothFF: (convBoth convFalse convFalse) ~> convFalse ;
  
  rule checkBothTT: (checkBoth convTrue convTrue) ~> convTrue ;
  rule checkBothTF: (checkBoth convTrue convFalse) ~> convFalse ;
  rule checkBothFT: (checkBoth convFalse convTrue) ~> convFalse ;
  rule checkBothFF: (checkBoth convFalse convFalse) ~> convFalse ;

-----------------------------------------------------
-- SEMANTIC DOMAIN (for NbE)
-----------------------------------------------------
piece Semantics
  dom ::= "domSet" → domSet
        | "domArr" dom dom → domArr
        | "domPi" dom closure → domPi
        | "domSigma" dom closure → domSigma
        | "domNe" neutral → domNe ;
  
  closure ::= "mkClosure" env term → mkClosure ;
  
  env ::= "envEmpty" → envEmpty
        | "envExtend" env dom → envExtend ;
  
  -- Environment lookup
  rule envLookup0: (envLookup (envExtend $ρ $d) 0) ~> $d ;
  rule envLookupS: (envLookup (envExtend $ρ $d) (succ $n)) ~> (envLookup $ρ $n) ;
  
  -- Interpretation
  rule interpVar: (interp (tmVar $n) $ρ) ~> (envLookup $ρ $n) ;
  rule interpLam: (interp (tmLam $body) $ρ) ~> (mkClosure $ρ $body) ;
  rule interpApp: (interp (tmApp $f $a) $ρ) ~> (doApp (interp $f $ρ) (interp $a $ρ)) ;
  rule interpPair: (interp (tmPair $a $b) $ρ) ~> (domPair (interp $a $ρ) (interp $b $ρ)) ;
  rule interpFst: (interp (tmFst $p) $ρ) ~> (doFst (interp $p $ρ)) ;
  rule interpSnd: (interp (tmSnd $p) $ρ) ~> (doSnd (interp $p $ρ)) ;
  
  -- Application in semantic domain
  rule doAppClosure: (doApp (mkClosure $ρ $body) $arg) ~> (interp $body (envExtend $ρ $arg)) ;
  rule doAppNe: (doApp (domNe $n) $arg) ~> (domNe (neApp $n (readback $arg))) ;
  
  -- Projection in semantic domain
  rule doFstPair: (doFst (domPair $a $b)) ~> $a ;
  rule doFstNe: (doFst (domNe $n)) ~> (domNe (neFst $n)) ;
  rule doSndPair: (doSnd (domPair $a $b)) ~> $b ;
  rule doSndNe: (doSnd (domNe $n)) ~> (domNe (neSnd $n)) ;

-----------------------------------------------------
-- DERIVES
-----------------------------------------------------

derive subst for term ;
derive shift for term ;
derive cata for type ;
derive cata for term ;
derive cata for nf ;
derive cata for neutral ;

-----------------------------------------------------
-- TESTS
-----------------------------------------------------

test "beta-id": (tmApp (tmLam (tmVar 0)) (tmVar 1)) ~~> (tmVar 1) ;
test "fst-pair": (tmFst (tmPair (tmVar 0) (tmVar 1))) ~~> (tmVar 0) ;
test "snd-pair": (tmSnd (tmPair (tmVar 0) (tmVar 1))) ~~> (tmVar 1) ;


-----------------------------------------------------
-- Summary:
-- 
-- Pieces: 10 (Ctx, Level, Type, Term, Subst, Normal, Typing, Conv, Semantics)
-- Rules: ~80
-- Tests: 3
--
-- This implements a complete simply-typed lambda calculus with:
-- - Contexts and type checking
-- - Substitution and shifting  
-- - Normalization by evaluation
-- - Conversion checking
-----------------------------------------------------
