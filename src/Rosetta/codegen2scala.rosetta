-----------------------------------------------------
-- codegen2scala.rosetta: Render CodeGen AST to Scala
--
-- Uses Cons/Nil for lists (not [...] syntax).
-----------------------------------------------------

module CodeGenToScala {

  -- Module -> package object
  rewrite moduleToScala: (toScala (Module $name $body)) ~>
    (Lines (Cons (Line (FSeq (Cons (Keyword "package") (Cons (Raw " object ") (Cons (Ident $name) (Cons (Raw " {") Nil))))))
          (Cons FEmpty (Cons (Indent (toScalaDecls $body)) (Cons (Line (Raw "}")) Nil))))) ;

  -- Import
  rewrite importToScala: (toScala (ImportDecl $mod)) ~>
    (Line (FSeq (Cons (Keyword "import") (Cons (Raw " ") (Cons (Ident $mod) (Cons (Raw "._") Nil)))))) ;

  -- Inductive type -> sealed trait + case class/object
  rewrite inductiveToScala: (toScala (InductiveType $name $ctors $derives)) ~>
    (Lines (Cons (Line (FSeq (Cons (Keyword "sealed") (Cons (Raw " ") (Cons (Keyword "trait") (Cons (Raw " ") (Cons (Ident $name) Nil)))))))
          (Cons (toScalaCtors $name $ctors) Nil))) ;

  -- Structure -> case class
  rewrite structToScala: (toScala (StructType $name $fields $derives)) ~>
    (Lines (Cons (Line (FSeq (Cons (Keyword "case") (Cons (Raw " ") (Cons (Keyword "class") (Cons (Raw " ") (Cons (Ident $name) (Cons (Raw "(") Nil))))))))
          (Cons (Indent (toScalaFields $fields)) (Cons (Line (Raw ")")) Nil)))) ;

  -- Type alias
  rewrite aliasToScala: (toScala (AliasType $name $def)) ~>
    (Line (FSeq (Cons (Keyword "type") (Cons (Raw " ") (Cons (Ident $name) (Cons (Raw " = ") (Cons (toScala $def) Nil))))))) ;

  -- Constructor with args -> case class
  rewrite ctorToScala: (toScalaCtor $parent (MkCtor $name $args)) ~>
    (Line (FSeq (Cons (Keyword "case") (Cons (Raw " ") (Cons (Keyword "class") (Cons (Raw " ") (Cons (Ident $name) (Cons (Raw "(") (Cons (Sep ", " (toScalaCtorArgs $args)) (Cons (Raw ") extends ") (Cons (Ident $parent) Nil))))))))))) ;

  -- Constructor no args -> case object
  rewrite ctorNoArgsScala: (toScalaCtor $parent (MkCtor $name Nil)) ~>
    (Line (FSeq (Cons (Keyword "case") (Cons (Raw " ") (Cons (Keyword "object") (Cons (Raw " ") (Cons (Ident $name) (Cons (Raw " extends ") (Cons (Ident $parent) Nil))))))))) ;

  -- Function definition
  rewrite funDefScala: (toScala (FunDef $name $params $retType $body)) ~>
    (Lines (Cons (Line (FSeq (Cons (Keyword "def") (Cons (Raw " ") (Cons (Ident $name) (Cons (toScalaParams $params) (Cons (Raw ": ") (Cons (toScala $retType) (Cons (Raw " = {") Nil)))))))))
          (Cons (Indent (toScala $body)) (Cons (Line (Raw "}")) Nil)))) ;

  -- Variable
  rewrite varScala: (toScala (VarExpr $x)) ~> (Ident $x) ;

  -- Literal
  rewrite litScala: (toScala (LitExpr $v)) ~> (Raw $v) ;

  -- Application
  rewrite appScala: (toScala (AppExpr $f $args)) ~>
    (FSeq (Cons (toScala $f) (Cons (Raw "(") (Cons (Sep ", " (map toScala $args)) (Cons (Raw ")") Nil))))) ;

  -- Lambda
  rewrite lamScala: (toScala (LamExpr $params $body)) ~>
    (FSeq (Cons (Raw "(") (Cons (Sep ", " (map Ident $params)) (Cons (Raw ") => ") (Cons (toScala $body) Nil))))) ;

  -- Let binding -> val
  rewrite letScala: (toScala (LetExpr $name $value $body)) ~>
    (Lines (Cons (Line (FSeq (Cons (Keyword "val") (Cons (Raw " ") (Cons (Ident $name) (Cons (Raw " = ") (Cons (toScala $value) Nil)))))))
          (Cons (toScala $body) Nil))) ;

  -- Match expression
  rewrite matchScala: (toScala (MatchExpr $scrutinee $cases)) ~>
    (Lines (Cons (Line (FSeq (Cons (toScala $scrutinee) (Cons (Raw " match {") Nil))))
          (Cons (Indent (toScalaCases $cases)) (Cons (Line (Raw "}")) Nil)))) ;

  -- Match case
  rewrite caseScala: (toScalaCase (MkCase $pat $body)) ~>
    (Line (FSeq (Cons (Keyword "case") (Cons (Raw " ") (Cons (toScala $pat) (Cons (Raw " => ") (Cons (toScala $body) Nil))))))) ;

  -- If expression
  rewrite ifScala: (toScala (IfExpr $cond $then $else)) ~>
    (FSeq (Cons (Keyword "if") (Cons (Raw " (") (Cons (toScala $cond) (Cons (Raw ") ") (Cons (toScala $then) (Cons (Raw " else ") (Cons (toScala $else) Nil)))))))) ;

  -- List literal
  rewrite listScala: (toScala (ListExpr $items)) ~>
    (FSeq (Cons (Ident "List") (Cons (Raw "(") (Cons (Sep ", " (map toScala $items)) (Cons (Raw ")") Nil))))) ;

  -- Tuple
  rewrite tupleScala: (toScala (TupleExpr $items)) ~>
    (FSeq (Cons (Raw "(") (Cons (Sep ", " (map toScala $items)) (Cons (Raw ")") Nil)))) ;

  -- Option
  rewrite someScala: (toScala (SomeExpr $v)) ~> (FSeq (Cons (Ident "Some") (Cons (Raw "(") (Cons (toScala $v) (Cons (Raw ")") Nil))))) ;
  rewrite noneScala: (toScala NoneExpr) ~> (Ident "None") ;

  -- Dot access
  rewrite dotScala: (toScala (DotExpr $obj $field)) ~>
    (FSeq (Cons (toScala $obj) (Cons (Raw ".") (Cons (Ident $field) Nil)))) ;

  rewrite dotAppScala: (toScala (DotAppExpr $obj $method $args)) ~>
    (FSeq (Cons (toScala $obj) (Cons (Raw ".") (Cons (Ident $method) (Cons (Raw "(") (Cons (Sep ", " (map toScala $args)) (Cons (Raw ")") Nil))))))) ;

  -- Operators
  rewrite eqOpScala: (toScala EqOp) ~> (Op "==") ;
  rewrite neqOpScala: (toScala NeqOp) ~> (Op "!=") ;
  rewrite ltOpScala: (toScala LtOp) ~> (Op "<") ;
  rewrite gtOpScala: (toScala GtOp) ~> (Op ">") ;
  rewrite leOpScala: (toScala LeOp) ~> (Op "<=") ;
  rewrite geOpScala: (toScala GeOp) ~> (Op ">=") ;
  rewrite andOpScala: (toScala AndOp) ~> (Op "&&") ;
  rewrite orOpScala: (toScala OrOp) ~> (Op "||") ;
  rewrite addOpScala: (toScala AddOp) ~> (Op "+") ;
  rewrite subOpScala: (toScala SubOp) ~> (Op "-") ;
  rewrite mulOpScala: (toScala MulOp) ~> (Op "*") ;
  rewrite divOpScala: (toScala DivOp) ~> (Op "/") ;
  rewrite modOpScala: (toScala ModOp) ~> (Op "%") ;
  rewrite consOpScala: (toScala ConsOp) ~> (Op "::") ;
  rewrite appendOpScala: (toScala AppendOp) ~> (Op "++") ;
  rewrite notOpScala: (toScala NotOp) ~> (Op "!") ;
  rewrite negOpScala: (toScala NegOp) ~> (Op "-") ;

  -- Base types
  rewrite stringTypeScala: (toScala StringType) ~> (Ident "String") ;
  rewrite intTypeScala: (toScala IntType) ~> (Ident "Int") ;
  rewrite natTypeScala: (toScala NatType) ~> (Ident "Int") ;
  rewrite boolTypeScala: (toScala BoolType) ~> (Ident "Boolean") ;
  rewrite unitTypeScala: (toScala UnitType) ~> (Ident "Unit") ;
  rewrite floatTypeScala: (toScala FloatType) ~> (Ident "Double") ;
  rewrite charTypeScala: (toScala CharType) ~> (Ident "Char") ;

  rewrite listOfScala: (toScala (ListOf $t)) ~> (FSeq (Cons (Ident "List") (Cons (Raw "[") (Cons (toScala $t) (Cons (Raw "]") Nil))))) ;
  rewrite optionOfScala: (toScala (OptionOf $t)) ~> (FSeq (Cons (Ident "Option") (Cons (Raw "[") (Cons (toScala $t) (Cons (Raw "]") Nil))))) ;
  rewrite arrowTScala: (toScala (ArrowT $a $b)) ~> (FSeq (Cons (toScala $a) (Cons (Raw " => ") (Cons (toScala $b) Nil)))) ;

  -- Comments
  rewrite commentScala: (toScala (CommentD $text)) ~> (Line (FSeq (Cons (Raw "// ") (Cons (Raw $text) Nil)))) ;
  rewrite docScala: (toScala (DocD $text)) ~> (Line (FSeq (Cons (Raw "/** ") (Cons (Raw $text) (Cons (Raw " */") Nil))))) ;
}
