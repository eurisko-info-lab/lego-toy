-----------------------------------------------------
-- Lego.lego: Core Language Semantics
--
-- Extends Bootstrap with semantic constructs.
-- Bootstrap provides: lang, piece, token, rule, type, test syntax
-- Lego adds: CorePrimitives, Binders, Products, ADT, Errors, Builtins
--
-- Layers:
--   Built-in (Lean) → Bootstrap.lego → Lego.lego → *.lego
--
-- Bootstrap = syntax (how to write .lego files)
-- Lego = semantics (what the language can express)
-----------------------------------------------------

lang Lego (Bootstrap) :=

-----------------------------------------------------
-- Core Primitives
-- Universe, variables, application, substitution
-----------------------------------------------------

piece CorePrimitives
  term ::= "Univ"                      → univ
         | "Var" <ident>               → var
         | "App" term term             → app
         | "Subst" <ident> term term   → subst ;

  rule appSubst: (App (Subst $x $s $f) $a) ~~> (Subst $x $s (App $f $a)) ;
  
  type univForm: Univ : Univ ;
  type varType: (Var $x) : $T when bound $x : $T ;

-----------------------------------------------------
-- Binders
-- Lambda abstraction
-----------------------------------------------------

piece Binders
  term ::= "Lam" <ident> "." term      → lam ;

  rule beta: (App (Lam $x . $body) $arg) ~~> (Subst $x $arg $body) ;

  type lamForm: (Lam $x . $body) : (Arrow $A $B)
    when [$x : $A] $body : $B ;

-----------------------------------------------------
-- Products
-- Non-dependent pairs
-----------------------------------------------------

piece Products
  term ::= "Pair" term term            → pair
         | "Fst" term                  → fst
         | "Snd" term                  → snd ;

  rule fstPair: (Fst (Pair $a $b)) ~~> $a ;
  rule sndPair: (Snd (Pair $a $b)) ~~> $b ;
  rule pairEta: (Pair (Fst $p) (Snd $p)) ~~> $p ;

  type pairType: (Pair $a $b) : (Prod $A $B)
    when $a : $A, $b : $B ;
  type fstType: (Fst $p) : $A when $p : (Prod $A $B) ;
  type sndType: (Snd $p) : $B when $p : (Prod $A $B) ;

-----------------------------------------------------
-- ADT Definition
-- Meta-construct for algebraic data types
-----------------------------------------------------

piece ADTDef
  decl ::= "adt" <ident> "{" constr* "}" → adtDef ;
  constr ::= <ident> ":" type            → constr ;

  type adtForm: (adtDef $name $constrs) : Univ ;

-----------------------------------------------------
-- Rewrite Rules
-- Pattern → template transformations
-- Annotations specify rule scope: @file, @decl, @expr, @type, @entry
-----------------------------------------------------

piece RewriteRules
  decl ::= ruleAnnot? "rewrite" <ident> ":" pattern "~>" term → rewriteRule ;
  ruleAnnot ::= "@" ruleAnnotKind → annot ;
  ruleAnnotKind ::= "file" → file | "decl" → decl | "expr" → expr | "type" → type | "entry" → entry ;
  pattern ::= term                       → termPat
            | "_"                        → wildcard ;

-----------------------------------------------------
-- Judgment Forms
-- Typing judgments with premises
-----------------------------------------------------

piece Judgments
  decl ::= "type" <ident> ":" term ":" term conds? → typeDecl ;
  conds ::= "when" cond ("," cond)*     → conds ;
  cond ::= term ":" term                → cond
         | "[" bind* "]" term ":" term  → ctxCond ;
  bind ::= <ident> ":" term             → bind ;

-----------------------------------------------------
-- Tests
-- Equivalence assertions with optional guards
-- Supports:
--   test[grammar] "name": <surface syntax> ~~> <expected> ;  (parametric)
--   test "name": <s-expr> ~~> <s-expr> ;                     (s-expr)
--   tests                                                    (test block in piece)
--     "input" ~> expected
--     ...
-----------------------------------------------------

piece Tests
  -- Parametric test uses piece grammar, s-expr test uses term grammar
  testDecl ::= "test" "[" <ident> "]" <string> ":" testBody ";" → DTestParam
             | "test" <string> ":" term "~~>" term testGuard? ";" → DTest ;
  testGuard ::= "when" testCond ("," testCond)* → guard ;
  testCond ::= term → cond ;
  
  -- Test case for test blocks
  testCase ::= <string> "~>" template → testCase ;

-- Extend File piece to add tests block as pieceItem
-- Uses simpleTemplate which is a restricted version that doesn't
-- consume trailing identifiers (avoiding ambiguity with following declarations)
piece File
  pieceItem ::= "tests" testsCase+ "end" → DTestsBlock
              | "tests" testsCase+ → DTestsBlock ;
  testsCase ::= <string> "~>" simpleTemplate → testCase ;
  -- Simple template for test expected values - no trailing ident consumption
  -- Supports: variables ($x), function application foo(a,b), brackets [a,b], nested
  simpleTemplate ::= "$" <ident> → var
                   | "(" simpleTemplate ")" → paren
                   | "(" simpleTemplate "," simpleTemplate ("," simpleTemplate)* ")" → tuple
                   | "[" simpleTemplateList "]" → bracket
                   | <ident> "(" simpleTemplateList ")" → con
                   | <ident> → con
                   | <string> → lit
                   | <number> → num ;
  simpleTemplateList ::= simpleTemplate ("," simpleTemplate)* ;
  simpleTemplateArg ::= simpleTemplate ;

-----------------------------------------------------
-- Modules
-- Namespacing and imports
-----------------------------------------------------

piece Modules
  decl ::= "module" <ident> "{" decl* "}" → moduleDecl
         | "import" <ident>               → importDecl ;

-- Note: File structure (lang, piece, token, rule, type, test)
-- is inherited from Bootstrap

-----------------------------------------------------
-- Errors
-- Error handling
-----------------------------------------------------

piece Errors
  term ::= "Error" <string>            → error
         | "Stuck" term                → stuck ;

  rule appError: (App (Error $msg) $a) ~~> (Error $msg) ;
  rule fstError: (Fst (Error $msg)) ~~> (Error $msg) ;

-----------------------------------------------------
-- Annotations
-- Source location and metadata
-----------------------------------------------------

piece Annotations
  term ::= "Ann" term term             → ann
         | "Loc" <int> <int> term      → loc ;

  rule annErase: (Ann $t $T) ~~> $t ;

-----------------------------------------------------
-- Builtins
-- Common primitives
-----------------------------------------------------

piece Builtins
  term ::= "Bool"                      → boolTy
         | "true"                      → true
         | "false"                     → false
         | "if" term term term         → ifThenElse
         | "Nat"                       → natTy
         | "zero"                      → zero
         | "succ" term                 → succ ;

  rule ifTrue: (if true $t $f) ~~> $t ;
  rule ifFalse: (if false $t $f) ~~> $f ;

  type boolForm: Bool : Univ ;
  type trueType: true : Bool ;
  type falseType: false : Bool ;
  type natForm: Nat : Univ ;
  type zeroType: zero : Nat ;
  type succType: (succ $n) : Nat when $n : Nat ;
