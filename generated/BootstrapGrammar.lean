/-
  Generated Grammar from Bootstrap.lego

  This module contains ONLY the grammar piece definitions.
  Import this from your hand-written Bootstrap.lean to use
  the generated grammar while keeping hand-written tokenizer
  and other infrastructure.

  DO NOT EDIT - regenerate with:
    lake exe tolean --grammar test/Bootstrap.lego > generated/BootstrapGrammar.lean
-/

import Lego.Algebra
import Lego.Interp

namespace Lego.Generated.Bootstrap

open GrammarExpr
open Lego

/-! ## Grammar Pieces -/

/-- Atom piece -/
def atomPiece : Piece := {
  name := "Atom"
  grammar := [
    ("Atom.ident", (node "ident" (ref "TOKEN.ident"))),
    ("Atom.string", (node "string" (ref "TOKEN.string"))),
    ("Atom.char", (node "char" (ref "TOKEN.char"))),
    ("Atom.number", (node "number" (ref "TOKEN.number"))),
    ("Atom.expr", (node "expr" (ref "TOKEN.expr"))),
    ("Atom.symbol", (node "symbol" (ref "TOKEN.symbol"))),
    ("Atom.bool", (node "bool" (ref "TOKEN.bool"))),
    ("Atom.elabCtx", (node "elabCtx" (ref "TOKEN.elabCtx"))),
    ("Atom.sysEntry", (node "sysEntry" (ref "TOKEN.sysEntry"))),
    ("Atom.visibility", (node "visibility" (ref "TOKEN.visibility"))),
    ("Atom.name", (node "name" (ref "TOKEN.name")))
  ]
  rules := []
}

/-- Term piece -/
def termPiece : Piece := {
  name := "Term"
  grammar := [
    ("Term.term", ((node "binder" ((lit "$").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Term.term").seq empty))))).alt ((node "var" ((lit "$").seq ((ref "Atom.ident").seq empty))).alt ((node "binder" ((ref "Atom.ident").seq ((lit ".").seq ((ref "Term.term").seq empty)))).alt ((node "var" (ref "Atom.ident")).alt ((node "wildcard" (lit "_")).alt ((node "lit" (ref "Atom.string")).alt ((node "num" (ref "Atom.number")).alt ((node "piType" ((lit "(").seq ((lit "Π").seq ((lit "(").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq ((lit ")").seq ((lit ".").seq ((ref "Term.term").seq ((lit ")").seq empty))))))))))).alt ((node "piType" ((lit "(").seq ((lit "Π").seq ((lit "(").seq ((lit "_").seq ((lit ":").seq ((ref "Term.term").seq ((lit ")").seq ((lit ".").seq ((ref "Term.term").seq ((lit ")").seq empty))))))))))).alt ((node "sigmaType" ((lit "(").seq ((lit "Σ").seq ((lit "(").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq ((lit ")").seq ((lit ".").seq ((ref "Term.term").seq ((lit ")").seq empty))))))))))).alt ((node "sigmaType" ((lit "(").seq ((lit "Σ").seq ((lit "(").seq ((lit "_").seq ((lit ":").seq ((ref "Term.term").seq ((lit ")").seq ((lit ".").seq ((ref "Term.term").seq ((lit ")").seq empty))))))))))).alt ((node "subst" ((lit "[").seq ((ref "Term.term").seq ((lit ":=").seq ((ref "Term.term").seq ((lit "]").seq ((ref "Term.term").seq empty))))))).alt ((node "typedCtx" ((lit "[").seq ((ref "Term.term").seq ((lit ":").seq ((ref "Term.term").seq ((lit "]").seq ((ref "Term.term").seq empty))))))).alt ((node "bracket" ((lit "[").seq ((ref "Term.term").seq ((lit "]").seq empty)))).alt ((node "brace" ((lit "{").seq (((ref "Term.termArg").star).seq ((lit "}").seq empty)))).alt ((node "parenSubst" ((lit "(").seq ((lit "[").seq ((ref "Term.term").seq ((lit ":=").seq ((ref "Term.term").seq ((lit "]").seq ((ref "Term.term").seq ((lit ")").seq empty))))))))).alt ((node "parenTypedCtx" ((lit "(").seq ((lit "[").seq ((ref "Term.term").seq ((lit ":").seq ((ref "Term.term").seq ((lit "]").seq ((ref "Term.term").seq ((lit ")").seq empty))))))))).alt ((node "ann" ((lit "(").seq ((ref "Term.term").seq ((lit ":").seq ((ref "Term.term").seq ((lit ")").seq empty)))))).alt ((node "binderParen" ((lit "(").seq ((lit "$").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Term.term").seq ((lit ")").seq empty))))))).alt ((node "objBinderParen" ((lit "(").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Term.term").seq ((lit ")").seq empty)))))).alt ((node "binderCon" ((lit "(").seq ((ref "Term.conname").seq ((lit "$").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq ((lit ".").seq ((ref "Term.term").seq ((lit ")").seq empty)))))))))).alt ((node "binderCon" ((lit "(").seq ((ref "Term.conname").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq ((lit ".").seq ((ref "Term.term").seq ((lit ")").seq empty))))))))).alt ((node "app" ((lit "(").seq ((lit "(").seq ((ref "Term.conname").seq (((ref "Term.termArg").star).seq ((lit ")").seq (((ref "Term.termArg").seq ((ref "Term.termArg").star)).seq ((lit ")").seq empty)))))))).alt (node "con" ((lit "(").seq ((ref "Term.conname").seq (((ref "Term.termArg").star).seq ((lit ")").seq empty))))))))))))))))))))))))))))),
    ("Term.termArg", ((node "binder" ((lit "$").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Term.term").seq empty))))).alt ((node "typedVar" ((lit "$").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq empty))))).alt ((node "assign" ((lit "$").seq ((ref "Atom.ident").seq ((lit ":=").seq ((ref "Term.term").seq empty))))).alt ((node "assign" ((ref "Atom.ident").seq ((lit ":=").seq ((ref "Term.term").seq empty)))).alt ((node "labeledArg" ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq empty)))).alt ((node "objBinder" ((ref "Atom.ident").seq ((lit ".").seq ((ref "Term.term").seq empty)))).alt ((node "con" (lit "~~>")).alt ((node "con" (lit "~>")).alt ((node "con" (lit "→")).alt ((node "con" (lit "->")).alt ((node "con" (lit "×")).alt ((node "con" (lit "↦")).alt ((node "con" (lit "=I=")).alt ((node "con" (lit "@@")).alt ((node "con" (lit "-")).alt ((node "con" (lit "↾")).alt ((node "con" (lit "@")).alt ((node "con" (lit ".")).alt ((node "con" (lit "|")).alt ((node "con" (lit "=>")).alt ((node "con" (lit "←")).alt ((node "con" (lit "with")).alt ((node "con" (lit "where")).alt (ref "Term.term"))))))))))))))))))))))))),
    ("Term.conname", ((lit "=I=").alt ((lit "@@").alt ((lit "~>").alt ((lit "→").alt ((lit "×").alt ((lit "↦").alt ((lit "⟨").alt ((lit "⟩").alt ((ref "Atom.ident").alt (ref "TOKEN.sym")))))))))))
  ]
  rules := []
}

/-- Pattern piece -/
def patternPiece : Piece := {
  name := "Pattern"
  grammar := [
    ("Pattern.pattern", ((node "binder" ((lit "$").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Pattern.pattern").seq empty))))).alt ((node "restVar" ((lit "$").seq ((ref "Atom.ident").seq ((lit "...").seq empty)))).alt ((node "var" ((lit "$").seq ((ref "Atom.ident").seq empty))).alt ((node "mapExpr" ((lit "@").seq ((ref "Atom.ident").seq (((ref "Pattern.patternArg").seq ((ref "Pattern.patternArg").star)).seq empty)))).alt ((node "subst" ((lit "[").seq ((ref "Pattern.pattern").seq ((lit ":=").seq ((ref "Pattern.pattern").seq ((lit "]").seq ((ref "Pattern.pattern").seq empty))))))).alt ((node "bracket" ((lit "[").seq (((ref "Pattern.patternArg").star).seq ((lit "]").seq empty)))).alt ((node "brace" ((lit "{").seq (((ref "Pattern.patternArg").star).seq ((lit "}").seq empty)))).alt ((node "tuple" ((lit "(").seq ((ref "Pattern.pattern").seq ((lit ",").seq ((ref "Pattern.pattern").seq ((lit ")").seq empty)))))).alt ((node "unit" ((lit "(").seq ((lit ")").seq empty))).alt ((node "binderParen" ((lit "(").seq ((lit "$").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Pattern.pattern").seq ((lit ")").seq empty))))))).alt ((node "objBinderParen" ((lit "(").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Pattern.pattern").seq ((lit ")").seq empty)))))).alt ((node "ann" ((lit "(").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Pattern.pattern").seq ((lit ")").seq empty)))))).alt ((node "app" ((lit "(").seq ((lit "(").seq ((lit "(").seq ((ref "Pattern.patternHead").seq (((ref "Pattern.patternArg").star).seq ((lit ")").seq ((lit ")").seq (((ref "Pattern.patternArg").seq ((ref "Pattern.patternArg").star)).seq ((lit ")").seq empty)))))))))).alt ((node "app" ((lit "(").seq ((lit "(").seq ((ref "Pattern.patternHead").seq (((ref "Pattern.patternArg").star).seq ((lit ")").seq (((ref "Pattern.patternArg").seq ((ref "Pattern.patternArg").star)).seq ((lit ")").seq empty)))))))).alt ((node "app" ((lit "(").seq ((lit "(").seq ((lit "[").seq (((ref "Pattern.patternArg").star).seq ((lit "]").seq ((lit ")").seq (((ref "Pattern.patternArg").seq ((ref "Pattern.patternArg").star)).seq ((lit ")").seq empty))))))))).alt ((node "app" ((lit "(").seq ((lit "[").seq (((ref "Pattern.patternArg").star).seq ((lit "]").seq (((ref "Pattern.patternArg").seq ((ref "Pattern.patternArg").star)).seq ((lit ")").seq empty))))))).alt ((node "ann" ((lit "(").seq ((lit "(").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Pattern.pattern").seq ((lit ")").seq ((lit ")").seq empty)))))))).alt ((node "con" ((lit "(").seq ((ref "Pattern.patternHead").seq (((ref "Pattern.patternArg").star).seq ((lit ")").seq empty))))).alt ((node "lit" (ref "Atom.string")).alt ((node "num" (ref "Atom.number")).alt (node "con" (ref "Atom.ident"))))))))))))))))))))))),
    ("Pattern.patternArg", ((node "binder" ((lit "$").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Pattern.pattern").seq empty))))).alt ((node "typedVar" ((lit "$").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Pattern.pattern").seq empty))))).alt ((node "restVar" ((lit "$").seq ((ref "Atom.ident").seq ((lit "...").seq empty)))).alt ((node "assign" ((lit "$").seq ((ref "Atom.ident").seq ((lit ":=").seq ((ref "Pattern.pattern").seq empty))))).alt ((node "assign" ((ref "Atom.ident").seq ((lit ":=").seq ((ref "Pattern.pattern").seq empty)))).alt ((node "labeledArg" ((ref "Atom.ident").seq ((lit ":").seq ((ref "Pattern.pattern").seq empty)))).alt ((node "objBinder" ((ref "Atom.ident").seq ((lit ".").seq ((ref "Pattern.pattern").seq empty)))).alt ((node "con" (lit "~~>")).alt ((node "con" (lit "~>")).alt ((node "con" (lit "→")).alt ((node "con" (lit "->")).alt ((node "con" (lit "×")).alt ((node "con" (lit "↦")).alt ((node "con" (lit "=I=")).alt ((node "con" (lit "@@")).alt ((node "con" (lit "-")).alt ((node "con" (lit "↾")).alt ((node "mapExpr" ((lit "@").seq ((ref "Atom.ident").seq (((ref "Pattern.patternArg").seq ((ref "Pattern.patternArg").star)).seq empty)))).alt ((node "con" (lit "@")).alt ((node "con" (lit ".")).alt ((node "con" (lit "|")).alt ((node "con" (lit "=>")).alt ((node "con" (lit "←")).alt ((node "con" (lit "⟨")).alt ((node "con" (lit "⟩")).alt ((node "con" (lit ",")).alt ((node "con" (lit ":")).alt ((node "con" (lit ":=")).alt ((node "con" (lit "=")).alt ((node "con" (lit "in")).alt ((node "con" (lit "with")).alt ((node "con" (lit "where")).alt (ref "Pattern.pattern")))))))))))))))))))))))))))))))))),
    ("Pattern.patternHead", ((node "var" ((lit "$").seq ((ref "Atom.ident").seq empty))).alt ((node "num" (ref "Atom.number")).alt (ref "Term.conname"))))
  ]
  rules := []
}

/-- Template piece -/
def templatePiece : Piece := {
  name := "Template"
  grammar := [
    ("Template.template", ((node "binder" ((lit "$").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Template.template").seq empty))))).alt ((node "restVar" ((lit "$").seq ((ref "Atom.ident").seq ((lit "...").seq empty)))).alt ((node "var" ((lit "$").seq ((ref "Atom.ident").seq empty))).alt ((node "mapExpr" ((lit "@").seq ((ref "Atom.ident").seq (((ref "Template.templateArg").seq ((ref "Template.templateArg").star)).seq empty)))).alt ((node "letIn" ((lit "let").seq ((ref "Atom.ident").seq ((lit "=").seq ((ref "Template.template").seq ((lit "in").seq ((ref "Template.template").seq empty))))))).alt ((node "letIn" ((lit "let").seq ((lit "$").seq ((ref "Atom.ident").seq ((lit "=").seq ((ref "Template.template").seq ((lit "in").seq ((ref "Template.template").seq empty)))))))).alt ((node "letTupleIn" ((lit "let").seq ((lit "(").seq ((ref "Template.template").seq ((lit ",").seq ((ref "Template.template").seq ((lit ")").seq ((lit "=").seq ((ref "Template.template").seq ((lit "in").seq ((ref "Template.template").seq empty))))))))))).alt ((node "caseExpr" ((lit "case").seq ((ref "Template.template").seq (((ref "Template.caseArm").seq ((ref "Template.caseArm").star)).seq empty)))).alt ((node "subst" ((lit "[").seq ((ref "Template.template").seq ((lit ":=").seq ((ref "Template.template").seq ((lit "]").seq ((ref "Template.template").seq empty))))))).alt ((node "bracket" ((lit "[").seq (((ref "Template.templateArg").star).seq ((lit "]").seq empty)))).alt ((node "brace" ((lit "{").seq (((ref "Template.templateArg").star).seq ((lit "}").seq empty)))).alt ((node "nTuple" ((lit "(").seq ((ref "Template.template").seq ((lit ",").seq ((ref "Template.template").seq ((((lit ",").seq ((ref "Template.template").seq empty)).seq (((lit ",").seq ((ref "Template.template").seq empty)).star)).seq ((lit ")").seq empty))))))).alt ((node "tuple" ((lit "(").seq ((ref "Template.template").seq ((lit ",").seq ((ref "Template.template").seq ((lit ")").seq empty)))))).alt ((node "unit" ((lit "(").seq ((lit ")").seq empty))).alt ((node "caseExpr" ((lit "(").seq ((lit "case").seq ((ref "Template.template").seq (((ref "Template.caseArm").seq ((ref "Template.caseArm").star)).seq ((lit ")").seq empty)))))).alt ((node "binderParen" ((lit "(").seq ((lit "$").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Template.template").seq ((lit ")").seq empty))))))).alt ((node "objBinderParen" ((lit "(").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Template.template").seq ((lit ")").seq empty)))))).alt ((node "lamParen" ((lit "(").seq ((lit "λ").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Template.template").seq ((lit ")").seq empty))))))).alt ((node "introExpr" ((lit "(").seq ((ref "Atom.ident").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Template.headTerm").seq (((ref "Template.templateArg").star).seq ((lit ")").seq empty)))))))).alt ((node "letIn" ((lit "(").seq ((lit "let").seq ((ref "Atom.ident").seq ((lit "=").seq ((ref "Template.template").seq ((lit "in").seq ((ref "Template.template").seq ((lit ")").seq empty))))))))).alt ((node "letIn" ((lit "(").seq ((lit "let").seq ((lit "$").seq ((ref "Atom.ident").seq ((lit "=").seq ((ref "Template.template").seq ((lit "in").seq ((ref "Template.template").seq ((lit ")").seq empty)))))))))).alt ((node "letTupleIn" ((lit "(").seq ((lit "let").seq ((lit "(").seq ((ref "Template.template").seq ((lit ",").seq ((ref "Template.template").seq ((lit ")").seq ((lit "=").seq ((ref "Template.template").seq ((lit "in").seq ((ref "Template.template").seq ((lit ")").seq empty))))))))))))).alt ((node "con" ((lit "(").seq ((ref "Template.headTerm").seq (((ref "Template.templateArg").star).seq ((lit ")").seq empty))))).alt ((node "record" ((lit "(").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Template.template").seq (((ref "Template.templateArg").seq ((ref "Template.templateArg").star)).seq ((lit ")").seq empty))))))).alt ((node "typed" ((lit "(").seq ((ref "Template.template").seq ((lit ":").seq ((ref "Template.template").seq ((lit ")").seq empty)))))).alt ((node "paren" ((lit "(").seq ((ref "Template.template").seq ((lit ")").seq empty)))).alt ((node "con" ((ref "Atom.ident").seq (((ref "Template.parenArg").seq ((ref "Template.parenArg").star)).seq (((ref "Atom.ident").seq ((ref "Atom.ident").star)).seq empty)))).alt ((node "con" ((ref "Atom.ident").seq (((ref "Template.parenArg").seq ((ref "Template.parenArg").star)).seq empty))).alt ((node "lit" (ref "Atom.string")).alt ((node "num" (ref "Atom.number")).alt (node "con" (ref "Atom.ident"))))))))))))))))))))))))))))))))),
    ("Template.parenArg", ((node "paren" ((lit "(").seq ((ref "Template.template").seq ((lit ")").seq empty)))).alt ((node "nTuple" ((lit "(").seq ((ref "Template.template").seq ((lit ",").seq ((ref "Template.template").seq ((((lit ",").seq ((ref "Template.template").seq empty)).seq (((lit ",").seq ((ref "Template.template").seq empty)).star)).seq ((lit ")").seq empty))))))).alt ((node "tuple" ((lit "(").seq ((ref "Template.template").seq ((lit ",").seq ((ref "Template.template").seq ((lit ")").seq empty)))))).alt ((node "unit" ((lit "(").seq ((lit ")").seq empty))).alt ((node "con" ((lit "(").seq ((ref "Template.headTerm").seq (((ref "Template.templateArg").star).seq ((lit ")").seq empty))))).alt (node "typed" ((lit "(").seq ((ref "Template.template").seq ((lit ":").seq ((ref "Template.template").seq ((lit ")").seq empty)))))))))))),
    ("Template.caseArm", ((node "arm" ((lit "(").seq ((ref "Pattern.patternHead").seq (((ref "Pattern.patternArg").star).seq ((lit ")").seq ((lit "=>").seq ((ref "Template.template").seq empty))))))).alt ((node "varArm" ((lit "$").seq ((ref "Atom.ident").seq ((lit "=>").seq ((ref "Template.template").seq empty))))).alt ((node "arm" ((ref "Atom.ident").seq ((lit "=>").seq ((ref "Template.template").seq empty)))).alt (node "arm" ((ref "Term.conname").seq ((lit "=>").seq ((ref "Template.template").seq empty)))))))),
    ("Template.templateArg", ((node "binder" ((lit "$").seq ((ref "Atom.ident").seq ((lit ".").seq ((ref "Template.template").seq empty))))).alt ((node "typedVar" ((lit "$").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Template.template").seq empty))))).alt ((node "assign" ((lit "$").seq ((ref "Atom.ident").seq ((lit ":=").seq ((ref "Template.template").seq empty))))).alt ((node "assign" ((ref "Atom.ident").seq ((lit ":=").seq ((ref "Template.template").seq empty)))).alt ((node "labeledArg" ((ref "Atom.ident").seq ((lit ":").seq ((ref "Template.template").seq empty)))).alt ((node "stringLabeledArg" ((ref "Atom.string").seq ((lit ":").seq ((ref "Template.template").seq empty)))).alt ((node "typed" ((lit "(").seq ((ref "Template.template").seq ((lit ":").seq ((ref "Template.template").seq ((lit ")").seq empty)))))).alt ((node "objBinder" ((ref "Atom.ident").seq ((lit ".").seq ((ref "Template.template").seq empty)))).alt ((node "con" (lit "~~>")).alt ((node "con" (lit "~>")).alt ((node "con" (lit "→")).alt ((node "con" (lit "->")).alt ((node "con" (lit "×")).alt ((node "con" (lit "↦")).alt ((node "con" (lit "=I=")).alt ((node "con" (lit "@@")).alt ((node "con" (lit "-")).alt ((node "con" (lit "↾")).alt ((node "mapExpr" ((lit "@").seq ((ref "Atom.ident").seq (((ref "Template.templateArg").seq ((ref "Template.templateArg").star)).seq empty)))).alt ((node "con" (lit "@")).alt ((node "con" (lit ".")).alt ((node "con" (lit "|")).alt ((node "con" (lit "=>")).alt ((node "con" (lit "←")).alt ((node "con" (lit "⟨")).alt ((node "con" (lit "⟩")).alt ((node "con" (lit ",")).alt ((node "con" (lit "with")).alt ((node "con" (lit "where")).alt (ref "Template.template"))))))))))))))))))))))))))))))),
    ("Template.headTerm", ((node "var" ((lit "$").seq ((ref "Atom.ident").seq empty))).alt ((ref "Atom.ident").alt ((ref "Atom.string").alt ((ref "Atom.number").alt ((node "typed" ((lit "(").seq ((ref "Template.template").seq ((lit ":").seq ((ref "Template.template").seq ((lit ")").seq empty)))))).alt ((node "nTuple" ((lit "(").seq ((ref "Template.template").seq ((lit ",").seq ((ref "Template.template").seq ((((lit ",").seq ((ref "Template.template").seq empty)).seq (((lit ",").seq ((ref "Template.template").seq empty)).star)).seq ((lit ")").seq empty))))))).alt ((node "tuple" ((lit "(").seq ((ref "Template.template").seq ((lit ",").seq ((ref "Template.template").seq ((lit ")").seq empty)))))).alt (node "app" ((lit "(").seq ((ref "Template.template").seq (((ref "Template.templateArg").star).seq ((lit ")").seq empty)))))))))))))
  ]
  rules := []
}

/-- GrammarExpr piece -/
def grammarExprPiece : Piece := {
  name := "GrammarExpr"
  grammar := [
    ("GrammarExpr.expr", (ref "GrammarExpr.ordered")),
    ("GrammarExpr.ordered", ((node "ordered" ((ref "GrammarExpr.alt").seq ((lit "/").seq ((ref "GrammarExpr.ordered").seq empty)))).alt (ref "GrammarExpr.alt"))),
    ("GrammarExpr.alt", ((node "alt" ((ref "GrammarExpr.seq").seq ((lit "|").seq ((ref "GrammarExpr.alt").seq empty)))).alt (ref "GrammarExpr.seq"))),
    ("GrammarExpr.seq", ((node "annotated" ((ref "GrammarExpr.seqBase").seq ((lit "→").seq ((ref "Atom.ident").seq empty)))).alt (ref "GrammarExpr.seqBase"))),
    ("GrammarExpr.seqBase", ((node "seq" ((ref "GrammarExpr.suffix").seq ((ref "GrammarExpr.suffix").star))).alt (ref "GrammarExpr.suffix"))),
    ("GrammarExpr.suffix", ((node "star" ((ref "GrammarExpr.atom").seq ((lit "*").seq empty))).alt ((node "plus" ((ref "GrammarExpr.atom").seq ((lit "+").seq empty))).alt ((node "opt" ((ref "GrammarExpr.atom").seq ((lit "?").seq empty))).alt (ref "GrammarExpr.atom"))))),
    ("GrammarExpr.atom", ((node "cut" ((lit "!").seq ((ref "GrammarExpr.atom").seq empty))).alt ((node "lit" (ref "Atom.string")).alt ((node "chr" (ref "Atom.char")).alt ((node "ref" (ref "Atom.ident")).alt ((node "group" ((lit "(").seq ((ref "GrammarExpr.expr").seq ((lit ")").seq empty)))).alt ((node "longest" ((lit "#longest").seq ((lit "[").seq ((ref "GrammarExpr.exprList").seq ((lit "]").seq empty))))).alt ((node "special" (ref "TOKEN.special")).alt ((node "empty" (lit "ε")).alt ((node "layoutNl" (lit "@nl")).alt ((node "layoutIndent" (lit "@indent")).alt ((node "layoutDedent" (lit "@dedent")).alt ((node "layoutSpace" (lit "@sp")).alt (node "layoutNoSpace" (lit "@nsp"))))))))))))))),
    ("GrammarExpr.exprList", ((ref "GrammarExpr.expr").seq ((((lit ",").seq ((ref "GrammarExpr.expr").seq empty)).star).seq empty)))
  ]
  rules := []
}

/-- File piece -/
def filePiece : Piece := {
  name := "File"
  grammar := [
    ("File.legoFile", ((ref "File.decl").star)),
    ("File.decl", ((ref "File.importDecl").alt ((ref "File.langDecl").alt ((ref "File.tokenDecl").alt ((ref "File.pieceDecl").alt ((ref "File.vocabDecl").alt ((ref "File.ruleDecl").alt ((ref "File.typeDecl").alt ((ref "File.testDecl").alt (ref "File.attrsDecl")))))))))),
    ("File.importDecl", (node "DImport" ((lit "import").seq ((ref "File.modulePath").seq (((lit ";").alt empty).seq empty))))),
    ("File.vocabDecl", (node "DVocab" ((lit "vocab").seq ((ref "Atom.ident").seq (((ref "Atom.ident").star).seq empty))))),
    ("File.modulePath", (node "modulePath" ((ref "Atom.ident").seq ((((lit ".").seq ((ref "Atom.ident").seq empty)).star).seq empty)))),
    ("File.langDecl", (node "DLang" ((lit "lang").seq ((ref "Atom.ident").seq (((ref "File.imports").alt empty).seq ((lit ":=").seq ((ref "File.langBody").seq empty))))))),
    ("File.imports", ((node "DImports" ((lit "(").seq ((ref "Atom.ident").seq ((((lit ",").seq ((ref "Atom.ident").seq empty)).star).seq ((lit ")").seq empty))))).alt (node "DImports" ((lit "(").seq (((ref "Atom.ident").seq ((ref "Atom.ident").star)).seq ((lit ")").seq empty)))))),
    ("File.langBody", ((ref "File.innerDecl").star)),
    ("File.innerDecl", ((ref "File.tokenDecl").alt ((ref "File.pieceDecl").alt ((ref "File.ruleDecl").alt ((ref "File.typeDecl").alt ((ref "File.testDecl").alt ((ref "File.attrsDecl").alt ((ref "File.deriveDecl").alt ((ref "File.algebraDecl").alt ((ref "File.effectDecl").alt ((ref "File.opticsDecl").alt ((ref "File.adjunctionDecl").alt ((ref "File.kanDecl").alt ((ref "File.operadDecl").alt ((ref "File.natDecl").alt ((ref "File.macroDecl").alt (ref "File.lawsDecl"))))))))))))))))),
    ("File.tokenDecl", (node "DToken" ((lit "token").seq ((ref "Atom.ident").seq (((ref "File.tokenItem").seq ((ref "File.tokenItem").star)).seq empty))))),
    ("File.tokenItem", (ref "File.prodDecl")),
    ("File.pieceDecl", (node "DPiece" ((lit "piece").seq ((ref "Atom.ident").seq (((ref "File.pieceItem").seq ((ref "File.pieceItem").star)).seq empty))))),
    ("File.pieceItem", ((ref "File.prodDecl").alt ((ref "File.ruleDecl").alt ((ref "File.typeDecl").alt ((ref "File.testDecl").alt ((ref "File.deriveDecl").alt ((ref "File.algebraDecl").alt ((ref "File.effectDecl").alt ((ref "File.opticsDecl").alt ((ref "File.adjunctionDecl").alt ((ref "File.kanDecl").alt ((ref "File.operadDecl").alt ((ref "File.natDecl").alt ((ref "File.macroDecl").alt (ref "File.lawsDecl"))))))))))))))),
    ("File.prodDecl", (node "DGrammar" ((ref "Atom.ident").seq ((lit "::=").seq ((ref "GrammarExpr.expr").seq ((lit ";").seq empty)))))),
    ("File.ruleDecl", (node "DRule" (((ref "File.ruleAnnot").alt empty).seq ((lit "rule").seq ((ref "Atom.ident").seq (((lit ":").alt empty).seq ((ref "Pattern.pattern").seq ((ref "File.ruleArrow").seq ((ref "Template.template").seq (((ref "File.ruleGuard").alt empty).seq ((lit ";").seq empty))))))))))),
    ("File.ruleAnnot", (node "annot" ((lit "@").seq ((ref "File.ruleAnnotKind").seq empty)))),
    ("File.ruleAnnotKind", ((node "file" (lit "file")).alt ((node "decl" (lit "decl")).alt ((node "expr" (lit "expr")).alt ((node "type" (lit "type")).alt (node "entry" (lit "entry"))))))),
    ("File.ruleArrow", ((lit "~~>").alt (lit "~>"))),
    ("File.ruleGuard", (node "guard" ((lit "when").seq ((ref "File.sideCondition").seq ((((lit ",").seq ((ref "File.sideCondition").seq empty)).star).seq empty))))),
    ("File.deriveDecl", (node "DDerive" ((lit "derive").seq ((ref "File.deriveKind").seq ((lit "for").seq ((ref "Atom.ident").seq (((ref "File.deriveWith").alt empty).seq ((lit ";").seq empty)))))))),
    ("File.deriveKind", ((node "DSubst" (lit "subst")).alt ((node "DShift" (lit "shift")).alt ((node "DMap" (lit "map")).alt ((node "DFold" (lit "fold")).alt ((node "DCata" (lit "cata")).alt ((node "DAna" (lit "ana")).alt ((node "DHylo" (lit "hylo")).alt ((node "DPara" (lit "para")).alt ((node "DConv" (lit "conv")).alt ((node "DEq" (lit "eq")).alt ((node "DInfer" (lit "infer")).alt ((node "DCheck" (lit "check")).alt ((node "DNormalize" (lit "normalize")).alt (node "DEval" (lit "eval")))))))))))))))),
    ("File.deriveWith", (node "deriveWith" ((lit "with").seq ((ref "File.deriveMod").seq ((((lit ",").seq ((ref "File.deriveMod").seq empty)).star).seq empty))))),
    ("File.deriveMod", ((node "binderList" ((lit "binders").seq ((lit "=").seq ((lit "[").seq ((ref "Atom.ident").seq ((((lit ",").seq ((ref "Atom.ident").seq empty)).star).seq ((lit "]").seq empty))))))).alt ((node "fuelMod" ((lit "fuel").seq ((lit "=").seq ((ref "TOKEN.number").seq empty)))).alt (node "baseMod" ((lit "base").seq ((lit "=").seq ((ref "Pattern.pattern").seq empty))))))),
    ("File.macroDecl", (node "DMacro" ((lit "macro").seq ((ref "Atom.ident").seq (((ref "File.macroParams").alt empty).seq ((lit ":=").seq ((ref "GrammarExpr.expr").seq ((lit ";").seq empty)))))))),
    ("File.macroParams", (node "macroParams" ((ref "Atom.ident").seq ((ref "Atom.ident").star)))),
    ("File.lawsDecl", (node "DAlgebra" ((lit "algebra").seq ((ref "Atom.ident").seq ((lit "for").seq ((ref "Atom.ident").seq ((lit "{").seq (((ref "File.lawItem").star).seq ((lit "}").seq empty))))))))),
    ("File.lawItem", ((node "lawEq" ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq ((lit "=").seq ((ref "Term.term").seq ((lit ";").seq empty))))))).alt (node "lawEq2" ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq ((lit "=").seq ((ref "Term.term").seq ((lit ",").seq ((ref "Term.term").seq ((lit "=").seq ((ref "Term.term").seq ((lit ";").seq empty))))))))))))),
    ("File.algebraDecl", ((node "DPushout" ((lit "pushout").seq ((ref "Atom.ident").seq ((ref "Atom.ident").seq ((lit "along").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))))).alt ((node "DPullback" ((lit "pullback").seq ((ref "Atom.ident").seq ((ref "Atom.ident").seq ((lit "over").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))))).alt ((node "DQuotient" ((lit "quotient").seq ((ref "Atom.ident").seq ((lit "by").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))).alt ((node "DInitial" ((lit "initial").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))).alt ((node "DTerminal" ((lit "terminal").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))).alt ((node "DCoproduct" ((lit "coproduct").seq ((ref "Atom.ident").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))).alt ((node "DProduct" ((lit "product").seq ((ref "Atom.ident").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))).alt (node "DExtends" ((ref "Atom.ident").seq ((lit "extends").seq ((ref "Atom.ident").seq (((ref "File.extendWith").alt empty).seq ((lit ";").seq empty)))))))))))))),
    ("File.extendWith", (node "extendWith" ((lit "with").seq ((ref "File.extendMod").seq ((((lit ",").seq ((ref "File.extendMod").seq empty)).star).seq empty))))),
    ("File.extendMod", ((node "renameMod" ((lit "rename").seq ((ref "Atom.ident").seq ((lit "to").seq ((ref "Atom.ident").seq empty))))).alt ((node "hideMod" ((lit "hide").seq ((ref "Atom.ident").seq empty))).alt (node "overrideMod" ((lit "override").seq ((ref "Atom.ident").seq ((lit "=").seq ((ref "GrammarExpr.expr").seq empty)))))))),
    ("File.effectDecl", ((node "DEffect" ((lit "effect").seq ((ref "Atom.ident").seq ((ref "File.effectBody").seq empty)))).alt ((node "DHandler" ((lit "handler").seq ((ref "Atom.ident").seq ((lit "for").seq ((ref "Atom.ident").seq ((ref "File.effectBody").seq empty)))))).alt ((node "DFree" ((lit "free").seq ((ref "Atom.ident").seq ((lit "over").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))).alt ((node "DCofree" ((lit "cofree").seq ((ref "Atom.ident").seq ((lit "over").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))).alt (node "DMonad" ((lit "monad").seq ((ref "Atom.ident").seq ((lit "=").seq ((ref "File.monadSpec").seq ((lit ";").seq empty))))))))))),
    ("File.effectBody", ((lit "{").seq (((ref "File.effectOp").star).seq ((lit "}").seq empty)))),
    ("File.effectOp", ((node "DOp" ((lit "op").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq ((lit "→").seq ((ref "Term.term").seq ((lit ";").seq empty)))))))).alt ((node "DReturn" ((lit "return").seq ((lit ":").seq ((ref "Term.term").seq ((lit ";").seq empty))))).alt (node "DBind" ((lit "bind").seq ((lit ":").seq ((ref "Term.term").seq ((lit ";").seq empty)))))))),
    ("File.monadSpec", ((node "stateMonad" ((lit "State").seq ((ref "Atom.ident").seq empty))).alt ((node "readerMonad" ((lit "Reader").seq ((ref "Atom.ident").seq empty))).alt ((node "writerMonad" ((lit "Writer").seq ((ref "Atom.ident").seq empty))).alt ((node "errorMonad" ((lit "Error").seq ((ref "Atom.ident").seq empty))).alt ((node "ioMonad" (lit "IO")).alt ((node "productMonad" ((ref "File.monadSpec").seq ((lit "×").seq ((ref "File.monadSpec").seq empty)))).alt (node "composeMonad" ((ref "File.monadSpec").seq ((lit "∘").seq ((ref "File.monadSpec").seq empty))))))))))),
    ("File.opticsDecl", ((node "DLens" ((lit "lens").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "⟷").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))).alt ((node "DPrism" ((lit "prism").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "⟷").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))).alt ((node "DIso" ((lit "iso").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "≅").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))).alt ((node "DTraversal" ((lit "traversal").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "⟿").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))).alt ((node "DAffine" ((lit "affine").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "⤳").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))).alt ((node "DGetter" ((lit "getter").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "→").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))).alt ((node "DSetter" ((lit "setter").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "←").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))).alt (node "DReview" ((lit "review").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "↩").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))))))))))),
    ("File.adjunctionDecl", ((node "DAdjunction" ((ref "Atom.ident").seq ((lit "⊣").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "⇄").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))))))).alt ((node "DForgetful" ((lit "forgetful").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "→").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))).alt ((node "DLeftAdj" ((lit "left").seq ((lit "adjoint").seq ((ref "Atom.ident").seq ((lit "to").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))))).alt (node "DRightAdj" ((lit "right").seq ((lit "adjoint").seq ((ref "Atom.ident").seq ((lit "to").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))))))))),
    ("File.kanDecl", ((node "DLan" ((lit "lan").seq ((ref "Atom.ident").seq ((lit "along").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))).alt ((node "DRan" ((lit "ran").seq ((ref "Atom.ident").seq ((lit "along").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))).alt ((node "DYoneda" ((lit "yoneda").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))).alt ((node "DCoYoneda" ((lit "coYoneda").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))).alt ((node "DCodensity" ((lit "codensity").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))).alt (node "DDensity" ((lit "density").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))))),
    ("File.operadDecl", ((node "DOperad" ((lit "operad").seq ((ref "Atom.ident").seq ((ref "File.operadBody").seq empty)))).alt (node "DOperadAlg" ((lit "algebra").seq ((ref "Atom.ident").seq ((lit "over").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))),
    ("File.operadBody", ((lit "{").seq (((ref "File.operadOp").star).seq ((lit "}").seq empty)))),
    ("File.operadOp", ((node "DArity" ((lit "arity").seq ((ref "TOKEN.number").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))).alt ((node "DCompose" ((lit "compose").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))).alt (node "DUnit" ((lit "unit").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))),
    ("File.natDecl", ((node "DNat" ((ref "Atom.ident").seq ((lit "=>").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "⟹").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))))))).alt ((node "DDinat" ((lit "dinatural").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "⤇").seq ((ref "Atom.ident").seq ((lit ";").seq empty)))))))).alt (node "DExtranat" ((lit "extranatural").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Atom.ident").seq ((lit "⟾").seq ((ref "Atom.ident").seq ((lit ";").seq empty))))))))))),
    ("File.typeDecl", (node "DType" ((lit "type").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq (((ref "File.whenClause").alt empty).seq ((lit ";").seq empty)))))))))),
    ("File.whenClause", (node "whenClause" ((lit "when").seq ((ref "File.typeConstraint").seq ((((lit ",").seq ((ref "File.typeConstraint").seq empty)).star).seq empty))))),
    ("File.typeConstraint", ((node "constraint" ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq empty)))).alt ((node "bracketConstraint" ((lit "[").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq ((lit "]").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq empty))))))))).alt ((node "multiBracketConstraint" ((lit "[").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq ((((lit ",").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq empty)))).seq (((lit ",").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq empty)))).star)).seq ((lit "]").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq empty)))))))))).alt ((node "substConstraint" ((lit "[").seq ((ref "Pattern.pattern").seq ((lit ":=").seq ((ref "Pattern.pattern").seq ((lit "]").seq ((ref "Pattern.pattern").seq ((lit "=").seq ((ref "Term.term").seq empty))))))))).alt ((node "eqCtxConstraint" ((lit "[").seq ((ref "Pattern.pattern").seq ((lit "=").seq ((ref "Pattern.pattern").seq ((lit "]").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq empty))))))))).alt ((node "ctxConstraint" ((lit "[").seq ((ref "Pattern.pattern").seq ((lit "]").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Term.term").seq empty))))))).alt ((node "eqConstraint" ((lit "[").seq ((ref "Pattern.pattern").seq ((lit "]").seq ((ref "Term.term").seq ((lit "=").seq ((ref "Term.term").seq empty))))))).alt (ref "File.sideCondition"))))))))),
    ("File.sideCondition", ((node "notFree" ((ref "Pattern.pattern").seq ((lit "not").seq ((lit "free").seq ((lit "in").seq ((ref "Pattern.pattern").seq empty)))))).alt ((node "agreeOverlaps" ((ref "Pattern.pattern").seq ((lit "agree").seq ((lit "on").seq ((lit "overlaps").seq empty))))).alt ((node "agrees" ((ref "Pattern.pattern").seq ((lit "agrees").seq ((ref "Pattern.pattern").seq empty)))).alt ((node "boundary" ((ref "Pattern.pattern").seq ((lit "boundary").seq ((ref "Pattern.pattern").seq empty)))).alt ((node "holds" ((ref "Pattern.pattern").seq ((lit "holds").seq empty))).alt ((node "declared" ((ref "Pattern.pattern").seq ((lit "declared").seq empty))).alt ((node "bound" ((lit "bound").seq ((ref "Pattern.pattern").seq ((lit ":").seq ((ref "Pattern.pattern").seq empty))))).alt ((node "eq" ((ref "Pattern.pattern").seq ((lit "=").seq ((ref "Pattern.pattern").seq empty)))).alt (node "sidePattern" (ref "Pattern.pattern"))))))))))),
    ("File.testDecl", ((node "DTestParam" ((lit "test").seq ((lit "[").seq ((ref "Atom.ident").seq ((lit "]").seq ((ref "Atom.string").seq ((lit ":").seq ((ref "File.testBody").seq ((lit ";").seq empty))))))))).alt (node "DTest" ((lit "test").seq ((ref "Atom.string").seq ((lit ":").seq ((ref "File.annotatedTerm").seq ((((lit "~~>").seq ((ref "File.annotatedTerm").seq empty)).alt empty).seq ((lit ";").seq empty))))))))),
    ("File.testBody", (node "testBody" ((ref "File.testInput").seq ((((lit "~~>").seq ((ref "File.testExpected").seq empty)).alt empty).seq empty)))),
    ("File.testInput", (node "input" ((ref "File.testToken").seq ((ref "File.testToken").star)))),
    ("File.testExpected", (node "expected" ((ref "File.testToken").seq ((ref "File.testToken").star)))),
    ("File.testToken", ((node "paren" ((lit "(").seq (((ref "File.testToken").star).seq ((lit ")").seq empty)))).alt ((node "bracket" ((lit "[").seq (((ref "File.testToken").star).seq ((lit "]").seq empty)))).alt ((node "brace" ((lit "{").seq (((ref "File.testToken").star).seq ((lit "}").seq empty)))).alt ((node "ident" (ref "TOKEN.ident")).alt ((node "string" (ref "TOKEN.string")).alt ((node "number" (ref "TOKEN.number")).alt (node "sym" (ref "TOKEN.sym"))))))))),
    ("File.annotatedTerm", ((node "ann" ((ref "Term.term").seq ((lit ":").seq ((ref "Term.term").seq empty)))).alt (ref "Term.term"))),
    ("File.attrsDecl", (node "DAttrs" ((lit "attrs").seq ((ref "Atom.ident").seq ((ref "File.attrBody").seq empty))))),
    ("File.attrBody", ((ref "File.attrItem").star)),
    ("File.attrItem", ((ref "File.attrDecl").alt (ref "File.attrRuleDecl"))),
    ("File.attrDecl", (node "DAttr" ((ref "File.attrFlow").seq ((ref "Atom.ident").seq ((lit ":").seq ((ref "Term.term").seq ((lit ";").seq empty))))))),
    ("File.attrFlow", ((node "syn" (lit "syn")).alt (node "inh" (lit "inh")))),
    ("File.attrRuleDecl", (node "DAttrRule" ((ref "File.attrPath").seq ((lit "=").seq ((ref "Term.term").seq ((lit ";").seq empty)))))),
    ("File.attrPath", (node "attrPath" ((ref "Atom.ident").seq ((((lit ".").seq ((ref "Atom.ident").seq empty)).star).seq empty))))
  ]
  rules := []
}

/-! ## Combined Grammar -/

/-- All piece definitions -/
def allPieces : List Piece := [atomPiece, termPiece, patternPiece, templatePiece, grammarExprPiece, filePiece]

/-- Get all productions from all pieces -/
def allProductions : Productions :=
  allPieces.foldl (fun acc p => acc ++ p.grammar) []

end Lego.Generated.Bootstrap
