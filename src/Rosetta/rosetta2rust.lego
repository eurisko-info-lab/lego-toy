-----------------------------------------------------
-- rosetta2rust.lego: Transform Rosetta IR to Rust Code
--
-- This transforms the Rosetta intermediate representation into 
-- Rust syntax as defined in Rust.lego.
--
-- Pipeline: Lego source → lego2rosetta → Rosetta IR → rosetta2rust → Rust
--
-- Input: Rosetta constructs (from Rosetta.lego)
-- Output: Rust constructs (from Rust.lego)
--
-- NOTES on Rust-specific concerns:
-- - Lifetime annotations needed for references in closures
-- - Explicit type annotations on closure params (Rust can't always infer)
-- - Clone trait needed for value types in Iso operations
-- - Box<dyn Fn> for storing closures in structs
-----------------------------------------------------
import Rosetta
import Rust

lang RosettaToRust :=

-----------------------------------------------------
-- FileTransform
-- Entry point: handle file-level (seq) wrapper
-----------------------------------------------------
piece FileTransform
  -- File is a sequence of declarations - transform each
  @file rule fileToRust: (toRust (seq $decls)) ~~>
    (rustFile (toRustDecls $decls)) ;
  
  -- Transform declaration list
  rule declsToRust: (toRustDecls ($decl $rest)) ~~>
    ((toRustDecl $decl) (toRustDecls $rest)) ;
  rule declsToRustSingle: (toRustDecls $decl) ~~>
    (toRustDecl $decl) ;
  
  -- Route declarations to appropriate transformers  
  @decl rule declAdtToRust: (toRustDecl (adtDef $kw $name $lb $constrs $rb)) ~~>
    (toRust (adtDef $kw $name $lb $constrs $rb)) ;

-----------------------------------------------------
-- ADTTransform (updated)
-- Transform Rosetta ADT definitions to Rust enum
-- Structure: (adtDef "adt" Name "{" constr1 (seq "," constr2) ... "}")
-----------------------------------------------------
piece ADTTransformNew
  -- adtDef → enum (with literal syntax tokens)
  @decl rule adtToRustNew: (toRust (adtDef $kw $name $lb $constrs $rb)) ~~>
    (enumDecl $name (toRustVariants $constrs)) ;
  
  -- Transform constructor sequence - handle (seq "," next)
  rule variantsToRustSeqComma: (toRustVariants (seq "," $next)) ~~>
    (toRustVariants $next) ;
  -- Handle multiple constructors: first constr followed by rest
  rule variantsToRustFirst: (toRustVariants ((constr $name ":" $ty) $rest)) ~~>
    ((enumVariant $name (toRustFields $ty)) (toRustVariants $rest)) ;
  -- Single constructor
  rule variantsToRustSingle: (toRustVariants (constr $name ":" $ty)) ~~>
    (enumVariant $name (toRustFields $ty)) ;
  rule variantsToRustNil: (toRustVariants ()) ~~> () ;
  
  -- Transform constructor types to enum variant fields
  rule fieldsArrow: (toRustFields (typeExpr $left -> $right)) ~~>
    ((toRustType $left) (toRustFields $right)) ;
  rule fieldsBase: (toRustFields (typeExpr $t)) ~~> () ;
  rule fieldsApp: (toRustFields (typeApp $t)) ~~> () ;

-----------------------------------------------------
-- CoreTransform
-- Transform Rosetta core terms to Rust expressions
-----------------------------------------------------
piece CoreTransform
  -- Universe → () (unit type, or could use a marker)
  rule univToRust: (toRust Univ) ~~> (unitLit) ;
  
  -- Variable → var
  rule varToRust: (toRust (Var $x)) ~~> (var $x) ;
  
  -- Application → call
  rule appToRust: (toRust (App $f $a)) ~~>
    (call (toRust $f) (exprList (toRust $a))) ;
  
  -- Curried application → nested call or tuple args
  rule appCurriedToRust: (toRust (App (App $f $a) $b)) ~~>
    (call (toRust $f) (exprList (toRust $a) (toRust $b))) ;
  
  -- Substitution → let expression (block)
  rule substToRust: (toRust (Subst $x $s $body)) ~~>
    (blockExpr (block (stmtList 
      (stmtLet (patIdent $x) (toRust $s))
      (toRust $body)))) ;

-----------------------------------------------------
-- BinderTransform
-- Transform Rosetta binders to Rust closures
-- Note: Rust closures need explicit type annotations when type can't be inferred
-----------------------------------------------------
piece BinderTransform
  -- Lambda → closure with explicit param type annotation
  rule lamToRust: (toRust (Lam $x . $body)) ~~>
    (closure (paramList (param $x (refTy (tyInfer)))) (toRust $body)) ;
  
  -- Typed lambda → closure with typed param (use reference for ownership)
  rule lamTypedToRust: (toRust (Lam ($x : $A) . $body)) ~~>
    (closure (paramList (param $x (refTy (toRustType $A)))) (toRust $body)) ;
  
  -- Pi type → Fn trait (approximation)
  rule piToRust: (toRust (Pi ($x : $A) $B)) ~~>
    (tyFn (typeList (toRustType $A)) (toRustType $B)) ;
  
  -- Arrow type → Fn trait
  rule arrowToRust: (toRust (Arrow $A $B)) ~~>
    (tyFn (typeList (toRustType $A)) (toRustType $B)) ;

-----------------------------------------------------
-- ProductTransform
-- Transform Rosetta pairs/products to Rust tuples
-----------------------------------------------------
piece ProductTransform
  -- Pair → tuple
  rule pairToRust: (toRust (Pair $a $b)) ~~>
    (tuple (exprList (toRust $a) (toRust $b))) ;
  
  -- Fst → .0 access
  rule fstToRust: (toRust (Fst $p)) ~~>
    (tupleAccess (toRust $p) 0) ;
  
  -- Snd → .1 access
  rule sndToRust: (toRust (Snd $p)) ~~>
    (tupleAccess (toRust $p) 1) ;
  
  -- Product type → tuple type
  rule prodToRust: (toRust (Prod $A $B)) ~~>
    (tyTuple (typeList (toRustType $A) (toRustType $B))) ;

-----------------------------------------------------
-- ADTTransform
-- Transform Rosetta ADT definitions to Rust enum
-----------------------------------------------------
piece ADTTransform
  -- adtDef → enum
  rule adtToRust: (toRust (adtDef $name { $constrs })) ~~>
    (enumItem (pubVis) $name (toRustVariants $constrs)) ;
  
  -- Transform constructor list
  rule variantsToRust: (toRustVariants ($c $rest)) ~~>
    ((toRustVariant $c) (toRustVariants $rest)) ;
  rule variantsToRustNil: (toRustVariants ()) ~~> () ;
  
  -- Transform single constructor
  -- No args → enumVariantUnit
  rule variantUnitToRust: (toRustVariant ($name : $ty)) ~~>
    (enumVariantUnit $name)
    when (isBaseType $ty) ;
  
  -- With args → enumVariantTuple
  rule variantTupleToRust: (toRustVariant ($name : $ty)) ~~>
    (enumVariantTuple $name (toRustTupleFields $ty)) ;
  
  -- Extract tuple fields from arrow type
  rule tupleFieldsFromArrow: (toRustTupleFields (Arrow $A $B)) ~~>
    ((tupleField (toRustType $A)) (toRustTupleFields $B)) ;
  rule tupleFieldsFromBase: (toRustTupleFields $T) ~~> () ;

-----------------------------------------------------
-- RewriteTransform
-- Transform Rosetta rewrite rules to Rust functions with match
-----------------------------------------------------
piece RewriteTransform
  -- Rewrite rule → fn with match
  -- Note: Rust requires explicit lifetime/type annotations on closures
  rule rewriteToRust: (toRust (rewriteRule $name ":" $pat ~~> $repl)) ~~>
    (fnItem (pubVis) $name
      (paramList (param t (refTy (tyPath Term))))
      (returnType (tyPath Term))
      (block (stmtList
        (matchExpr (var t)
          (matchArm (toRustPat $pat) (toRust $repl))
          (matchArm (patIdent t) (call (var t) (exprList clone))))))) ;
  
  -- Pattern transforms
  rule patVarToRust: (toRustPat (Var $x)) ~~> (patIdent $x) ;
  rule patCtorToRust: (toRustPat ($f $args)) ~~>
    (patTupleStruct $f (toRustPats $args)) ;
  rule patWildToRust: (toRustPat _) ~~> (patWild) ;
  rule patsToRust: (toRustPats ($p $rest)) ~~>
    (patternList (toRustPat $p) (toRustPats $rest)) ;
  rule patsToRustNil: (toRustPats ()) ~~> (patternList) ;

-----------------------------------------------------
-- JudgmentTransform
-- Transform Rosetta type judgments to Rust (trait bounds or comments)
-----------------------------------------------------
piece JudgmentTransform
  -- Type judgment → fn with todo!()
  rule typeToRust: (toRust (typeDecl $name ":" $term ":" $ty when $conds)) ~~>
    (fnItem (pubVis) $name
      (toRustCondParams $conds)
      (returnType (tyPath bool))
      (block (stmtList (macroCall todo (exprList))))) ;
  
  -- Transform conditions to params
  rule condParamsToRust: (toRustCondParams (($t : $T) $rest)) ~~>
    (paramList (param evidence (tyPath HasType))
               (toRustCondParams $rest)) ;
  rule condParamsToRustNil: (toRustCondParams ()) ~~> (paramList) ;

-----------------------------------------------------
-- TestTransform
-- Transform Rosetta tests to Rust #[test] functions
-----------------------------------------------------
piece TestTransform
  -- test → #[test] fn with assert_eq!
  rule testToRust: (toRust (testDecl $name ":" $lhs ~~> $rhs)) ~~>
    (fnItem $name
      (paramList)
      (block (stmtList
        (macroCall assert_eq (exprList (toRust $lhs) (toRust $rhs)))))) ;

-----------------------------------------------------
-- ModuleTransform
-- Transform Rosetta modules to Rust mod
-----------------------------------------------------
piece ModuleTransform
  -- module → mod
  rule moduleToRust: (toRust (moduleDecl $name { $decls })) ~~>
    (modDefItem (pubVis) $name (toRustItems $decls)) ;
  
  -- import → use
  rule importToRust: (toRust (importDecl $name)) ~~>
    (useItem (usePath $name)) ;
  
  -- Transform item list
  rule itemsToRust: (toRustItems ($d $rest)) ~~>
    ((toRust $d) (toRustItems $rest)) ;
  rule itemsToRustNil: (toRustItems ()) ~~> () ;

-----------------------------------------------------
-- BuiltinTransform
-- Transform Rosetta builtins to Rust equivalents
-----------------------------------------------------
piece BuiltinTransform
  -- Bool
  rule boolTyToRust: (toRustType Bool) ~~> (tyPath bool) ;
  rule trueToRust: (toRust true) ~~> (trueLit) ;
  rule falseToRust: (toRust false) ~~> (falseLit) ;
  
  -- Nat → u64 (or usize)
  rule natTyToRust: (toRustType Nat) ~~> (tyPath u64) ;
  rule zeroToRust: (toRust zero) ~~> (intLit 0) ;
  rule succToRust: (toRust (succ $n)) ~~> (add (toRust $n) (intLit 1)) ;
  
  -- If-then-else
  rule ifToRust: (toRust (if $c $t $f)) ~~>
    (ifExpr (toRust $c)
      (block (stmtList (toRust $t)))
      (elseBlock (block (stmtList (toRust $f))))) ;

-----------------------------------------------------
-- OptionTransform
-- Transform Rosetta Option to Rust Option
-----------------------------------------------------
piece OptionTransform
  rule noneToRust: (toRust None) ~~> (noneLit) ;
  rule someToRust: (toRust (Some $x)) ~~> (someLit (toRust $x)) ;
  rule optionTyToRust: (toRustType (Option $A)) ~~>
    (tyOption (toRustType $A)) ;

-----------------------------------------------------
-- ListTransform
-- Transform Rosetta lists to Rust Vec
-----------------------------------------------------
piece ListTransform
  rule nilToRust: (toRust Nil) ~~> (vecLit (exprList)) ;
  rule consToRust: (toRust (Cons $h $t)) ~~>
    (blockExpr (block (stmtList
      (stmtLet (patMut (patIdent v)) (toRust $t))
      (methodCall (var v) insert (exprList (intLit 0) (toRust $h)))
      (var v)))) ;
  rule listToRust: (toRust (List $items)) ~~>
    (vecLit (toRustExprList $items)) ;

-----------------------------------------------------
-- ErrorTransform
-- Transform Rosetta errors to Rust panic
-----------------------------------------------------
piece ErrorTransform
  rule errorToRust: (toRust (Error $msg)) ~~> (panicExpr $msg) ;
  rule stuckToRust: (toRust (Stuck $t)) ~~>
    (call (var Stuck) (exprList (toRust $t))) ;

-----------------------------------------------------
-- TypeTransform
-- Transform Rosetta types to Rust types
-----------------------------------------------------
piece TypeTransform
  -- Source syntax: typeExpr with arrow
  rule typeExprArrowToRust: (toRustType (typeExpr $left -> $right)) ~~>
    (tyFn (typeList (toRustType $left)) (toRustType $right)) ;
  -- Source syntax: simple typeExpr
  rule typeExprBaseToRust: (toRustType (typeExpr $t)) ~~>
    (toRustType $t) ;
  -- Source syntax: typeApp (type application)
  rule typeAppSingleToRust: (toRustType (typeApp $t)) ~~>
    (tyPath $t) ;
  rule typeAppMultiToRust: (toRustType (typeApp $t $args)) ~~>
    (tyGeneric $t (toRustType $args)) ;
  -- IR syntax
  rule typeVarToRust: (toRustType (Var $x)) ~~> (tyPath $x) ;
  rule typeAppToRust: (toRustType (App $f $a)) ~~>
    (tyGeneric (toRustType $f) (toRustType $a)) ;
  rule typeUnivToRust: (toRustType Univ) ~~> (unitTy) ;
  rule typeBoxToRust: (toRustType (Box $A)) ~~>
    (tyGeneric Box (toRustType $A)) ;
  -- Fallback
  rule typeIdentToRust: (toRustType $t) ~~> (tyPath $t) ;

-----------------------------------------------------
-- BoxTransform
-- Transform recursive types with Box
-----------------------------------------------------
piece BoxTransform
  -- Recursive ADT fields need Box
  rule boxedFieldToRust: (toRust (Boxed $t)) ~~>
    (call (var Box) (exprList (var new) (exprList (toRust $t)))) ;
  rule boxTyToRust: (toRustType (Boxed $A)) ~~>
    (tyBox (toRustType $A)) ;

-----------------------------------------------------
-- ImplTransform
-- Generate impl blocks for ADTs
-----------------------------------------------------
piece ImplTransform
  -- Generate impl with Default
  rule implDefaultToRust: (toRustImpl $name default $body) ~~>
    (implTraitBlock Default (tyPath $name)
      (implFn (pubVis) default (paramList) 
        (returnType (tyPath Self))
        (block (stmtList (toRust $body))))) ;

-----------------------------------------------------
-- Entry Point
-----------------------------------------------------
piece Entry
  rule transformProgram: (rosettaToRust $program) ~~> (toRust $program) ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------
test "closureToRust": (toRust (Lam x . (Var x))) ~~>
  (closure (paramList (param x (tyInfer))) (var x)) ;

test "tupleToRust": (toRust (Pair (Var a) (Var b))) ~~>
  (tuple (exprList (var a) (var b))) ;

test "enumToRust": (toRust (adtDef Option { (None : Option) (Some : (arrowTy Term Option)) })) ~~>
  (enumItem (pubVis) Option
    (enumVariantUnit None)
    (enumVariantTuple Some (tupleField (tyPath Term)))) ;

test "matchToRust": (toRust (rewriteRule unwrap: (Some $x) ~~> $x)) ~~>
  (fnItem (pubVis) unwrap
    (paramList (param t (tyPath Term)))
    (returnType (tyPath Term))
    (block (stmtList
      (matchExpr (var t)
        (matchArm (patTupleStruct Some (patternList (patIdent x))) (var x))
        (matchArm (patIdent t) (var t)))))) ;

