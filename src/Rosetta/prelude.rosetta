-----------------------------------------------------
-- prelude.rosetta: Rosetta Prelude/Foundationals
--
-- Provides the core constructs in Rosetta notation.
-- Imported by all generated Rosetta specs.
--
-- Uses the new piece-based syntax:
--   piece Name
--     term ::= ... → node ;
--     rule name: pattern ~~> replacement ;
--     type name: term : type when premises ;
--
-- No cubical features - pure abstractions.
-----------------------------------------------------

lang Prelude :=

-----------------------------------------------------
-- UnivAndTypes
-- Abstract universe and type formation
-----------------------------------------------------

piece UnivAndTypes
  term ::= "Univ"                      → univ ;   -- Universe type

  type univForm: Univ : Univ ;

-----------------------------------------------------
-- Variables
-- Abstract variables with binding
-----------------------------------------------------

piece Variables
  term ::= "Var" <ident>               → var ;    -- Variable reference

  type varType: (Var $x) : $T when bound $x : $T ;

-----------------------------------------------------
-- Substitution
-- Abstract capture-avoiding substitution
-----------------------------------------------------

piece Substitution
  term ::= "Subst" <ident> term term   → subst ;  -- subst x t body

  rule substVar: (Subst $x $s (Var $x)) ~~> $s ;
  rule substVarNeq: (Subst $x $s (Var $y)) ~~> (Var $y) ;  -- when x ≠ y

-----------------------------------------------------
-- Application
-- Function application
-----------------------------------------------------

piece Application
  term ::= "App" term term             → app ;    -- f a

  rule appSubst: (App (Subst $x $s $f) $a) ~~> (Subst $x $s (App $f $a)) ;

-----------------------------------------------------
-- Binders
-- Lambda abstraction (term binders only)
-----------------------------------------------------

piece Binders
  term ::= "Lam" <ident> "." term      → lam ;    -- λx. body

  rule beta: (App (Lam $x . $body) $arg) ~~> (Subst $x $arg $body) ;

  type lamForm: (Lam $x . $body) : (Arrow $A $B)
    when [$x : $A] $body : $B ;

-----------------------------------------------------
-- Products
-- Non-dependent pairs
-----------------------------------------------------

piece Products
  term ::= "Pair" term term            → pair
         | "Fst" term                  → fst
         | "Snd" term                  → snd ;

  rule fstPair: (Fst (Pair $a $b)) ~~> $a ;
  rule sndPair: (Snd (Pair $a $b)) ~~> $b ;
  rule pairEta: (Pair (Fst $p) (Snd $p)) ~~> $p ;

  type pairType: (Pair $a $b) : (Prod $A $B)
    when $a : $A, $b : $B ;
  type fstType: (Fst $p) : $A when $p : (Prod $A $B) ;
  type sndType: (Snd $p) : $B when $p : (Prod $A $B) ;

-----------------------------------------------------
-- DimensionBinders (for cubical, but abstract)
-- Dimension lambda and application
-----------------------------------------------------

piece DimensionBinders
  term ::= "DLam" <ident> "." term     → dlam     -- λⁱ. body (dimension)
         | "DApp" term term            → dapp ;   -- f @ r

  rule dbeta: (DApp (DLam $i . $body) $r) ~~> (Subst $i $r $body) ;

-----------------------------------------------------
-- Lists
-- Abstract list operations
-----------------------------------------------------

piece Lists
  term ::= "Nil"                       → nil
         | "Cons" term term            → cons ;

  rule consNilEta: (Cons $h Nil) ~~> (Cons $h Nil) ;  -- identity

-----------------------------------------------------
-- Constants
-- Literal values
-----------------------------------------------------

piece Constants
  term ::= "IntLit" <number>           → intLit
         | "StrLit" <string>           → strLit
         | "BoolLit" <ident>           → boolLit ;  -- true/false

-----------------------------------------------------
-- Errors
-- Error handling
-----------------------------------------------------

piece Errors
  term ::= "Error" <string>            → error
         | "Stuck" term                → stuck ;

  rule appError: (App (Error $msg) $a) ~~> (Error $msg) ;
  rule fstError: (Fst (Error $msg)) ~~> (Error $msg) ;
  rule sndError: (Snd (Error $msg)) ~~> (Error $msg) ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------

test "substId": (Subst x (Var y) (Var x)) ~~> (Var y) ;
test "beta": (App (Lam x . (Var x)) (Var y)) ~~> (Var y) ;
test "fstPair": (Fst (Pair (Var a) (Var b))) ~~> (Var a) ;
test "sndPair": (Snd (Pair (Var a) (Var b))) ~~> (Var b) ;