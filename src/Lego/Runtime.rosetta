-----------------------------------------------------
-- Runtime.rosetta: True Runtime Bootstrap
--
-- Implements the proper bootstrap chain:
-- 1. Hardcoded minimal grammar parses Bootstrap.lego ONLY
-- 2. Bootstrap.lego provides the grammar for Lego.lego
-- 3. Lego.lego provides the full grammar
-- 4. Full grammar parses all other .lego files
--
-- Architecture:
--   Hardcoded → Bootstrap.lego → Lego.lego → *.lego
-----------------------------------------------------

import Grammar;

-----------------------------------------------------
-- Production and LoadedGrammar (depends on GrammarExpr)
-----------------------------------------------------

adt Production {
  MkProd : String -> GrammarExpr -> String -> Production
}

adt LoadedGrammar {
  MkGrammar : List Production 
           -> List Production
           -> List String
           -> String
           -> LoadedGrammar
}

adt Rule {
  MkRule : String -> Term -> Term -> Rule
}

-----------------------------------------------------
-- Runtime State
--
-- Extended to hold multiple grammars:
-- - grammar: Lego.lego grammar for .lego files
-- - rosettaGrammar: Rosetta.lego grammar for .rosetta files
-- - leanGrammar: Lean.lego grammar for .lean files
-----------------------------------------------------

adt Runtime {
  MkRuntime : LoadedGrammar     -- Lego grammar
           -> LoadedGrammar     -- Rosetta grammar
           -> LoadedGrammar     -- Lean grammar
           -> List Rule         -- Loaded rules
           -> Runtime
}

-- Get Lego grammar from runtime
rewrite rtGrammar:
  (rtGrammar (MkRuntime $grammar $rosetta $lean $rules)) ~> $grammar ;

-- Get Rosetta grammar from runtime
rewrite rtRosettaGrammar:
  (rtRosettaGrammar (MkRuntime $grammar $rosetta $lean $rules)) ~> $rosetta ;

-- Get Lean grammar from runtime
rewrite rtLeanGrammar:
  (rtLeanGrammar (MkRuntime $grammar $rosetta $lean $rules)) ~> $lean ;

-- Get rules from runtime
rewrite rtRules:
  (rtRules (MkRuntime $grammar $rosetta $lean $rules)) ~> $rules ;

-----------------------------------------------------
-- Bootstrap Loading
-----------------------------------------------------

-- Load Bootstrap.lego using hardcoded grammar
-- Returns just the grammar (not full Runtime) for composition
rewrite loadBootstrap:
  (loadBootstrap $content) ~>
    (case (parseBootstrap $content)
      (Some $ast) 
        (let $prods (extractProductions $ast)
          (let $tokProds (extractTokenProductions $ast)
            (Some (MkGrammar $prods $tokProds Nil "File.legoFile"))))
      None None) ;

-- Parse Bootstrap.lego with hardcoded grammar (built-in)
-- This is the ONLY file the hardcoded grammar accepts
rewrite parseBootstrap:
  (parseBootstrap $content) ~> (hardcodedParse $content) ;

-----------------------------------------------------
-- Load Lego.lego (after bootstrap)
-----------------------------------------------------

-- Load Lego.lego using Bootstrap grammar, returns merged grammar
rewrite loadLego:
  (loadLego $bootstrapGrammar $content) ~>
    (case (parseWithGrammar $bootstrapGrammar $content)
      (Some $ast)
        (let $prods (extractProductions $ast)
          (let $tokProds (extractTokenProductions $ast)
            (let $mergedProds (append $prods (grammarProds $bootstrapGrammar))
              (let $mergedTokProds (append $tokProds (grammarTokProds $bootstrapGrammar))
                (Some (MkGrammar $mergedProds $mergedTokProds 
                                 (extractSymbols $mergedProds) "File.legoFile"))))))
      None None) ;

-----------------------------------------------------
-- Load Rosetta.lego (after Lego.lego)
-----------------------------------------------------

-- Load Rosetta.lego using Lego grammar, returns merged grammar
rewrite loadRosetta:
  (loadRosetta $legoGrammar $content) ~>
    (case (parseWithGrammar $legoGrammar $content)
      (Some $ast)
        (let $prods (extractProductions $ast)
          (let $tokProds (extractTokenProductions $ast)
            (let $mergedProds (append $prods (grammarProds $legoGrammar))
              (let $mergedTokProds (append $tokProds (grammarTokProds $legoGrammar))
                (Some (MkGrammar $mergedProds $mergedTokProds
                                 (extractSymbols $mergedProds) "File.rosettaFile"))))))
      None None) ;

-----------------------------------------------------
-- Load Lean.lego (after Lego.lego)
-----------------------------------------------------

-- Load Lean.lego using Lego grammar, returns merged grammar
rewrite loadLean:
  (loadLean $legoGrammar $content) ~>
    (case (parseWithGrammar $legoGrammar $content)
      (Some $ast)
        (let $prods (extractProductions $ast)
          (let $tokProds (extractTokenProductions $ast)
            (let $mergedProds (append $prods (grammarProds $legoGrammar))
              (let $mergedTokProds (append $tokProds (grammarTokProds $legoGrammar))
                (Some (MkGrammar $mergedProds $mergedTokProds
                                 (extractSymbols $mergedProds) "Module.module"))))))
      None None) ;

-----------------------------------------------------
-- Load a Language from .lego file with Inheritance
--
-- When a language declares `lang X (Parent) :=`:
-- 1. Load the parent grammar(s) recursively
-- 2. Merge parent productions into child grammar
-- This way token definitions flow through the inheritance chain.
-----------------------------------------------------

rewrite loadLanguage:
  (loadLanguage $rt $path) ~>
    (loadLanguageWithParents $rt $path Nil) ;

-- Load language with parent inheritance tracking (to prevent cycles)
rewrite loadLanguageWithParents:
  (loadLanguageWithParents $rt $path $visited) ~>
    (if (elem $path $visited)
      (Err (concat "Circular language inheritance: " $path))
      (case (readFile $path)
        (Some $content) (loadLanguageContent $rt $path $content (Cons $path $visited))
        None (Err (concat "Cannot read file: " $path)))) ;

rewrite loadLanguageContent:
  (loadLanguageContent $rt $path $content $visited) ~>
    (case (parseLegoFile $rt $content)
      (Some $ast)
        (let $parentNames (extractParentNames $ast)
          (loadWithParents $rt $path $ast $parentNames $visited))
      None (Err "parse failed")) ;

-- Load parent grammars and merge
rewrite loadWithParents:
  (loadWithParents $rt $path $ast $parentNames $visited) ~>
    (case (loadParentGrammars $rt $path $parentNames $visited)
      (Ok $inheritedProds $inheritedTokProds)
        (let $childProds (extractProductions $ast)
          (let $childTokProds (extractTokenProductions $ast)
            (let $mergedProds (append $inheritedProds $childProds)
              (let $mergedTokProds (append $inheritedTokProds $childTokProds)
                (let $syms (extractSymbols $mergedProds)
                  (let $start (findStartProd $childProds)
                    (Ok (MkGrammar $mergedProds $mergedTokProds $syms $start))))))))
      (Err $e) (Err $e)) ;

-- Load all parent grammars recursively
rewrite loadParentGrammars:
  (loadParentGrammars $rt $childPath Nil $visited) ~>
    (Ok Nil Nil) ;

rewrite loadParentGrammarsNonEmpty:
  (loadParentGrammars $rt $childPath (Cons $parent $rest) $visited) ~>
    (case (resolveParentPath $parent $childPath)
      (Some $parentPath)
        (case (loadLanguageWithParents $rt $parentPath $visited)
          (Ok $parentGrammar)
            (case (loadParentGrammars $rt $childPath $rest $visited)
              (Ok $restProds $restTokProds)
                (Ok (append (grammarProds $parentGrammar) $restProds)
                    (append (grammarTokProds $parentGrammar) $restTokProds))
              (Err $e) (Err $e))
          (Err $e) (Err (concat "Failed to load parent " (concat $parent (concat ": " $e)))))
      None 
        (if (eq $parent "Bootstrap")
          -- Bootstrap is special - its tokens are in runtime
          (case (loadParentGrammars $rt $childPath $rest $visited)
            (Ok $restProds $restTokProds)
              (Ok (append (grammarProds (rtGrammar $rt)) $restProds)
                  (append (grammarTokProds (rtGrammar $rt)) $restTokProds))
            (Err $e) (Err $e))
          (Err (concat "Cannot find parent language: " $parent)))) ;

-- Resolve parent path - search standard locations
rewrite resolveParentPath:
  (resolveParentPath $parentName $childPath) ~>
    (findFirst fileExists
      (Cons (concat (dirname $childPath) (concat "/" (concat $parentName ".lego")))
        (Cons (concat "test/" (concat $parentName ".lego"))
          (Cons (concat "src/Lego/" (concat $parentName ".lego"))
            (Cons (concat "src/Rosetta/" (concat $parentName ".lego"))
              Nil))))) ;

-- Get productions from grammar
rewrite grammarProds:
  (grammarProds (MkGrammar $prods $tokProds $syms $start)) ~> $prods ;

-- Get token productions from grammar
rewrite grammarTokProds:
  (grammarTokProds (MkGrammar $prods $tokProds $syms $start)) ~> $tokProds ;

-----------------------------------------------------
-- Extract token productions
-----------------------------------------------------

-- Extract token productions
rewrite extractTokenProductions:
  (extractTokenProductions $ast) ~>
    (filter isTokenProd (extractProductions $ast)) ;

rewrite isTokenProd:
  (isTokenProd (MkProd $name $g $c)) ~> (startsWith $name "TOKEN.") ;

-- Extract all symbols used in grammar
rewrite extractSymbols:
  (extractSymbols $prods) ~>
    (nub (concatMap prodSymbols $prods)) ;

rewrite prodSymbols:
  (prodSymbols (MkProd $name $g $c)) ~> (grammarSymbols $g) ;

rewrite grammarSymbolsRef:
  (grammarSymbols (GRef $name)) ~> (Cons $name Nil) ;

rewrite grammarSymbolsSeq:
  (grammarSymbols (GSeq $g1 $g2)) ~> (append (grammarSymbols $g1) (grammarSymbols $g2)) ;

rewrite grammarSymbolsAlt:
  (grammarSymbols (GAlt $g1 $g2)) ~> (append (grammarSymbols $g1) (grammarSymbols $g2)) ;

rewrite grammarSymbolsStar:
  (grammarSymbols (GStar $g)) ~> (grammarSymbols $g) ;

rewrite grammarSymbolsOther:
  (grammarSymbols $g) ~> Nil ;

-- Find start production
rewrite findStartProd:
  (findStartProd (Cons (MkProd $name $g $c) $rest)) ~> $name ;

rewrite findStartProdEmpty:
  (findStartProd Nil) ~> "File.legoFile" ;

-----------------------------------------------------
-- Normalization with Runtime Rules
-----------------------------------------------------

rewrite normalize:
  (normalize $rt $term) ~> (normalizeWith 1000 (rtRules $rt) $term) ;

rewrite normalizeWith:
  (normalizeWith 0 $rules $t) ~> $t ;

rewrite normalizeWithFuel:
  (normalizeWith $n $rules $t) ~>
    (case (tryApplyRules $rules $t)
      (Some $t') (normalizeWith (sub $n 1) $rules $t')
      None (normalizeChildren $n $rules $t)) ;

rewrite tryApplyRules:
  (tryApplyRules (Cons (MkRule $name $pat $tmpl) $rest) $t) ~>
    (case (matchPat $pat $t)
      (Some $bindings) (Some (subst $tmpl $bindings))
      None (tryApplyRules $rest $t)) ;

rewrite tryApplyRulesEmpty:
  (tryApplyRules Nil $t) ~> None ;

rewrite normalizeChildren:
  (normalizeChildren $n $rules (Var $x)) ~> (Var $x) ;

rewrite normalizeChildrenLit:
  (normalizeChildren $n $rules (Lit $s)) ~> (Lit $s) ;

rewrite normalizeChildrenCon:
  (normalizeChildren $n $rules (Con $name $args)) ~>
    (Con $name (map (normalizeWith $n $rules) $args)) ;

-----------------------------------------------------
-- Pretty Printing
-----------------------------------------------------

rewrite printTerm:
  (printTerm $rt $term $prodName) ~>
    (case (printWithGrammar (rtGrammar $rt) $prodName $term)
      (PrintOk $tokens) (Some (joinTokens $tokens))
      (PrintFail $msg) None) ;

rewrite joinTokens:
  (joinTokens $tokens) ~> (intercalate " " (map tokenToString $tokens)) ;

rewrite tokenToString:
  (tokenToString (TokIdent $s)) ~> $s ;

rewrite tokenToStringStr:
  (tokenToString (TokString $s)) ~> (concat "\"" (concat $s "\"")) ;

rewrite tokenToStringSym:
  (tokenToString (TokSym $s)) ~> $s ;

-----------------------------------------------------
-- Full Bootstrap Chain
-----------------------------------------------------

-- Initialize runtime: load Bootstrap.lego then Lego.lego then Rosetta.lego then Lean.lego
rewrite initRuntime:
  (initRuntime $bootstrapContent $legoContent $rosettaContent $leanContent) ~>
    (case (loadBootstrap $bootstrapContent)
      (Some $bootstrapRt)
        (case (loadLego $bootstrapRt $legoContent)
          (Some $legoGrammar)
            (case (loadRosetta $legoGrammar $rosettaContent)
              (Some $rosettaGrammar)
                (case (loadLean $legoGrammar $leanContent)
                  (Some $leanGrammar)
                    (Ok (MkRuntime $legoGrammar $rosettaGrammar $leanGrammar 
                                   (append (extractRules $legoContent)
                                           (append (extractRules $rosettaContent)
                                                   (extractRules $leanContent)))))
                  None (Err "failed to load Lean.lego"))
              None (Err "failed to load Rosetta.lego"))
          None (Err "failed to load Lego.lego"))
      None (Err "failed to load Bootstrap.lego")) ;

-- Quiet initialization (no logging) - same as initRuntime but silent
rewrite initRuntimeQuiet:
  (initRuntimeQuiet $bootstrapContent $legoContent $rosettaContent $leanContent) ~>
    (initRuntime $bootstrapContent $legoContent $rosettaContent $leanContent) ;

-----------------------------------------------------
-- Singleton Pattern (optional caching)
-----------------------------------------------------

-- A cached runtime state (mutable cell conceptually)
adt RuntimeCache {
  CacheEmpty : RuntimeCache,
  CacheFull  : Runtime -> RuntimeCache
}

-- Initialize once and reuse (reduces repeated loading)
rewrite initSingleton:
  (initSingleton $cache $bootstrapContent $legoContent $rosettaContent $leanContent $quiet) ~>
    (case $cache
      CacheEmpty 
        (let $result (if $quiet 
                        (initRuntimeQuiet $bootstrapContent $legoContent $rosettaContent $leanContent)
                        (initRuntime $bootstrapContent $legoContent $rosettaContent $leanContent))
          (case $result
            (Ok $rt) (Pair (CacheFull $rt) $rt)
            (Err $e) (Pair CacheEmpty (Err $e))))
      (CacheFull $rt) (Pair (CacheFull $rt) $rt)) ;

-----------------------------------------------------
-- File Parsing Helpers
-----------------------------------------------------

-- Parse .lego file using Lego grammar
rewrite parseLegoFile:
  (parseLegoFile $rt $content) ~>
    (parseWithGrammar (rtGrammar $rt) $content) ;

-- Parse .rosetta file using Rosetta grammar
rewrite parseRosettaFile:
  (parseRosettaFile $rt $content) ~>
    (parseWithGrammar (rtRosettaGrammar $rt) $content) ;

-- Parse .lean file using Lean grammar
rewrite parseLeanFile:
  (parseLeanFile $rt $content) ~>
    (parseWithGrammar (rtLeanGrammar $rt) $content) ;

-- Parse with error handling
rewrite parseLegoFileE:
  (parseLegoFileE $rt $content) ~>
    (case (parseWithGrammar (rtGrammar $rt) $content)
      (ParseOk $t $s) (Ok $t)
      (ParseFail $msg $s) (Err $msg)) ;

rewrite parseRosettaFileE:
  (parseRosettaFileE $rt $content) ~>
    (case (parseWithGrammar (rtRosettaGrammar $rt) $content)
      (ParseOk $t $s) (Ok $t)
      (ParseFail $msg $s) (Err $msg)) ;

rewrite parseLeanFileE:
  (parseLeanFileE $rt $content) ~>
    (case (parseWithGrammar (rtLeanGrammar $rt) $content)
      (ParseOk $t $s) (Ok $t)
      (ParseFail $msg $s) (Err $msg)) ;

-- Convenience: initialize and parse a file in one step
rewrite initAndParse:
  (initAndParse $path $bootstrapContent $legoContent $rosettaContent $leanContent) ~>
    (case (initRuntime $bootstrapContent $legoContent $rosettaContent $leanContent)
      (Ok $rt)
        (case (readFile $path)
          (Some $content)
            (if (endsWith $path ".rosetta")
                (parseRosettaFileE $rt $content)
            (if (endsWith $path ".lean")
                (parseLeanFileE $rt $content)
                (parseLegoFileE $rt $content)))
          None (Err (concat "Cannot read file " $path)))
      (Err $e) (Err $e)) ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------

test "normalize_id": (normalizeWith 10 Nil (Var "x")) ~~> (Var "x") ;

test "tryApplyRules_empty": (tryApplyRules Nil (Var "x")) ~~> None ;
