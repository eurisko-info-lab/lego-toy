-----------------------------------------------------
-- Lego.rosetta: Self-Specification of Lego in Rosetta
--
-- This specifies Lego itself using Rosetta syntax, enabling
-- compilation to all target languages (Lean, Scala, Haskell, Rust).
--
-- Uses Rosetta constructs: adt, rewrite, module, test
-----------------------------------------------------

-----------------------------------------------------
-- Core Types: The Universal AST
-----------------------------------------------------

adt Term {
  Var : String -> Term,
  Lit : String -> Term,
  Con : String -> List Term -> Term
}

adt Env {
  Empty : Env,
  Bind : String -> Term -> Env -> Env
}

adt Rule {
  MkRule : String -> Term -> Term -> Rule
}

-- Note: Using built-in Option type (Some/None)

-----------------------------------------------------
-- Pattern Matching
-----------------------------------------------------

rewrite matchVarMeta:
  (match (Var $name) $t) ~> (Some (Bind $name $t Empty))
  when (startsWith $name "$") ;

rewrite matchVarSame:
  (match (Var $name) (Var $name)) ~> (Some Empty) ;

rewrite matchVarDiff:
  (match (Var $name) $t) ~> None ;

rewrite matchLitSame:
  (match (Lit $s) (Lit $s)) ~> (Some Empty) ;

rewrite matchLitDiff:
  (match (Lit $a) (Lit $b)) ~> None ;

rewrite matchConSame:
  (match (Con $n $args1) (Con $n $args2)) ~> (matchList $args1 $args2) ;

rewrite matchConDiff:
  (match (Con $n1 $args1) (Con $n2 $args2)) ~> None ;

rewrite matchListNil:
  (matchList Nil Nil) ~> (Some Empty) ;

rewrite matchListCons:
  (matchList (Cons $p $ps) (Cons $t $ts)) ~> 
    (merge (match $p $t) (matchList $ps $ts)) ;

rewrite mergeEnvs:
  (merge (Some $e1) (Some $e2)) ~> (Some (append $e1 $e2)) ;

rewrite mergeFail:
  (merge None $e) ~> None ;

-----------------------------------------------------
-- Substitution
-----------------------------------------------------

rewrite substVarHit:
  (subst (Var $name) (Bind $name $val $rest)) ~> $val ;

rewrite substVarMiss:
  (subst (Var $name) (Bind $other $val $rest)) ~> (subst (Var $name) $rest) ;

rewrite substVarEmpty:
  (subst (Var $name) Empty) ~> (Var $name) ;

rewrite substLit:
  (subst (Lit $s) $env) ~> (Lit $s) ;

rewrite substCon:
  (subst (Con $name $args) $env) ~> (Con $name (map (subst $env) $args)) ;

-----------------------------------------------------
-- Rule Application
-----------------------------------------------------

rewrite applyRule:
  (apply (MkRule $name $pat $tmpl) $t) ~>
    (case (match $pat $t)
      (Some $env) (subst $tmpl $env)
      None None) ;

rewrite tryRulesFirst:
  (tryRules (Cons $r $rs) $t) ~>
    (case (apply $r $t)
      (Some $result) (Some $result)
      None (tryRules $rs $t)) ;

rewrite tryRulesEmpty:
  (tryRules Nil $t) ~> None ;

-----------------------------------------------------
-- Interpreter: Normalize to fixpoint
-----------------------------------------------------

rewrite normalizeStep:
  (normalize $rules $t) ~>
    (let $t' (normalizeOnce $rules $t)
      (if (eq $t $t') $t (normalize $rules $t'))) ;

rewrite normalizeOnceTop:
  (normalizeOnce $rules $t) ~>
    (case (tryRules $rules $t)
      (Some $result) $result
      None (normalizeChildren $rules $t)) ;

rewrite normalizeChildrenVar:
  (normalizeChildren $rules (Var $x)) ~> (Var $x) ;

rewrite normalizeChildrenLit:
  (normalizeChildren $rules (Lit $s)) ~> (Lit $s) ;

rewrite normalizeChildrenCon:
  (normalizeChildren $rules (Con $name $args)) ~>
    (Con $name (map (normalizeOnce $rules) $args)) ;

-----------------------------------------------------
-- ROSETTA LAYER (builds on Lego)
-----------------------------------------------------
-- Rosetta extends Lego with:
--   1. Partial Isomorphisms (bidirectional transforms)
--   2. Grammar representation (parsing/printing)
--   3. Language-to-language mappings
-----------------------------------------------------

-----------------------------------------------------
-- Partial Isomorphisms
-----------------------------------------------------

-- Iso is a partial isomorphism (bidirectional partial function)
adt Iso {
  MkIso : (a -> Option b) -> (b -> Option a) -> Iso a b
}

rewrite isoForward:
  (forward (MkIso $fwd $bwd) $x) ~> (App $fwd $x) ;

rewrite isoBackward:
  (backward (MkIso $fwd $bwd) $x) ~> (App $bwd $x) ;

rewrite isoComp:
  (comp (MkIso $f1 $b1) (MkIso $f2 $b2)) ~>
    (MkIso 
      (Lam x . (bind (App $f1 x) y (App $f2 y)))
      (Lam z . (bind (App $b2 z) y (App $b1 y)))) ;

rewrite isoSym:
  (sym (MkIso $fwd $bwd)) ~> (MkIso $bwd $fwd) ;

-----------------------------------------------------
-- Grammar Representation
-----------------------------------------------------

adt Symbol {
  Terminal : String -> Symbol,
  NonTerminal : String -> Symbol,
  Epsilon : Symbol
}

adt Production {
  MkProd : String -> List Symbol -> String -> Production
}

adt Grammar {
  MkGrammar : List Production -> Grammar
}

-----------------------------------------------------
-- Parser/Printer Isomorphisms (Rosetta's key insight)
-----------------------------------------------------

adt Parser {
  MkParser : Grammar -> (String -> Option Term) -> Parser
}

adt Printer {
  MkPrinter : Grammar -> (Term -> Option String) -> Printer
}

-- A language is a grammar + its parse/print iso
adt Language {
  MkLang : String -> Grammar -> (Iso String Term) -> Language
}

-- Rosetta composition: L1 <-> Universal <-> L2
rewrite rosettaTranslate:
  (translate (MkLang $n1 $g1 $iso1) (MkLang $n2 $g2 $iso2) $src) ~>
    (forward $iso2 (backward $iso1 $src)) ;

-- Round-trip property: parse then print should preserve
rewrite roundTrip:
  (roundtrip (MkLang $n $g (MkIso $parse $print)) $src) ~>
    (bind (App $parse $src) $ast (App $print $ast)) ;

-----------------------------------------------------
-- List Operations
-----------------------------------------------------

rewrite mapNil:
  (map $f Nil) ~> Nil ;

rewrite mapCons:
  (map $f (Cons $x $xs)) ~> (Cons (App $f $x) (map $f $xs)) ;

rewrite foldNil:
  (fold $f $acc Nil) ~> $acc ;

rewrite foldCons:
  (fold $f $acc (Cons $x $xs)) ~> (fold $f (App $f $acc $x) $xs) ;

rewrite appendNil:
  (append Nil $ys) ~> $ys ;

rewrite appendCons:
  (append (Cons $x $xs) $ys) ~> (Cons $x (append $xs $ys)) ;

-----------------------------------------------------
-- Builtins
-----------------------------------------------------

rewrite ifTrue:
  (if true $then $else) ~> $then ;

rewrite ifFalse:
  (if false $then $else) ~> $else ;

rewrite eqSame:
  (eq $x $x) ~> true ;

rewrite bindSome:
  (bind (Some $x) $var $body) ~> (subst $body (Bind $var $x Empty)) ;

rewrite bindNone:
  (bind None $var $body) ~> None ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------

test "match_meta": (match (Var "$x") (Lit "hello")) ~~> (Some (Bind "$x" (Lit "hello") Empty)) ;

test "subst_simple": (subst (Con "f" (Cons (Var "$x") Nil)) (Bind "$x" (Lit "a") Empty)) ~~> (Con "f" (Cons (Lit "a") Nil)) ;

test "normalize_id": (normalize Nil (Var "x")) ~~> (Var "x") ;

