-----------------------------------------------------
-- Lean.lego: Lean 4 AST Definition for Rosetta
--
-- This defines the Lean 4 abstract syntax tree as a Lego specification.
-- It serves as the TARGET representation for rosetta2lean transformation.
--
-- Structure follows the Rosetta design pattern:
-- - Term syntax via 'term ::=' grammar
-- - Type syntax via 'type ::=' grammar  
-- - Declaration syntax via 'decl ::=' grammar
-- - No transformation rules here - those go in rosetta2lean.lego
--
-- This is the "what Lean code looks like" specification.
-----------------------------------------------------
lang Lean :=

-----------------------------------------------------
-- Token: Character-level grammar (lexer)
-- Defines Lean-specific tokenization including comments
-----------------------------------------------------
token Token
  -- Basic ASCII character classes
  digit  ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
  lower  ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
           | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
           | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
  upper  ::= 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
           | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
           | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
  alpha  ::= lower | upper | '_' ;
  
  -- Symbol characters (for operators)
  symch  ::= '+' | '-' | '*' | '/' | '=' | '<' | '>' | '!' | '@' | '#'
           | '$' | '%' | '^' | '&' | '|' | '~' | '?' | ':' | ';' | ','
           | '.' | '[' | ']' | '(' | ')' | '{' | '}' | '`' | '\\' ;
  
  -- Identifiers
  ident  ::= alpha (alpha | digit | '\'' | '?' | '!' | '«' | '»')* ;
  
  -- Numbers  
  number ::= digit+ ;
  
  -- String literals
  string ::= '"' strchar* '"' ;
  strchar ::= '\\' escape | alpha | digit | symch | ' ' | '\'' | '\t' ;
  escape ::= 'n' | 't' | 'r' | '\\' | '"' | '\'' | '0' ;
  
  -- Whitespace
  ws     ::= ' ' | '\t' | '\n' | '\r' ;
  
  -- Line comments: -- ...
  comment ::= '-' '-' nonnl* ;
  nonnl  ::= alpha | digit | symch | ' ' | '\t' | '\'' | '"' ;
  
  -- Block comments: /- ... -/
  -- Note: The tokenizer handles nested block comments specially
  blockComment ::= '/' '-' blockInner* '-' '/' ;
  blockInner ::= alpha | digit | symch | ' ' | '\t' | '\n' | '\r' | '\'' | '"' | '-' ;
  
  -- Operators
  operator ::= #longest[
      ':' ':' '=',   -- ::=
      '~' '~' '>',   -- ~~>
      ':' '=',       -- :=
      '~' '>',       -- ~>
      '-' '>',       -- ->
      '→',           -- Unicode arrow
      '<' '-',       -- <-
      '←',           -- Unicode left arrow
      '=' '>',       -- =>
      '⇒',           -- Unicode double arrow
      '|' '>',       -- |>
      '<' '|',       -- <|
      '&' '&',       -- &&
      '|' '|',       -- ||
      '=' '=',       -- ==
      '!' '=',       -- !=
      '<' '=',       -- <=
      '≤',           -- Unicode <=
      '>' '=',       -- >=
      '≥',           -- Unicode >=
      '+' '+',       -- ++
      ':' ':',       -- ::
      '.' '1',       -- .1
      '.' '2',       -- .2
      '∀',           -- forall
      '∃',           -- exists
      'Π',           -- Pi
      'Σ',           -- Sigma
      '×',           -- product
      '⟨',           -- angle bracket open
      '⟩',           -- angle bracket close
      '↑',           -- coercion
      '#' '[',       -- array literal
      '#' 'c' 'h' 'e' 'c' 'k',  -- #check
      '#' 'e' 'v' 'a' 'l',       -- #eval
      '#' 'p' 'r' 'i' 'n' 't',   -- #print
      '@' '[',       -- attribute start
      '@',           -- explicit
      '$',           -- dollar
      '+', '-', '*', '/', '%',
      '<', '>', '=', '!',
      '(', ')', '[', ']', '{', '}',
      ',', '.', ':', ';', '|', '_'
    ] ;

-----------------------------------------------------
-- Core Terms
-- Basic Lean expressions
-- Grammar is structured to avoid left-recursion:
--   term -> arrowExpr -> orExpr -> andExpr -> cmpExpr -> addExpr -> mulExpr -> unaryExpr -> appExpr -> atomExpr
-----------------------------------------------------
piece CoreTerms
  -- Top level: arrow types (right-associative)
  term ::= arrowExpr                              → term ;
  
  arrowExpr ::= orExpr "→" arrowExpr              → arrowTy
              | orExpr "×" arrowExpr              → prodTy
              | orExpr                            → arrowExpr
              ;
  
  -- Logical or
  orExpr ::= andExpr "||" orExpr                  → or
           | andExpr                              → orExpr
           ;
  
  -- Logical and
  andExpr ::= cmpExpr "&&" andExpr                → and
            | cmpExpr                             → andExpr
            ;
  
  -- Comparison operators (non-associative)
  cmpExpr ::= addExpr "==" addExpr                → beq
            | addExpr "!=" addExpr                → bne
            | addExpr "<" addExpr                 → lt
            | addExpr ">" addExpr                 → gt
            | addExpr "<=" addExpr                → le
            | addExpr ">=" addExpr                → ge
            | addExpr                             → cmpExpr
            ;
  
  -- Additive operators (left-to-right via iteration)
  addExpr ::= mulExpr addOp*                      → addExpr ;
  addOp ::= "+" mulExpr                           → addOp
          | "-" mulExpr                           → subOp
          | "++" mulExpr                          → appendOp
          | "::" mulExpr                          → consOp
          ;
  
  -- Multiplicative operators
  mulExpr ::= unaryExpr mulOp*                    → mulExpr ;
  mulOp ::= "*" unaryExpr                         → mulOp
          | "/" unaryExpr                         → divOp
          | "%" unaryExpr                         → modOp
          ;
  
  -- Unary operators
  unaryExpr ::= "-" unaryExpr                     → neg
              | "!" unaryExpr                     → not
              | "↑" unaryExpr                     → coeUp
              | appExpr                           → unaryExpr
              ;
  
  -- Application (juxtaposition, left-associative via iteration)
  -- Includes postfix operators like projections
  appExpr ::= primaryExpr postfixOp*              → appExpr ;
  postfixOp ::= "@" primaryExpr                   → explicitArg
              | primaryExpr                       → appArg
              | ".1"                              → fstOp
              | ".2"                              → sndOp
              | ".fst"                            → fstOp
              | ".snd"                            → sndOp
              | "." <ident>                       → projOp
              | "$" term                          → dollarOp
              | "|>" term                         → pipeRightOp
              | "<|" term                         → pipeLeftOp
              | "with" "{" fieldAssign* "}"       → structUpdateOp
              ;
  
  -- Primary expressions (no left recursion)
  primaryExpr ::= 
    -- Universes
    "Type" level?                                 → typeUniv
    | "Prop"                                      → propUniv
    | "Sort" level?                               → sortUniv
    -- Variables and literals
    | <ident>                                     → var
    | <number>                                    → numLit
    | <string>                                    → strLit
    | "true"                                      → trueLit
    | "false"                                     → falseLit
    | "()"                                        → unitLit
    | "Unit.unit"                                 → unitLit
    -- Lambda and function
    | "fun" binder+ "=>" term                     → lam
    | "λ" binder+ "=>" term                       → lamUnicode
    -- Pi/forall/sigma types
    | "∀" binder+ "," term                        → forallTy
    | "Π" binder+ "," term                        → piTy
    | "Σ" binder+ "," term                        → sigmaTy
    -- Let expressions
    | "let" <ident> typeAnn? ":=" term "in"? term → letExpr
    | "let" "rec" <ident> typeAnn? ":=" term "in"? term → letRecExpr
    -- Conditionals
    | "if" term "then" term "else" term           → ifExpr
    | "if" "let" pattern ":=" term "then" term "else" term → ifLetExpr
    -- Match
    | "match" termList "with" matchAlt*           → matchExpr
    -- Lists and arrays
    | "[" termList? "]"                           → listLit
    | "#[" termList? "]"                          → arrayLit
    -- Option
    | "none"                                      → noneLit
    | "some" primaryExpr                          → someLit
    | "Option" primaryExpr                        → optionTy
    -- Do notation
    | "do" doElem+                                → doBlock
    -- Tactics
    | "by" tactic+                                → byTactic
    -- Parenthesized expressions
    | "(" term ")"                                → paren
    | "(" term "," term ")"                       → pair
    -- Anonymous constructors
    | "⟨" termList "⟩"                            → anonCtor
    -- Structure literals
    | "{" fieldAssign* "}"                        → structLit
    -- Hole and sorry
    | "_"                                         → hole
    | "sorry"                                     → sorryTerm
    | "panic!" <string>                           → panic
    ;

  termList ::= term ("," term)*                   → termList ;
  level ::= <number>                              → levelLit
          | "max" level level                     → levelMax
          | "imax" level level                    → levelIMax
          | level "+" <number>                    → levelSucc
          ;

-----------------------------------------------------
-- Binders
-- Lambda/forall binders
-----------------------------------------------------
piece Binders
  binder ::= <ident>                              → simpleBinder
           | "(" <ident> ":" term ")"             → explicitBinder
           | "{" <ident> ":" term "}"             → implicitBinder
           | "[" <ident> ":" term "]"             → instBinder
           | "(" <ident> ")"                      → parenBinder
           ;
  typeAnn ::= ":" term                            → typeAnn ;

-----------------------------------------------------
-- Patterns
-- Match patterns
-----------------------------------------------------
piece Patterns
  pattern ::= <ident>                             → patVar
            | "_"                                 → patWild
            | <number>                            → patNum
            | <string>                            → patStr
            | "." <ident>                         → patCtor
            | <ident> pattern*                    → patApp
            | "(" patternList ")"                 → patTuple
            | "⟨" patternList "⟩"                 → patAnon
            | pattern "::" pattern                → patCons
            | pattern "+" <number>                → patSucc
            ;
  patternList ::= pattern ("," pattern)*          → patternList ;
  matchAlt ::= "|" patternList "=>" term          → matchAlt ;

-----------------------------------------------------
-- Do Notation
-- Monadic do blocks
-----------------------------------------------------
piece DoNotation
  doElem ::= "let" <ident> "←" term               → doLetBind
           | "let" <ident> ":=" term              → doLetPure
           | <ident> "←" term                     → doBind
           | "return" term                        → doReturn
           | "pure" term                          → doPure
           | "if" term "then" doElem+ "else"? doElem* → doIf
           | "for" <ident> "in" term "do" doElem+ → doFor
           | term                                 → doExpr
           ;

-----------------------------------------------------
-- Tactics
-- Proof tactics
-----------------------------------------------------
piece Tactics
  tactic ::= "rfl"                                → tacRfl
           | "sorry"                              → tacSorry
           | "trivial"                            → tacTrivial
           | "decide"                             → tacDecide
           | "assumption"                         → tacAssumption
           | "intro" <ident>*                     → tacIntro
           | "exact" term                         → tacExact
           | "apply" term                         → tacApply
           | "simp" simpArgs?                     → tacSimp
           | "cases" term                         → tacCases
           | "induction" term "with" inductAlt*  → tacInduction
           | "constructor"                        → tacConstructor
           | "rw" "[" rwRule* "]"                 → tacRewrite
           | <ident> term*                        → tacApp
           ;
  simpArgs ::= "[" term* "]"                      → simpArgs ;
  inductAlt ::= "|" <ident> <ident>* "=>" tactic+ → inductAlt ;
  rwRule ::= "←"? term                            → rwRule ;

-----------------------------------------------------
-- Declarations
-- Top-level declarations
-----------------------------------------------------
piece Declarations
  decl ::= 
    -- Inductive types
    "inductive" <ident> param* whereCtors? derivingClause? @nl
      → inductiveDecl
    -- Structures
    | "structure" <ident> param* extendsClause? "where" @nl @indent fieldDecl* @dedent derivingClause?
      → structureDecl
    -- Classes
    | "class" <ident> param* extendsClause? "where" @nl @indent fieldDecl* @dedent
      → classDecl
    -- Instances
    | "instance" instName? ":" term "where" @nl @indent fieldDef* @dedent
      → instanceDecl
    -- Definitions
    | "def" <ident> param* typeAnn? whereClause? ":=" term @nl
      → defDecl
    | "partial" "def" <ident> param* typeAnn? ":=" term @nl
      → partialDefDecl
    | "abbrev" <ident> param* typeAnn? ":=" term @nl
      → abbrevDecl
    -- Theorems
    | "theorem" <ident> param* ":" term ":=" term @nl
      → theoremDecl
    | "lemma" <ident> param* ":" term ":=" term @nl
      → lemmaDecl
    | "example" ":" term ":=" term @nl
      → exampleDecl
    -- Namespaces
    | "namespace" modulePath @nl @indent decl* @dedent "end" modulePath @nl
      → namespaceDecl
    | "section" <ident>? @nl @indent decl* @dedent "end" <ident>? @nl
      → sectionDecl
    -- Imports and opens  
    | "import" modulePath @nl
      → importDecl
    | "open" modulePath inClause? @nl
      → openDecl
    -- Variables
    | "variable" varDecl+ @nl
      → variableDecl
    -- Attributes
    | "attribute" "[" <ident> "]" <ident> @nl
      → attributeDecl
    -- Set options
    | "set_option" modulePath term @nl
      → setOptionDecl
    -- Notation and macros
    | "macro" <ident> param* ":" <ident> ":=" term @nl
      → macroDecl
    | "notation" <string> ":=" term @nl
      → notationDecl
    | "syntax" term* ":" <ident> @nl
      → syntaxDecl
    -- Private/protected modifiers
    | "private" decl
      → privateDecl
    | "protected" decl
      → protectedDecl
    -- @[simp] style attributes
    | "@[" <ident> "]" decl
      → attrDecl
    -- #check, #eval, #print commands
    | "#check" term @nl
      → checkCmd
    | "#eval" term @nl
      → evalCmd
    | "#print" <ident> @nl
      → printCmd
    ;

  param ::= <ident>                               → simpleParam
          | "(" @nsp <ident> ":" term ")" @sp     → explicitParam
          | "{" @nsp <ident> ":" term "}" @sp     → implicitParam
          | "[" @nsp <ident> ":" term "]" @sp     → instParam
          ;
  whereCtors ::= "where" @nl @indent ctor* @dedent → whereCtors ;
  ctor ::= "|" <ident> param* ":" term @nl        → ctor ;
  derivingClause ::= "deriving" <ident> ("," <ident>)* → derivingClause ;
  fieldDecl ::= <ident> ":" term defaultVal?      → fieldDecl ;
  fieldDef ::= <ident> ":=" term                  → fieldDef ;
  fieldAssign ::= <ident> ":=" term               → fieldAssign ;
  defaultVal ::= ":=" term                        → defaultVal ;
  extendsClause ::= "extends" term                → extendsClause ;
  instName ::= <ident>                            → instName ;
  modulePath ::= <ident> ("." <ident>)*           → modulePath ;
  inClause ::= "in" term                          → inClause ;
  varDecl ::= "(" <ident> ":" term ")"            → explicitVarDecl
            | "{" <ident> ":" term "}"            → implicitVarDecl
            ;
  whereClause ::= "where" letDecl*                → whereClause ;
  letDecl ::= <ident> ":=" term                   → letDecl ;

-----------------------------------------------------
-- Module
-- Top-level module structure
-----------------------------------------------------
piece Module
  module ::= decl*                                → module ;

-----------------------------------------------------
-- Tests
-- Syntax validation examples
-----------------------------------------------------
test "lam": (lam (explicitBinder x Nat) (add (var x) (numLit 1))) ;
test "forall": (forallTy (explicitBinder x Type) (arrowTy (var x) (var x))) ;
test "inductive": (inductiveDecl Term (whereCtors (ctor Var (explicitParam x Nat) (var Term)))) ;
test "def": (defDecl id (explicitParam A Type) (explicitParam x (var A)) (typeAnn (var A)) (var x)) ;
test "match": (matchExpr (termList (var x)) (matchAlt (patVar n) (add (var n) (numLit 1)))) ;

