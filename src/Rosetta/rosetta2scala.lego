-----------------------------------------------------
-- rosetta2scala.lego: Transform Rosetta AST to Scala AST
--
-- Rosetta is the portable IR; Scala.lego defines Scala 3 syntax.
-- This file bridges them with rewrite rules.
--
-- Usage: 
--   1. Parse .rosetta file with Rosetta.lego grammar
--   2. Apply these rules to transform AST
--   3. Print with Scala.lego grammar
-----------------------------------------------------

lang RosettaToScala :=

-----------------------------------------------------
-- Import declarations
-- Rosetta: (DImport "import" (modulePath ...) ";")
-- Scala: (decl (importDecl (importPath (modulePath ...))))
-----------------------------------------------------
piece ImportTransformScala
  rule importToScala: (DImport "import" $path ";")
    ~~> (decl (importDecl (importPath $path))) ;

-----------------------------------------------------
-- ADT to Enum
-- Rosetta AST structure from parser:
--   (adtDef "adt" Name (unit|typeParams) "{" constr1 (seq "," constr2)... "}")
--
-- Scala target AST:
--   (decl (enumDecl Name (enumCases enumCase1 enumCase2...)))
-- Based on Scala grammar: decl ::= annotation* declBody
--   where declBody ::= ... | enumDecl
--   and enumCases wraps the enum cases
-- 
-- Grammar: visibility* "enum" <ident> typeParamList? extendsClause? enumCases
-----------------------------------------------------
piece AdtToEnum
  -- Variadic ADT transformation using @map
  rule adtToEnum: (adtDef "adt" $name (unit) "{" $constrs... "}")
    ~~> (decl (enumDecl $name (enumCases @map transformConstrScala $constrs...))) ;
  
  -- Helper to normalize seq wrappers from comma-separated constructors
  rule normalizeSeqScala: (transformConstrScala (seq "," $c))
    ~~> (transformConstrScala $c) ;

-----------------------------------------------------
-- Constructor transformation
-- Rosetta: (constr Name ":" Type)
-- Scala grammar: enumCase ::= "case" <ident> "(" paramList ")" | "case" <ident>
-- For simple types, use enumCaseSimple. For function types, use enumCaseParams.
--
-- Actual AST from Rosetta parser:
--   Simple: (typeExpr (typeApp GrammarExpr))
--   One arrow: (typeExpr (typeApp A) "->" (typeExpr (typeApp B)) (unit))
--   Two arrows: (typeExpr (typeApp A) "->" (typeExpr (typeApp B) "->" (typeExpr (typeApp C)) (unit)) (unit))
--   Note: The trailing (unit) comes from the optional (typeArrow type)? in the grammar
-----------------------------------------------------
piece ConstrTransformScala
  -- Constructor with simple type (no args) -> enumCaseSimple
  -- Pattern: (constr Name ":" (typeExpr (typeApp ReturnType)))
  rule transformConstrScalaSimple: (transformConstrScala (constr $name ":" (typeExpr (typeApp $type))))
    ~~> (enumCaseSimple $name) ;
  
  -- Constructor with ONE arrow: A -> Result (with trailing unit)
  -- Pattern: (typeExpr (typeApp A) "->" (typeExpr (typeApp Result)) (unit))
  -- Use string literals for param names since they need to print as identifiers
  -- Wrap types in full chain: type -> unionTy -> intersectTy -> funTy -> tyVar
  rule transformConstrScalaOneArg: (transformConstrScala (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $ret)) (unit))))
    ~~> (enumCaseParams $name (paramList (param "arg1" (type (unionTy (intersectTy (funTy (tyVar $a)))))))) ;

  -- Constructor with ONE arrow where arg is type application: List Term -> Result (with trailing unit)
  rule transformConstrScalaOneArgApp: (transformConstrScala (constr $name ":" (typeExpr (typeApp $a $aArg) "->" (typeExpr (typeApp $ret)) (unit))))
    ~~> (enumCaseParams $name (paramList (param "arg1" (type (unionTy (intersectTy (funTy (tyApp $a (typeList (type (unionTy (intersectTy (funTy (tyVar $aArg)))))))))))))) ;
  
  -- Constructor with TWO arrows: A -> B -> Result (with nested units)
  -- Pattern: (typeExpr (typeApp A) "->" (typeExpr (typeApp B) "->" (typeExpr (typeApp C)) (unit)) (unit))
  rule transformConstrScalaTwoArgs: (transformConstrScala (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $b) "->" (typeExpr (typeApp $ret)) (unit)) (unit))))
    ~~> (enumCaseParams $name (paramList (param "arg1" (type (unionTy (intersectTy (funTy (tyVar $a)))))) (param "arg2" (type (unionTy (intersectTy (funTy (tyVar $b)))))))) ;

  -- Constructor with TWO arrows, second arg is type app: A -> List B -> Result (with nested units)
  rule transformConstrScalaTwoArgsSecondApp: (transformConstrScala (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $b $bArg) "->" (typeExpr (typeApp $ret)) (unit)) (unit))))
    ~~> (enumCaseParams $name (paramList (param "arg1" (type (unionTy (intersectTy (funTy (tyVar $a)))))) (param "arg2" (type (unionTy (intersectTy (funTy (tyApp $b (typeList (type (unionTy (intersectTy (funTy (tyVar $bArg)))))))))))))) ;
  
  -- Constructor with THREE arrows: A -> B -> C -> Result (with nested units)
  rule transformConstrScalaThreeArgs: (transformConstrScala (constr $name ":" (typeExpr (typeApp $a) "->" (typeExpr (typeApp $b) "->" (typeExpr (typeApp $c) "->" (typeExpr (typeApp $ret)) (unit)) (unit)) (unit))))
    ~~> (enumCaseParams $name (paramList (param "arg1" (type (unionTy (intersectTy (funTy (tyVar $a)))))) (param "arg2" (type (unionTy (intersectTy (funTy (tyVar $b)))))) (param "arg3" (type (unionTy (intersectTy (funTy (tyVar $c)))))))) ;

  -- Direct pass through (fallback)
  rule transformConstrScalaDirect: (constr $name ":" $type)
    ~~> (enumCaseParams $name (paramList)) ;

-----------------------------------------------------
-- Type wrapping for Scala's grammar (for other contexts)
-----------------------------------------------------
piece TypeWrapScala
  rule wrapTypeScalaApp: (wrapTypeScala (typeExpr (typeApp $name)))
    ~~> (tyVar $name) ;
  
  rule wrapTypeScalaSimple: (wrapTypeScala (typeApp $name))
    ~~> (tyVar $name) ;

  rule wrapTypeScalaAppTwo: (wrapTypeScala (typeExpr (typeApp $name $arg)))
    ~~> (tyApp (tyVar $name) (typeList (tyVar $arg))) ;

  rule wrapTypeScalaExpr: (wrapTypeScala (typeExpr $inner $rest))
    ~~> (tyVar $inner) ;

-----------------------------------------------------
-- Rewrite Rule transformation
-- Rosetta: (rewriteRule "rewrite" name ":" lhs "~>" rhs ";")
-- Scala: def name(x: T): T = x match { case pattern => rhs }
--
-- Rosetta compound AST: (compound "(" f arg1 arg2... ")")
-- Note: Types must be fully wrapped: type -> unionTy -> intersectTy -> funTy -> tyVar
-- Note: Terms must be fully wrapped: term -> orExpr -> andExpr -> cmpExpr -> addExpr -> mulExpr -> unaryExpr -> postfixExpr
-----------------------------------------------------
piece RewriteTransformScala
  -- Simple rewrite: (fname (Ctor $vars...)) ~> body
  rule rewriteToDefScala: (rewriteRule "rewrite" $name ":" (compound "(" $fname $arg ")") "~>" $rhs ";")
    ~~> (decl (defDecl $name (paramList (param "x" (type (unionTy (intersectTy (funTy (tyVar "Term"))))))) (type (unionTy (intersectTy (funTy (tyVar "Term"))))) 
              (term (orExpr (andExpr (cmpExpr (addExpr (mulExpr (unaryExpr (postfixExpr (appExpr (var "x")) (matchOp (caseClause (transformPatternScala $arg) (transformTermScala $rhs))))))))))))) ;

  -- Fallback: produce a comment
  rule rewriteToCommentScala: (rewriteRule "rewrite" $name ":" $lhs "~>" $rhs ";")
    ~~> (decl (lineComment "//" "rewrite" $name)) ;

-----------------------------------------------------
-- Pattern transformation (Rosetta patterns to Scala patterns)
-- Scala grammar: pattern → patVar | patCtor | ...
-- patCtor ::= <ident> "(" patternList ")" → patCtor
-- patternList ::= pattern ("," pattern)* → patternList
-----------------------------------------------------
piece PatternTransformScala
  -- Metavariable: (metavar "$" x) becomes patVar x
  rule transformPatternScalaMeta: (transformPatternScala (metavar "$" $x))
    ~~> (patVar $x) ;

  -- Constructor pattern: (compound "(" Ctor args... ")") becomes patCtor with patternList
  rule transformPatternScalaCtor: (transformPatternScala (compound "(" $ctor $args... ")"))
    ~~> (patCtor $ctor (patternList @map transformPatternScala $args...)) ;

  -- Simple identifier (like Nil)
  rule transformPatternScalaIdent: (transformPatternScala $x)
    ~~> (patVar $x) ;

-----------------------------------------------------
-- Term transformation (Rosetta terms to Scala terms)
-- Note: Terms must be fully wrapped: term -> orExpr -> andExpr -> cmpExpr -> addExpr -> mulExpr -> unaryExpr -> postfixExpr -> appExpr
-- Note: appArg expects termList inside: appArg ::= "(" termList? ")" → appArg
-----------------------------------------------------
piece TermTransformScala
  -- Metavariable: (metavar "$" x) becomes var x wrapped in full term chain
  rule transformTermScalaMeta: (transformTermScala (metavar "$" $x))
    ~~> (term (orExpr (andExpr (cmpExpr (addExpr (mulExpr (unaryExpr (postfixExpr (appExpr (var $x)))))))))) ;

  -- Constructor/Application: (compound "(" f args... ")")
  rule transformTermScalaApp: (transformTermScala (compound "(" $f $args... ")"))
    ~~> (term (orExpr (andExpr (cmpExpr (addExpr (mulExpr (unaryExpr (postfixExpr (appExpr (var $f) @map transformTermArgScala $args...))))))))) ;
  
  -- appArg needs termList inside: (appArg (termList (term ...)))
  rule transformTermArgScalaMeta: (transformTermArgScala (metavar "$" $x))
    ~~> (appArg (termList (term (orExpr (andExpr (cmpExpr (addExpr (mulExpr (unaryExpr (postfixExpr (appExpr (var $x)))))))))))) ;
  
  rule transformTermArgScalaCompound: (transformTermArgScala (compound "(" $inner... ")"))
    ~~> (appArg (termList (transformTermScala (compound "(" $inner... ")")))) ;
  
  rule transformTermArgScalaIdent: (transformTermArgScala $x)
    ~~> (appArg (termList (term (orExpr (andExpr (cmpExpr (addExpr (mulExpr (unaryExpr (postfixExpr (appExpr (var $x)))))))))))) ;

  -- Simple identifier
  rule transformTermScalaIdent: (transformTermScala $x)
    ~~> (term (orExpr (andExpr (cmpExpr (addExpr (mulExpr (unaryExpr (postfixExpr (appExpr (var $x)))))))))) ;

