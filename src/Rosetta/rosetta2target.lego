-----------------------------------------------------
-- rosetta2target.lego: Unified Multi-Target Transformer
--
-- Consolidates rosetta2lean, rosetta2rust, rosetta2haskell, rosetta2scala.
-- Uses original function names: toLean, toRust, toHaskell, toScala
--
-- Pipeline: Rosetta IR → rosetta2target → Target Code
-----------------------------------------------------
import Rosetta
import Lean
import Haskell
import Rust

lang RosettaToTarget :=

-----------------------------------------------------
-- CoreTransform: Univ, Var, App, Subst
-----------------------------------------------------
piece CoreTransform
  rule univToLean: (toLean Univ) ~~> (typeUniv) ;
  rule univToRust: (toRust Univ) ~~> (unitTy) ;
  rule univToHaskell: (toHaskell Univ) ~~> (tyVar Type) ;
  rule univToScala: (toScala Univ) ~~> (tyAny) ;
  
  rule varToLean: (toLean (Var $x)) ~~> (var $x) ;
  rule varToRust: (toRust (Var $x)) ~~> (var $x) ;
  rule varToHaskell: (toHaskell (Var $x)) ~~> (var $x) ;
  rule varToScala: (toScala (Var $x)) ~~> (var $x) ;
  
  rule appToLean: (toLean (App $f $a)) ~~> (app (toLean $f) (toLean $a)) ;
  rule appToRust: (toRust (App $f $a)) ~~> (app (toRust $f) (toRust $a)) ;
  rule appToHaskell: (toHaskell (App $f $a)) ~~> (app (toHaskell $f) (toHaskell $a)) ;
  rule appToScala: (toScala (App $f $a)) ~~> (app (toScala $f) (toScala $a)) ;
  
  rule substToLean: (toLean (Subst $x $s $body)) ~~>
    (letExpr $x (toLean $s) (toLean $body)) ;
  rule substToRust: (toRust (Subst $x $s $body)) ~~>
    (block (stmtList (stmtLet (patIdent $x) (toRust $s)) (toRust $body))) ;
  rule substToHaskell: (toHaskell (Subst $x $s $body)) ~~>
    (letExpr $x (toHaskell $s) (toHaskell $body)) ;
  rule substToScala: (toScala (Subst $x $s $body)) ~~>
    (letExpr $x (toScala $s) (toScala $body)) ;

-----------------------------------------------------
-- BinderTransform: Lam, Pi, Arrow
-----------------------------------------------------
piece BinderTransform
  rule lamToLean: (toLean (Lam $x . $body)) ~~>
    (lam (simpleBinder $x) (toLean $body)) ;
  rule lamToRust: (toRust (Lam $x . $body)) ~~>
    (closure (paramList (param $x (refTy (tyInfer)))) (toRust $body)) ;
  rule lamToHaskell: (toHaskell (Lam $x . $body)) ~~>
    (lam (patVar $x) (toHaskell $body)) ;
  rule lamToScala: (toScala (Lam $x . $body)) ~~>
    (lamSimple $x (toScala $body)) ;
  
  rule lamTypedToLean: (toLean (Lam ($x : $A) . $body)) ~~>
    (lam (explicitBinder $x (toLean $A)) (toLean $body)) ;
  rule lamTypedToRust: (toRust (Lam ($x : $A) . $body)) ~~>
    (closure (paramList (param $x (refTy (toRustType $A)))) (toRust $body)) ;
  rule lamTypedToHaskell: (toHaskell (Lam ($x : $A) . $body)) ~~>
    (lam (patVar $x) (toHaskell $body)) ;
  rule lamTypedToScala: (toScala (Lam ($x : $A) . $body)) ~~>
    (lam (paramList (param $x (toScalaType $A))) (toScala $body)) ;
  
  rule piToLean: (toLean (Pi ($x : $A) $B)) ~~>
    (forallTy (explicitBinder $x (toLean $A)) (toLean $B)) ;
  rule piToRust: (toRust (Pi ($x : $A) $B)) ~~>
    (tyFn (typeList (toRustType $A)) (toRustType $B)) ;
  rule piToHaskell: (toHaskell (Pi ($x : $A) $B)) ~~>
    (tyFun (toHaskellType $A) (toHaskellType $B)) ;
  rule piToScala: (toScala (Pi ($x : $A) $B)) ~~>
    (tyFun (toScalaType $A) (toScalaType $B)) ;
  
  rule arrowToLean: (toLean (Arrow $A $B)) ~~>
    (arrowTy (toLean $A) (toLean $B)) ;
  rule arrowToRust: (toRust (Arrow $A $B)) ~~>
    (tyFn (typeList (toRustType $A)) (toRustType $B)) ;
  rule arrowToHaskell: (toHaskell (Arrow $A $B)) ~~>
    (tyFun (toHaskellType $A) (toHaskellType $B)) ;
  rule arrowToScala: (toScala (Arrow $A $B)) ~~>
    (tyFun (toScalaType $A) (toScalaType $B)) ;

-----------------------------------------------------
-- ProductTransform: Pair, Fst, Snd, Prod
-----------------------------------------------------
piece ProductTransform
  rule pairToLean: (toLean (Pair $a $b)) ~~> (pair (toLean $a) (toLean $b)) ;
  rule pairToRust: (toRust (Pair $a $b)) ~~>
    (tuple (exprList (toRust $a) (toRust $b))) ;
  rule pairToHaskell: (toHaskell (Pair $a $b)) ~~>
    (tuple (exprList (toHaskell $a) (toHaskell $b))) ;
  rule pairToScala: (toScala (Pair $a $b)) ~~>
    (tuple (termList (toScala $a) (toScala $b))) ;
  
  rule fstToLean: (toLean (Fst $p)) ~~> (fst (toLean $p)) ;
  rule fstToRust: (toRust (Fst $p)) ~~> (tupleAccess (toRust $p) 0) ;
  rule fstToHaskell: (toHaskell (Fst $p)) ~~> (app (var fst) (toHaskell $p)) ;
  rule fstToScala: (toScala (Fst $p)) ~~> (fst (toScala $p)) ;
  
  rule sndToLean: (toLean (Snd $p)) ~~> (snd (toLean $p)) ;
  rule sndToRust: (toRust (Snd $p)) ~~> (tupleAccess (toRust $p) 1) ;
  rule sndToHaskell: (toHaskell (Snd $p)) ~~> (app (var snd) (toHaskell $p)) ;
  rule sndToScala: (toScala (Snd $p)) ~~> (snd (toScala $p)) ;
  
  rule prodToLean: (toLean (Prod $A $B)) ~~>
    (prodTy (toLean $A) (toLean $B)) ;
  rule prodToRust: (toRust (Prod $A $B)) ~~>
    (tyTuple (typeList (toRustType $A) (toRustType $B))) ;
  rule prodToHaskell: (toHaskell (Prod $A $B)) ~~>
    (tyTuple (typeList (toHaskellType $A) (toHaskellType $B))) ;
  rule prodToScala: (toScala (Prod $A $B)) ~~>
    (tyTuple (typeList (toScalaType $A) (toScalaType $B))) ;

-----------------------------------------------------
-- FileTransform: (seq ...) entry point
-----------------------------------------------------
piece FileTransform
  @file rule fileToLean: (toLean (seq $decls)) ~~>
    (leanModule (toLeanDecls $decls)) ;
  rule declsToLean: (toLeanDecls ($decl $rest)) ~~>
    ((toLeanDecl $decl) (toLeanDecls $rest)) ;
  rule declsToLeanSingle: (toLeanDecls $decl) ~~> (toLeanDecl $decl) ;
  @decl rule declAdtToLean: (toLeanDecl (adtDef $kw $name $lb $constrs $rb)) ~~>
    (toLean (adtDef $kw $name $lb $constrs $rb)) ;
  
  @file rule fileToRust: (toRust (seq $decls)) ~~>
    (rustFile (toRustItems $decls)) ;
  rule itemsToRust: (toRustItems ($d $rest)) ~~> ((toRust $d) (toRustItems $rest)) ;
  rule itemsToRustNil: (toRustItems ()) ~~> () ;
  
  @file rule fileToHaskell: (toHaskell (seq $decls)) ~~>
    (hsModule (toHaskellDecls $decls)) ;
  rule declsToHaskell: (toHaskellDecls ($d $rest)) ~~>
    ((toHaskell $d) (toHaskellDecls $rest)) ;
  rule declsToHaskellNil: (toHaskellDecls ()) ~~> () ;
  
  @file rule fileToScala: (toScala (seq $decls)) ~~>
    (scalaFile (toScalaDecls $decls)) ;
  rule declsToScala: (toScalaDecls ($d $rest)) ~~>
    ((toScala $d) (toScalaDecls $rest)) ;
  rule declsToScalaNil: (toScalaDecls ()) ~~> () ;

-----------------------------------------------------
-- ADTTransform: adtDef
-----------------------------------------------------
piece ADTTransform
  -- Lean: inductive
  rule adtToLean: (toLean (adtDef $kw $name $lb $constrs $rb)) ~~>
    (inductiveDecl $name (whereCtors (toLeanCtors $constrs))) ;
  rule ctorsSeqLean: (toLeanCtors (seq "," $next)) ~~> (toLeanCtors $next) ;
  rule ctorsFirstLean: (toLeanCtors ((constr $name ":" $ty) $rest)) ~~>
    ((ctor $name (toLeanType $ty)) (toLeanCtors $rest)) ;
  rule ctorsSingleLean: (toLeanCtors (constr $name ":" $ty)) ~~>
    (ctor $name (toLeanType $ty)) ;
  rule ctorsNilLean: (toLeanCtors ()) ~~> () ;
  rule typeExprArrowLean: (toLeanType (typeExpr $left -> $right)) ~~>
    (arrowTy (toLeanType $left) (toLeanType $right)) ;
  rule typeExprBaseLean: (toLeanType (typeExpr $t)) ~~> (toLeanType $t) ;
  rule typeAppMultiLean: (toLeanType (typeApp $t $args)) ~~>
    (app (toLeanType $t) (toLeanType $args)) ;
  rule typeAppSingleLean: (toLeanType (typeApp $t)) ~~> (var $t) ;
  rule typeIdentLean: (toLeanType $t) ~~> (var $t) ;
  
  -- Rust: enum
  rule adtToRust: (toRust (adtDef $name { $constrs })) ~~>
    (enumItem (pubVis) $name (toRustVariants $constrs)) ;
  rule variantsToRust: (toRustVariants ($c $rest)) ~~>
    ((toRustVariant $c) (toRustVariants $rest)) ;
  rule variantsToRustNil: (toRustVariants ()) ~~> () ;
  rule variantUnitToRust: (toRustVariant ($name : $ty)) ~~>
    (enumVariantUnit $name) when (isBaseType $ty) ;
  rule variantTupleToRust: (toRustVariant ($name : $ty)) ~~>
    (enumVariantTuple $name (toRustTupleFields $ty)) ;
  rule tupleFieldsArrow: (toRustTupleFields (Arrow $A $B)) ~~>
    ((tupleField (toRustType $A)) (toRustTupleFields $B)) ;
  rule tupleFieldsBase: (toRustTupleFields $T) ~~> () ;
  
  -- Haskell: data
  rule adtToHaskell: (toHaskell (adtDef $name { $constrs })) ~~>
    (dataDecl $name (toHaskellDataCons $constrs)) ;
  rule dataconsToHaskell: (toHaskellDataCons ($c $rest)) ~~>
    ((toHaskellDataCon $c) (toHaskellDataCons $rest)) ;
  rule dataconsToHaskellNil: (toHaskellDataCons ()) ~~> () ;
  rule dataconToHaskell: (toHaskellDataCon ($name : $ty)) ~~>
    (dataCon $name (toHaskellConTypes $ty)) ;
  rule conTypesArrow: (toHaskellConTypes (Arrow $A $B)) ~~>
    ((toHaskellType $A) (toHaskellConTypes $B)) ;
  rule conTypesBase: (toHaskellConTypes $T) ~~> () ;
  
  -- Scala: enum
  rule adtToScala: (toScala (adtDef $name { $constrs })) ~~>
    (enumDecl $name (toScalaCases $constrs)) ;
  rule casesToScala: (toScalaCases ($c $rest)) ~~>
    ((toScalaCase $c) (toScalaCases $rest)) ;
  rule casesToScalaNil: (toScalaCases ()) ~~> () ;
  rule caseSimpleToScala: (toScalaCase ($name : $ty)) ~~>
    (enumCaseSimple $name) when (isBaseType $ty) ;
  rule caseParamsToScala: (toScalaCase ($name : $ty)) ~~>
    (enumCaseParams $name (toScalaParams $ty)) ;
  rule paramsArrow: (toScalaParams (Arrow $A $B)) ~~>
    (paramList (param arg (toScalaType $A)) (toScalaParams $B)) ;
  rule paramsBase: (toScalaParams $T) ~~> (paramList) ;

-----------------------------------------------------
-- RewriteTransform: rewriteRule
-----------------------------------------------------
piece RewriteTransform
  rule rewriteToLean: (toLean (rewriteRule $name ":" $pat ~~> $repl)) ~~>
    (defDecl $name (explicitParam t Term) (typeAnn (var Term))
      (matchExpr (termList (var t))
        (matchAlt (toLeanPat $pat) (toLean $repl))
        (matchAlt (patWild) (var t)))) ;
  rule patVarToLean: (toLeanPat (Var $x)) ~~> (patVar $x) ;
  rule patAppToLean: (toLeanPat ($f $args)) ~~> (patApp $f (toLeanPats $args)) ;
  rule patWildToLean: (toLeanPat _) ~~> (patWild) ;
  rule patsToLean: (toLeanPats ($p $rest)) ~~> ((toLeanPat $p) (toLeanPats $rest)) ;
  rule patsToLeanNil: (toLeanPats ()) ~~> () ;
  
  rule rewriteToRust: (toRust (rewriteRule $name ":" $pat ~~> $repl)) ~~>
    (fnItem (pubVis) $name
      (paramList (param t (refTy (tyPath Term))))
      (returnType (tyPath Term))
      (block (stmtList
        (matchExpr (var t)
          (matchArm (toRustPat $pat) (toRust $repl))
          (matchArm (patIdent t) (call (var t) (exprList clone))))))) ;
  rule patVarToRust: (toRustPat (Var $x)) ~~> (patIdent $x) ;
  rule patCtorToRust: (toRustPat ($f $args)) ~~> (patTupleStruct $f (toRustPats $args)) ;
  rule patWildToRust: (toRustPat _) ~~> (patWild) ;
  rule patsToRust: (toRustPats ($p $rest)) ~~> (patternList (toRustPat $p) (toRustPats $rest)) ;
  rule patsToRustNil: (toRustPats ()) ~~> (patternList) ;
  
  rule rewriteToHaskell: (toHaskell (rewriteRule $name ":" $pat ~~> $repl)) ~~>
    (funDecl $name (patVar t)
      (caseExpr (var t)
        (caseAlt (toHaskellPat $pat) (toHaskell $repl))
        (caseAlt (patWild) (var t)))) ;
  rule patVarToHaskell: (toHaskellPat (Var $x)) ~~> (patVar $x) ;
  rule patCtorToHaskell: (toHaskellPat ($f $args)) ~~> (patCtor $f (toHaskellPats $args)) ;
  rule patWildToHaskell: (toHaskellPat _) ~~> (patWild) ;
  rule patsToHaskell: (toHaskellPats ($p $rest)) ~~> ((toHaskellPat $p) (toHaskellPats $rest)) ;
  rule patsToHaskellNil: (toHaskellPats ()) ~~> () ;
  
  rule rewriteToScala: (toScala (rewriteRule $name ":" $pat ~~> $repl)) ~~>
    (defDecl $name (paramList (param t (tyVar Term))) (tyVar Term)
      (matchExpr (var t)
        (caseClause (toScalaPat $pat) (toScala $repl))
        (caseClause (patWild) (var t)))) ;
  rule patVarToScala: (toScalaPat (Var $x)) ~~> (patVar $x) ;
  rule patCtorToScala: (toScalaPat ($f $args)) ~~> (patCtor $f (toScalaPats $args)) ;
  rule patWildToScala: (toScalaPat _) ~~> (patWild) ;
  rule patsToScala: (toScalaPats ($p $rest)) ~~> (patternList (toScalaPat $p) (toScalaPats $rest)) ;
  rule patsToScalaNil: (toScalaPats ()) ~~> (patternList) ;

-----------------------------------------------------
-- JudgmentTransform: typeDecl
-----------------------------------------------------
piece JudgmentTransform
  rule typeToLean: (toLean (typeDecl $name ":" $term ":" $ty when $conds)) ~~>
    (theoremDecl $name (toLeanParams $conds)
      (app (app (var HasType) (toLean $term)) (toLean $ty))
      (byTactic (tacSorry))) ;
  rule typeSimpleToLean: (toLean (typeDecl $name ":" $term ":" $ty)) ~~>
    (theoremDecl $name (app (app (var HasType) (toLean $term)) (toLean $ty))
      (byTactic (tacSorry))) ;
  rule condsToParams: (toLeanParams (($t : $T) $rest)) ~~>
    ((implicitParam h (app (app (var HasType) (toLean $t)) (toLean $T)))
     (toLeanParams $rest)) ;
  rule condsToParamsNil: (toLeanParams ()) ~~> () ;
  
  rule typeToRust: (toRust (typeDecl $name ":" $term ":" $ty when $conds)) ~~>
    (fnItem (pubVis) $name (toRustCondParams $conds)
      (returnType (tyPath bool))
      (block (stmtList (macroCall todo (exprList))))) ;
  rule condParamsToRust: (toRustCondParams (($t : $T) $rest)) ~~>
    (paramList (param evidence (tyPath HasType)) (toRustCondParams $rest)) ;
  rule condParamsToRustNil: (toRustCondParams ()) ~~> (paramList) ;
  
  rule typeToHaskell: (toHaskell (typeDecl $name ":" $term ":" $ty when $conds)) ~~>
    ((typeSigDecl $name (toHaskellJudgmentType $conds $term $ty))
     (funDecl $name (undefinedExpr))) ;
  rule judgmentTypeToHaskell: (toHaskellJudgmentType (($t : $T) $rest) $term $ty) ~~>
    (tyFun (toHaskellType $T) (toHaskellJudgmentType $rest $term $ty)) ;
  rule judgmentTypeBaseToHaskell: (toHaskellJudgmentType () $term $ty) ~~>
    (toHaskellType $ty) ;
  
  rule typeToScala: (toScala (typeDecl $name ":" $term ":" $ty when $conds)) ~~>
    (defDecl $name (toScalaCondParams $conds) (tyVar Boolean) (trueLit)) ;
  rule condParamsToScala: (toScalaCondParams (($t : $T) $rest)) ~~>
    (paramList (param evidence (tyVar HasType)) (toScalaCondParams $rest)) ;
  rule condParamsToScalaNil: (toScalaCondParams ()) ~~> (paramList) ;

-----------------------------------------------------
-- TestTransform: testDecl
-----------------------------------------------------
piece TestTransform
  rule testToLean: (toLean (testDecl $name ":" $lhs ~~> $rhs)) ~~>
    (exampleDecl (beq (toLean $lhs) (toLean $rhs)) (byTactic (tacRfl))) ;
  
  rule testToRust: (toRust (testDecl $name ":" $lhs ~~> $rhs)) ~~>
    (fnItem $name (paramList) (block (stmtList
      (macroCall assert_eq (exprList (toRust $lhs) (toRust $rhs)))))) ;
  
  rule testToHaskell: (toHaskell (testDecl $name ":" $lhs ~~> $rhs)) ~~>
    (funDecl $name (app (app (var assertEqual) (strLit $name))
      (app (app (var eq) (toHaskell $lhs)) (toHaskell $rhs)))) ;
  
  rule testToScala: (toScala (testDecl $name ":" $lhs ~~> $rhs)) ~~>
    (defDecl $name (paramList) (tyUnit)
      (methodCall (var assert) (termList (eq (toScala $lhs) (toScala $rhs))))) ;

-----------------------------------------------------
-- ModuleTransform: moduleDecl, importDecl
-----------------------------------------------------
piece ModuleTransform
  rule moduleToLean: (toLean (moduleDecl $name { $decls })) ~~>
    (namespaceDecl $name (toLeanDecls $decls) $name) ;
  rule importToLean: (toLean (importDecl $name)) ~~>
    (importDecl (modulePath $name)) ;
  rule modDeclsToLean: (toLeanDecls ($d $rest)) ~~> ((toLean $d) (toLeanDecls $rest)) ;
  rule modDeclsToLeanNil: (toLeanDecls ()) ~~> () ;
  
  rule moduleToRust: (toRust (moduleDecl $name { $decls })) ~~>
    (modDefItem (pubVis) $name (toRustItems $decls)) ;
  rule importToRust: (toRust (importDecl $name)) ~~> (useItem (usePath $name)) ;
  
  rule moduleToHaskell: (toHaskell (moduleDecl $name { $decls })) ~~>
    ((moduleDecl (modulePath $name)) (toHaskellDecls $decls)) ;
  rule importToHaskell: (toHaskell (importDecl $name)) ~~>
    (importDecl (modulePath $name)) ;
  
  rule moduleToScala: (toScala (moduleDecl $name { $decls })) ~~>
    (objectDecl $name (toScalaDecls $decls)) ;
  rule importToScala: (toScala (importDecl $name)) ~~>
    (importDecl (modulePath $name) (importAll)) ;

-----------------------------------------------------
-- BuiltinTransform: Bool, Nat, if, true, false
-----------------------------------------------------
piece BuiltinTransform
  rule boolTyToLean: (toLean Bool) ~~> (var Bool) ;
  rule boolTyToRust: (toRustType Bool) ~~> (tyPath bool) ;
  rule boolTyToHaskell: (toHaskellType Bool) ~~> (tyVar Bool) ;
  rule boolTyToScala: (toScalaType Bool) ~~> (tyVar Boolean) ;
  
  rule trueToLean: (toLean true) ~~> (trueLit) ;
  rule trueToRust: (toRust true) ~~> (trueLit) ;
  rule trueToHaskell: (toHaskell true) ~~> (trueLit) ;
  rule trueToScala: (toScala true) ~~> (trueLit) ;
  rule falseToLean: (toLean false) ~~> (falseLit) ;
  rule falseToRust: (toRust false) ~~> (falseLit) ;
  rule falseToHaskell: (toHaskell false) ~~> (falseLit) ;
  rule falseToScala: (toScala false) ~~> (falseLit) ;
  
  rule natTyToLean: (toLean Nat) ~~> (var Nat) ;
  rule natTyToRust: (toRustType Nat) ~~> (tyPath u64) ;
  rule natTyToHaskell: (toHaskellType Nat) ~~> (tyVar Int) ;
  rule natTyToScala: (toScalaType Nat) ~~> (tyVar Int) ;
  
  rule zeroToLean: (toLean zero) ~~> (numLit 0) ;
  rule zeroToRust: (toRust zero) ~~> (intLit 0) ;
  rule zeroToHaskell: (toHaskell zero) ~~> (intLit 0) ;
  rule zeroToScala: (toScala zero) ~~> (intLit 0) ;
  
  rule succToLean: (toLean (succ $n)) ~~> (add (toLean $n) (numLit 1)) ;
  rule succToRust: (toRust (succ $n)) ~~> (add (toRust $n) (intLit 1)) ;
  rule succToHaskell: (toHaskell (succ $n)) ~~> (add (toHaskell $n) (intLit 1)) ;
  rule succToScala: (toScala (succ $n)) ~~> (add (toScala $n) (intLit 1)) ;
  
  rule ifToLean: (toLean (if $c $t $f)) ~~>
    (ifExpr (toLean $c) (toLean $t) (toLean $f)) ;
  rule ifToRust: (toRust (if $c $t $f)) ~~>
    (ifExpr (toRust $c) (block (stmtList (toRust $t)))
      (elseBlock (block (stmtList (toRust $f))))) ;
  rule ifToHaskell: (toHaskell (if $c $t $f)) ~~>
    (ifExpr (toHaskell $c) (toHaskell $t) (toHaskell $f)) ;
  rule ifToScala: (toScala (if $c $t $f)) ~~>
    (ifExpr (toScala $c) (toScala $t) (toScala $f)) ;

-----------------------------------------------------
-- ListTransform: Nil, Cons, List
-----------------------------------------------------
piece ListTransform
  rule nilToLean: (toLean Nil) ~~> (listLit (termList)) ;
  rule nilToRust: (toRust Nil) ~~> (vecLit (exprList)) ;
  rule nilToHaskell: (toHaskell Nil) ~~> (nilLit) ;
  rule nilToScala: (toScala Nil) ~~> (nilLit) ;
  
  rule consToLean: (toLean (Cons $h $t)) ~~> (cons (toLean $h) (toLean $t)) ;
  rule consToRust: (toRust (Cons $h $t)) ~~>
    (blockExpr (block (stmtList
      (stmtLet (patMut (patIdent v)) (toRust $t))
      (methodCall (var v) insert (exprList (intLit 0) (toRust $h)))
      (var v)))) ;
  rule consToHaskell: (toHaskell (Cons $h $t)) ~~> (cons (toHaskell $h) (toHaskell $t)) ;
  rule consToScala: (toScala (Cons $h $t)) ~~> (cons (toScala $h) (toScala $t)) ;
  
  rule listToLean: (toLean (List $items)) ~~> (listLit (toLeanTermList $items)) ;
  rule termListToLean: (toLeanTermList ($t $rest)) ~~>
    (termList (toLean $t) (toLeanTermList $rest)) ;
  rule termListToLeanNil: (toLeanTermList ()) ~~> (termList) ;

-----------------------------------------------------
-- ErrorTransform: Error, Stuck
-----------------------------------------------------
piece ErrorTransform
  rule errorToLean: (toLean (Error $msg)) ~~> (panic $msg) ;
  rule errorToRust: (toRust (Error $msg)) ~~> (panicExpr $msg) ;
  rule errorToHaskell: (toHaskell (Error $msg)) ~~> (errorExpr $msg) ;
  rule errorToScala: (toScala (Error $msg)) ~~>
    (throwExpr (newExpr RuntimeException (termList (strLit $msg)))) ;
  
  rule stuckToLean: (toLean (Stuck $t)) ~~> (app (var Stuck) (toLean $t)) ;
  rule stuckToRust: (toRust (Stuck $t)) ~~> (call (var Stuck) (exprList (toRust $t))) ;
  rule stuckToHaskell: (toHaskell (Stuck $t)) ~~> (app (var Stuck) (toHaskell $t)) ;
  rule stuckToScala: (toScala (Stuck $t)) ~~> (ctorApp Stuck (termList (toScala $t))) ;

-----------------------------------------------------
-- TypeTransform: typeExpr, typeApp, Var, App types
-----------------------------------------------------
piece TypeTransform
  -- typeExpr arrow
  rule typeExprArrowToRust: (toRustType (typeExpr $left -> $right)) ~~>
    (tyFn (typeList (toRustType $left)) (toRustType $right)) ;
  rule typeExprArrowToHaskell: (toHaskellType (typeExpr $left -> $right)) ~~>
    (tyFun (toHaskellType $left) (toHaskellType $right)) ;
  rule typeExprArrowToScala: (toScalaType (typeExpr $left -> $right)) ~~>
    (tyFun (toScalaType $left) (toScalaType $right)) ;
  
  -- typeExpr base
  rule typeExprBaseToRust: (toRustType (typeExpr $t)) ~~> (toRustType $t) ;
  rule typeExprBaseToHaskell: (toHaskellType (typeExpr $t)) ~~> (toHaskellType $t) ;
  rule typeExprBaseToScala: (toScalaType (typeExpr $t)) ~~> (toScalaType $t) ;
  
  -- typeApp
  rule typeAppSingleToRust: (toRustType (typeApp $t)) ~~> (tyPath $t) ;
  rule typeAppSingleToHaskell: (toHaskellType (typeApp $t)) ~~> (tyVar $t) ;
  rule typeAppSingleToScala: (toScalaType (typeApp $t)) ~~> (tyVar $t) ;
  rule typeAppMultiToRust: (toRustType (typeApp $t $args)) ~~>
    (tyGeneric $t (toRustType $args)) ;
  rule typeAppMultiToHaskell: (toHaskellType (typeApp $t $args)) ~~>
    (tyApp (toHaskellType $t) (toHaskellType $args)) ;
  rule typeAppMultiToScala: (toScalaType (typeApp $t $args)) ~~>
    (tyApp (toScalaType $t) (toScalaType $args)) ;
  
  -- IR Var type
  rule typeVarToRust: (toRustType (Var $x)) ~~> (tyPath $x) ;
  rule typeVarToHaskell: (toHaskellType (Var $x)) ~~> (tyVar $x) ;
  rule typeVarToScala: (toScalaType (Var $x)) ~~> (tyVar $x) ;
  
  -- IR App type
  rule typeAppIRToRust: (toRustType (App $f $a)) ~~>
    (tyGeneric (toRustType $f) (toRustType $a)) ;
  rule typeAppIRToHaskell: (toHaskellType (App $f $a)) ~~>
    (tyApp (toHaskellType $f) (toHaskellType $a)) ;
  rule typeAppIRToScala: (toScalaType (App $f $a)) ~~>
    (tyApp (toScalaType $f) (typeList (toScalaType $a))) ;
  
  -- Universe
  rule typeUnivToRust: (toRustType Univ) ~~> (unitTy) ;
  rule typeUnivToHaskell: (toHaskellType Univ) ~~> (tyVar Type) ;
  rule typeUnivToScala: (toScalaType Univ) ~~> (tyAny) ;
  
  -- Fallback
  rule typeIdentToRust: (toRustType $t) ~~> (tyPath $t) ;
  rule typeIdentToHaskell: (toHaskellType $t) ~~> (tyVar $t) ;
  rule typeIdentToScala: (toScalaType $t) ~~> (tyVar $t) ;

-----------------------------------------------------
-- AnnotationTransform: Ann, Loc
-----------------------------------------------------
piece AnnotationTransform
  rule annToLean: (toLean (Ann $t $T)) ~~> (toLean $t) ;
  rule annToRust: (toRust (Ann $t $T)) ~~> (toRust $t) ;
  rule annToHaskell: (toHaskell (Ann $t $T)) ~~> (toHaskell $t) ;
  rule annToScala: (toScala (Ann $t $T)) ~~> (toScala $t) ;
  
  rule locToLean: (toLean (Loc $l $c $t)) ~~> (toLean $t) ;
  rule locToRust: (toRust (Loc $l $c $t)) ~~> (toRust $t) ;
  rule locToHaskell: (toHaskell (Loc $l $c $t)) ~~> (toHaskell $t) ;
  rule locToScala: (toScala (Loc $l $c $t)) ~~> (toScala $t) ;

-----------------------------------------------------
-- LiteralTransform: Const
-----------------------------------------------------
piece LiteralTransform
  rule constIntToLean: (toLean (Const (IntLit $n))) ~~> (numLit $n) ;
  rule constIntToRust: (toRust (Const (IntLit $n))) ~~> (intLit $n) ;
  rule constIntToHaskell: (toHaskell (Const (IntLit $n))) ~~> (intLit $n) ;
  rule constIntToScala: (toScala (Const (IntLit $n))) ~~> (intLit $n) ;
  
  rule constStrToLean: (toLean (Const (StrLit $s))) ~~> (strLit $s) ;
  rule constStrToRust: (toRust (Const (StrLit $s))) ~~> (strLit $s) ;
  rule constStrToHaskell: (toHaskell (Const (StrLit $s))) ~~> (strLit $s) ;
  rule constStrToScala: (toScala (Const (StrLit $s))) ~~> (strLit $s) ;
  
  rule constBoolTrueToLean: (toLean (Const (BoolLit true))) ~~> (trueLit) ;
  rule constBoolFalseToLean: (toLean (Const (BoolLit false))) ~~> (falseLit) ;
  rule constBoolTrueToRust: (toRust (Const (BoolLit true))) ~~> (trueLit) ;
  rule constBoolFalseToRust: (toRust (Const (BoolLit false))) ~~> (falseLit) ;
  rule constBoolTrueToHaskell: (toHaskell (Const (BoolLit true))) ~~> (trueLit) ;
  rule constBoolFalseToHaskell: (toHaskell (Const (BoolLit false))) ~~> (falseLit) ;
  rule constBoolTrueToScala: (toScala (Const (BoolLit true))) ~~> (trueLit) ;
  rule constBoolFalseToScala: (toScala (Const (BoolLit false))) ~~> (falseLit) ;

-----------------------------------------------------
-- OptionTransform: None, Some, Option
-----------------------------------------------------
piece OptionTransform
  rule noneToRust: (toRust None) ~~> (noneLit) ;
  rule noneToHaskell: (toHaskell None) ~~> (nothingLit) ;
  rule someToRust: (toRust (Some $x)) ~~> (someLit (toRust $x)) ;
  rule someToHaskell: (toHaskell (Some $x)) ~~> (justExpr (toHaskell $x)) ;
  rule optionTyToRust: (toRustType (Option $A)) ~~> (tyOption (toRustType $A)) ;
  rule optionTyToHaskell: (toHaskellType (Option $A)) ~~> (tyMaybe (toHaskellType $A)) ;

-----------------------------------------------------
-- RustBoxTransform: Box, Boxed
-----------------------------------------------------
piece RustBoxTransform
  rule boxedToRust: (toRust (Boxed $t)) ~~>
    (call (var Box) (exprList (var new) (exprList (toRust $t)))) ;
  rule boxTyToRust: (toRustType (Boxed $A)) ~~> (tyBox (toRustType $A)) ;
  rule boxTyToRust2: (toRustType (Box $A)) ~~> (tyGeneric Box (toRustType $A)) ;

-----------------------------------------------------
-- HaskellGADTTransform
-----------------------------------------------------
piece HaskellGADTTransform
  rule adtGadtToHaskell: (toHaskellGadt (adtDef $name { $constrs })) ~~>
    (gadtDecl $name (toHaskellGadtCons $constrs)) ;
  rule gadtconsToHaskell: (toHaskellGadtCons ($c $rest)) ~~>
    ((toHaskellGadtCon $c) (toHaskellGadtCons $rest)) ;
  rule gadtconsToHaskellNil: (toHaskellGadtCons ()) ~~> () ;
  rule gadtconToHaskell: (toHaskellGadtCon ($name : $ty)) ~~>
    (gadtCon $name (toHaskellType $ty)) ;

-----------------------------------------------------
-- Entry Points
-----------------------------------------------------
piece Entry
  rule transformLean: (rosettaToLean $program) ~~> (toLean $program) ;
  rule transformRust: (rosettaToRust $program) ~~> (toRust $program) ;
  rule transformHaskell: (rosettaToHaskell $program) ~~> (toHaskell $program) ;
  rule transformScala: (rosettaToScala $program) ~~> (toScala $program) ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------
test "lamToLean": (toLean (Lam x . (Var x))) ~~>
  (lam (simpleBinder x) (var x)) ;
test "lamToRust": (toRust (Lam x . (Var x))) ~~>
  (closure (paramList (param x (refTy (tyInfer)))) (var x)) ;
test "lamToHaskell": (toHaskell (Lam x . (Var x))) ~~>
  (lam (patVar x) (var x)) ;
test "lamToScala": (toScala (Lam x . (Var x))) ~~>
  (lamSimple x (var x)) ;
test "appToLean": (toLean (App (Var f) (Var x))) ~~>
  (app (var f) (var x)) ;
test "pairToLean": (toLean (Pair (Var a) (Var b))) ~~>
  (pair (var a) (var b)) ;
test "pairToRust": (toRust (Pair (Var a) (Var b))) ~~>
  (tuple (exprList (var a) (var b))) ;

