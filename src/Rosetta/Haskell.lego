-----------------------------------------------------
-- Haskell.lego: Haskell AST Definition for Rosetta
--
-- This defines the Haskell abstract syntax tree as a Lego specification.
-- It serves as the TARGET representation for rosetta2haskell transformation.
--
-- Haskell features:
-- - GADTs for precise ADTs
-- - Type classes and instances
-- - Pattern matching
-- - do-notation
-- - where clauses
-- - guards
--
-- BIDIRECTIONAL: parse . print = print . parse = id
-- Layout markers (@nl, @indent, @dedent, @sp, @nsp) guide printing.
-----------------------------------------------------
lang Haskell :=

-----------------------------------------------------
-- Core Terms
-- Basic Haskell expressions
-----------------------------------------------------
piece CoreTerms
  expr ::= 
    -- Variables and literals
    <ident>                             → var
    | <number>                          → intLit
    | <string>                          → strLit
    | "True"                            → trueLit
    | "False"                           → falseLit
    | "()"                              → unitLit
    -- Application (juxtaposition)
    | expr expr                         → app
    -- Lambda
    | "\\" pattern+ @sp "->" @sp expr   → lam
    -- Let
    | "let" @nl @indent letBind+ @dedent "in" @sp expr → letExpr
    | "let" "{" @sp letBind+ @sp "}" "in" @sp expr → letExprBraces
    -- Where (at expression level via do)
    | expr "where" @nl @indent letBind+ @dedent → whereExpr
    -- If-then-else
    | "if" expr "then" @sp expr @sp "else" @sp expr → ifExpr
    -- Case
    | "case" expr "of" @nl @indent caseAlt+ @dedent → caseExpr
    | "case" expr "of" "{" @sp caseAlt+ @sp "}" → caseExprBraces
    -- Tuples
    | "(" @nsp exprList @nsp ")"        → tuple
    | "fst" expr                        → fst
    | "snd" expr                        → snd
    -- Lists
    | "[" @nsp exprList @nsp "]"        → listLit
    | "[]"                              → nilLit
    | expr @sp ":" @sp expr             → cons
    | expr @sp "++" @sp expr            → append
    | "[" @nsp expr @sp "|" @sp qual+ @nsp "]" → listComp
    -- Operators (sections)
    | "(" @nsp expr op @nsp ")"         → leftSection
    | "(" @nsp op expr @nsp ")"         → rightSection
    -- Operators (arithmetic)
    | expr @sp "+" @sp expr             → add
    | expr @sp "-" @sp expr             → sub
    | expr @sp "*" @sp expr             → mul
    | expr @sp "/" @sp expr             → div
    | expr @sp "`div`" @sp expr         → intDiv
    | expr @sp "`mod`" @sp expr         → mod
    | "-" @nsp expr                     → neg
    -- Operators (comparison)
    | expr @sp "==" @sp expr            → eq
    | expr @sp "/=" @sp expr            → neq
    | expr @sp "<" @sp expr             → lt
    | expr @sp ">" @sp expr             → gt
    | expr @sp "<=" @sp expr            → le
    | expr @sp ">=" @sp expr            → ge
    -- Operators (logical)
    | expr @sp "&&" @sp expr            → and
    | expr @sp "||" @sp expr            → or
    | "not" expr                        → not
    -- Function composition/application
    | expr @sp "." @sp expr             → compose
    | expr @sp "$" @sp expr             → dollarApp
    -- Do notation
    | "do" @nl @indent doStmt+ @dedent  → doExpr
    | "do" "{" @sp doStmt+ @sp "}"      → doExprBraces
    -- Monadic
    | expr @sp ">>=" @sp expr           → bind
    | expr @sp ">>" @sp expr            → seqOp
    | "return" expr                     → returnExpr
    | "pure" expr                       → pureExpr
    -- Maybe
    | "Nothing"                         → nothingLit
    | "Just" expr                       → justExpr
    -- Either
    | "Left" expr                       → leftExpr
    | "Right" expr                      → rightExpr
    -- Error
    | "error" <string>                  → errorExpr
    | "undefined"                       → undefinedExpr
    -- Parentheses
    | "(" @nsp expr @nsp ")"            → paren
    -- Type annotation
    | expr @sp "::" @sp type            → typeAnn
    -- Record syntax
    | <ident> @sp "{" @sp fieldBind+ @sp "}" → recordCtor
    | expr @sp "{" @sp fieldBind+ @sp "}" → recordUpdate
    -- Field access
    | expr @nsp "." @nsp <ident>        → fieldAccess
    ;

  exprList ::= expr ("," @sp expr)*     → exprList ;
  op ::= "+" | "-" | "*" | "/" | "." | "$" | "==" | "<" | ">" | ":" | "++" → op ;

-----------------------------------------------------
-- Let Bindings
-----------------------------------------------------
piece LetBindings
  letBind ::= <ident> @sp "=" @sp expr @nl → letBind
            | <ident> pattern* @sp "=" @sp expr @nl → funBind
            | <ident> pattern* guards @nl → funBindGuards
            ;
  guards ::= guard+                     → guards ;
  guard ::= "|" expr @sp "=" @sp expr   → guard ;

-----------------------------------------------------
-- Do Notation
-----------------------------------------------------
piece DoNotation
  doStmt ::= <ident> @sp "<-" @sp expr @nl → doBind
           | "let" @nl @indent letBind+ @dedent → doLet
           | "let" "{" @sp letBind+ @sp "}" → doLetBraces
           | expr @nl                   → doExpr
           ;

-----------------------------------------------------
-- List Comprehension
-----------------------------------------------------
piece ListComprehension
  qual ::= <ident> @sp "<-" @sp expr    → genQual
         | expr                         → filterQual
         | "let" <ident> @sp "=" @sp expr → letQual
         ;

-----------------------------------------------------
-- Types
-- Haskell type expressions
-----------------------------------------------------
piece Types
  type ::= <ident>                      → tyVar
         | "(" @nsp <ident> type+ @nsp ")" → tyApp
         | type @sp "->" @sp type       → tyFun
         | "(" @nsp typeList @nsp ")"   → tyTuple
         | "[" @nsp type @nsp "]"       → tyList
         | "Maybe" type                 → tyMaybe
         | "Either" type type           → tyEither
         | "IO" type                    → tyIO
         | "forall" <ident>+ @sp "." @sp type → tyForall
         | "(" @nsp type @nsp ")"       → tyParen
         ;
  typeList ::= type ("," @sp type)*     → typeList ;

-----------------------------------------------------
-- Patterns
-----------------------------------------------------
piece Patterns
  pattern ::= <ident>                   → patVar
            | "_"                       → patWild
            | <number>                  → patLit
            | <string>                  → patStr
            | "()"                      → patUnit
            | "True"                    → patTrue
            | "False"                   → patFalse
            | <ident> pattern*          → patCtor
            | "(" @nsp patternList @nsp ")" → patTuple
            | "[" @nsp patternList @nsp "]" → patList
            | "[]"                      → patNil
            | pattern @sp ":" @sp pattern → patCons
            | pattern @sp "@" @sp pattern → patAs
            | "(" @nsp pattern @nsp ")" → patParen
            | <ident> @sp "{" @sp fieldPat+ @sp "}" → patRecord
            ;
  patternList ::= pattern ("," @sp pattern)* → patternList ;
  fieldPat ::= <ident> @sp "=" @sp pattern → fieldPat ;
  caseAlt ::= pattern @sp "->" @sp expr @nl → caseAlt
            | pattern guards @nl        → caseAltGuards
            ;

-----------------------------------------------------
-- Field Bindings (Records)
-----------------------------------------------------
piece Records
  fieldBind ::= <ident> @sp "=" @sp expr → fieldBind ;

-----------------------------------------------------
-- Declarations
-- Top-level declarations
-----------------------------------------------------
piece Declarations
  decl ::= 
    -- Data types
    "data" <ident> tyVarList? @nl @indent "=" dataCon @nl ("|" dataCon @nl)* @dedent derivingClause? @nl
      → dataDecl
    | "data" <ident> tyVarList? "where" @nl @indent gadtCon* @dedent derivingClause? @nl
      → gadtDecl
    -- Newtype
    | "newtype" <ident> tyVarList? @sp "=" @sp <ident> type derivingClause? @nl
      → newtypeDecl
    -- Type synonym
    | "type" <ident> tyVarList? @sp "=" @sp type @nl
      → typeSynDecl
    -- Function definition
    | <ident> @sp "::" @sp type @nl
      → typeSigDecl
    | <ident> pattern* @sp "=" @sp expr whereClause? @nl
      → funDecl
    | <ident> pattern* guards whereClause? @nl
      → funDeclGuards
    -- Class/Instance
    | "class" context? <ident> tyVarList "where" @nl @indent classMethod* @dedent
      → classDecl
    | "instance" context? <ident> type+ "where" @nl @indent instMethod* @dedent
      → instanceDecl
    -- Module
    | "module" modulePath exports? "where" @nl
      → moduleDecl
    | "import" qualified? modulePath importSpec? @nl
      → importDecl
    -- Infix
    | "infixl" <number> <ident> @nl
      → infixlDecl
    | "infixr" <number> <ident> @nl
      → infixrDecl
    | "infix" <number> <ident> @nl
      → infixDecl
    -- Comments (for generated code)
    | "--" <ident>* @nl
      → comment
    ;

  dataCon ::= <ident> type*             → dataCon
            | <ident> @sp "{" @sp fieldDecl+ @sp "}" → dataConRecord
            ;
  gadtCon ::= <ident> @sp "::" @sp type @nl → gadtCon ;
  fieldDecl ::= <ident> @sp "::" @sp type → fieldDecl ;
  tyVarList ::= <ident>+                → tyVarList ;
  derivingClause ::= @indent "deriving" @nsp "(" @nsp <ident> ("," @sp <ident>)* @nsp ")" @dedent → derivingClause
                   | @indent "deriving" <ident> @dedent → derivingClauseSimple
                   ;
  context ::= "(" @nsp constraint ("," @sp constraint)* @nsp ")" @sp "=>" → context
            | constraint @sp "=>"       → contextSimple
            ;
  constraint ::= <ident> type+          → constraint ;
  classMethod ::= <ident> @sp "::" @sp type @nl → classMethod ;
  instMethod ::= <ident> pattern* @sp "=" @sp expr @nl → instMethod ;
  whereClause ::= "where" @nl @indent letBind+ @dedent → whereClause ;
  modulePath ::= <ident> ("." @nsp <ident>)* → modulePath ;
  exports ::= "(" @nsp exportItem ("," @sp exportItem)* @nsp ")" → exports ;
  exportItem ::= <ident>                → exportItem
               | <ident> @nsp "(..)"    → exportAll
               | "module" <ident>       → exportModule
               ;
  qualified ::= "qualified"             → qualified ;
  importSpec ::= "(" @nsp importItem ("," @sp importItem)* @nsp ")" → importSpec
               | "hiding" "(" @nsp importItem ("," @sp importItem)* @nsp ")" → importHiding
               | "as" <ident>           → importAs
               ;
  importItem ::= <ident>                → importItem
               | <ident> @nsp "(..)"    → importItemAll
               ;

-----------------------------------------------------
-- Module
-- Top-level structure
-----------------------------------------------------
piece Module
  module ::= decl*                      → module ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------
test "lam": (lam (patVar x) (add (var x) (intLit 1))) ;
test "data": (dataDecl Maybe (tyVarList a) (dataCon Nothing) (dataCon Just (tyVar a))) ;
test "fun": (funDecl id (patVar x) (var x)) ;
test "case": (caseExpr (var mx) (caseAlt (patCtor Nothing) (intLit 0)) (caseAlt (patCtor Just (patVar x)) (var x))) ;
test "gadt": (gadtDecl Expr (tyVarList a) (gadtCon Lit (tyFun (tyVar Int) (tyApp Expr (tyVar Int))))) ;

