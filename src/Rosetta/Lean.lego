-----------------------------------------------------
-- Lean.lego: Lean 4 AST Definition for Rosetta
--
-- This defines the Lean 4 abstract syntax tree as a Lego specification.
-- It serves as the TARGET representation for rosetta2lean transformation.
--
-- Structure follows the Rosetta design pattern:
-- - Term syntax via 'term ::=' grammar
-- - Type syntax via 'type ::=' grammar  
-- - Declaration syntax via 'decl ::=' grammar
-- - No transformation rules here - those go in rosetta2lean.lego
--
-- This is the "what Lean code looks like" specification.
-----------------------------------------------------
lang Lean :=

-----------------------------------------------------
-- Core Terms
-- Basic Lean expressions
-----------------------------------------------------
piece CoreTerms
  term ::= 
    -- Universes
    "Type" level?                       → typeUniv
    | "Prop"                            → propUniv
    | "Sort" level?                     → sortUniv
    -- Variables and literals
    | <ident>                           → var
    | <number>                          → numLit
    | <string>                          → strLit
    | "true"                            → trueLit
    | "false"                           → falseLit
    | "()" | "Unit.unit"                → unitLit
    -- Application
    | term term                         → app
    | term "@" term                     → explicitApp
    -- Lambda and function
    | "fun" binder+ "=>" term           → lam
    | "λ" binder+ "=>" term             → lamUnicode
    -- Pi and arrow types
    | "∀" binder+ "," term              → forallTy
    | "Π" binder+ "," term              → piTy
    | term "→" term                     → arrowTy
    -- Sigma and product types
    | "Σ" binder+ "," term              → sigmaTy
    | term "×" term                     → prodTy
    -- Pairs and projections
    | "(" term "," term ")"             → pair
    | "⟨" termList "⟩"                  → anonCtor
    | term ".1" | term ".fst"           → fst
    | term ".2" | term ".snd"           → snd
    | term "." <ident>                  → proj
    -- Let expressions
    | "let" <ident> typeAnn? ":=" term "in"? term → letExpr
    | "let" "rec" <ident> typeAnn? ":=" term "in"? term → letRecExpr
    -- Conditionals
    | "if" term "then" term "else" term → ifExpr
    | "if" "let" pattern ":=" term "then" term "else" term → ifLetExpr
    -- Match
    | "match" termList "with" matchAlt* → matchExpr
    -- Lists and arrays
    | "[" termList "]"                  → listLit
    | "#[" termList "]"                 → arrayLit
    | term "::" term                    → cons
    | term "++" term                    → append
    -- Option
    | "none"                            → noneLit
    | "some" term                       → someLit
    | "Option" term                     → optionTy
    -- Operators (arithmetic)
    | term "+" term                     → add
    | term "-" term                     → sub
    | term "*" term                     → mul
    | term "/" term                     → div
    | term "%" term                     → mod
    | "-" term                          → neg
    -- Operators (comparison)
    | term "==" term                    → beq
    | term "!=" term                    → bne
    | term "<" term                     → lt
    | term ">" term                     → gt
    | term "<=" term                    → le
    | term ">=" term                    → ge
    -- Operators (logical)
    | term "&&" term                    → and
    | term "||" term                    → or
    | "!" term                          → not
    -- Do notation
    | "do" doElem+                      → doBlock
    -- Tactics
    | "by" tactic+                      → byTactic
    -- Parentheses and hole
    | "(" term ")"                      → paren
    | "_"                               → hole
    -- Coercion
    | "↑" term                          → coeUp
    -- Dollar application
    | term "$" term                     → dollarApp
    -- Pipe operators  
    | term "|>" term                    → pipeRight
    | term "<|" term                    → pipeLeft
    -- Structure literal
    | "{" fieldAssign* "}"              → structLit
    | term "with" "{" fieldAssign* "}"  → structUpdate
    -- Error/stuck
    | "panic!" <string>                 → panic
    | "sorry"                           → sorryTerm
    ;

  termList ::= term ("," term)*         → termList ;
  level ::= <number>                    → levelLit
          | "max" level level           → levelMax
          | "imax" level level          → levelIMax
          | level "+" <number>          → levelSucc
          ;

-----------------------------------------------------
-- Binders
-- Lambda/forall binders
-----------------------------------------------------
piece Binders
  binder ::= <ident>                              → simpleBinder
           | "(" <ident> ":" term ")"             → explicitBinder
           | "{" <ident> ":" term "}"             → implicitBinder
           | "[" <ident> ":" term "]"             → instBinder
           | "(" <ident> ")"                      → parenBinder
           ;
  typeAnn ::= ":" term                            → typeAnn ;

-----------------------------------------------------
-- Patterns
-- Match patterns
-----------------------------------------------------
piece Patterns
  pattern ::= <ident>                             → patVar
            | "_"                                 → patWild
            | <number>                            → patNum
            | <string>                            → patStr
            | "." <ident>                         → patCtor
            | <ident> pattern*                    → patApp
            | "(" patternList ")"                 → patTuple
            | "⟨" patternList "⟩"                 → patAnon
            | pattern "::" pattern                → patCons
            | pattern "+" <number>                → patSucc
            ;
  patternList ::= pattern ("," pattern)*          → patternList ;
  matchAlt ::= "|" patternList "=>" term          → matchAlt ;

-----------------------------------------------------
-- Do Notation
-- Monadic do blocks
-----------------------------------------------------
piece DoNotation
  doElem ::= "let" <ident> "←" term               → doLetBind
           | "let" <ident> ":=" term              → doLetPure
           | <ident> "←" term                     → doBind
           | "return" term                        → doReturn
           | "pure" term                          → doPure
           | "if" term "then" doElem+ "else"? doElem* → doIf
           | "for" <ident> "in" term "do" doElem+ → doFor
           | term                                 → doExpr
           ;

-----------------------------------------------------
-- Tactics
-- Proof tactics
-----------------------------------------------------
piece Tactics
  tactic ::= "rfl"                                → tacRfl
           | "sorry"                              → tacSorry
           | "trivial"                            → tacTrivial
           | "decide"                             → tacDecide
           | "assumption"                         → tacAssumption
           | "intro" <ident>*                     → tacIntro
           | "exact" term                         → tacExact
           | "apply" term                         → tacApply
           | "simp" simpArgs?                     → tacSimp
           | "cases" term                         → tacCases
           | "induction" term "with" inductAlt*  → tacInduction
           | "constructor"                        → tacConstructor
           | "rw" "[" rwRule* "]"                 → tacRewrite
           | <ident> term*                        → tacApp
           ;
  simpArgs ::= "[" term* "]"                      → simpArgs ;
  inductAlt ::= "|" <ident> <ident>* "=>" tactic+ → inductAlt ;
  rwRule ::= "←"? term                            → rwRule ;

-----------------------------------------------------
-- Declarations
-- Top-level declarations
-----------------------------------------------------
piece Declarations
  decl ::= 
    -- Inductive types
    "inductive" <ident> param* whereCtors? derivingClause? @nl
      → inductiveDecl
    -- Structures
    | "structure" <ident> param* extendsClause? "where" @nl @indent fieldDecl* @dedent derivingClause?
      → structureDecl
    -- Classes
    | "class" <ident> param* extendsClause? "where" @nl @indent fieldDecl* @dedent
      → classDecl
    -- Instances
    | "instance" instName? ":" term "where" @nl @indent fieldDef* @dedent
      → instanceDecl
    -- Definitions
    | "def" <ident> param* typeAnn? whereClause? ":=" term @nl
      → defDecl
    | "partial" "def" <ident> param* typeAnn? ":=" term @nl
      → partialDefDecl
    | "abbrev" <ident> param* typeAnn? ":=" term @nl
      → abbrevDecl
    -- Theorems
    | "theorem" <ident> param* ":" term ":=" term @nl
      → theoremDecl
    | "lemma" <ident> param* ":" term ":=" term @nl
      → lemmaDecl
    | "example" ":" term ":=" term @nl
      → exampleDecl
    -- Namespaces
    | "namespace" <ident> @nl @indent decl* @dedent "end" <ident> @nl
      → namespaceDecl
    | "section" <ident>? @nl @indent decl* @dedent "end" <ident>? @nl
      → sectionDecl
    -- Imports and opens
    | "import" modulePath @nl
      → importDecl
    | "open" modulePath inClause? @nl
      → openDecl
    -- Variables
    | "variable" varDecl+ @nl
      → variableDecl
    -- Attributes
    | "attribute" "[" <ident> "]" <ident> @nl
      → attributeDecl
    ;

  param ::= <ident>                               → simpleParam
          | "(" @nsp <ident> ":" term ")" @sp     → explicitParam
          | "{" @nsp <ident> ":" term "}" @sp     → implicitParam
          | "[" @nsp <ident> ":" term "]" @sp     → instParam
          ;
  whereCtors ::= "where" @nl @indent ctor* @dedent → whereCtors ;
  ctor ::= "|" <ident> param* ":" term @nl        → ctor ;
  derivingClause ::= "deriving" <ident> ("," <ident>)* → derivingClause ;
  fieldDecl ::= <ident> ":" term defaultVal?      → fieldDecl ;
  fieldDef ::= <ident> ":=" term                  → fieldDef ;
  fieldAssign ::= <ident> ":=" term               → fieldAssign ;
  defaultVal ::= ":=" term                        → defaultVal ;
  extendsClause ::= "extends" term                → extendsClause ;
  instName ::= <ident>                            → instName ;
  modulePath ::= <ident> ("." <ident>)*           → modulePath ;
  inClause ::= "in" term                          → inClause ;
  varDecl ::= "(" <ident> ":" term ")"            → explicitVarDecl
            | "{" <ident> ":" term "}"            → implicitVarDecl
            ;
  whereClause ::= "where" letDecl*                → whereClause ;
  letDecl ::= <ident> ":=" term                   → letDecl ;

-----------------------------------------------------
-- Module
-- Top-level module structure
-----------------------------------------------------
piece Module
  module ::= decl*                                → module ;

-----------------------------------------------------
-- Tests
-- Syntax validation examples
-----------------------------------------------------
test "lam": (lam (explicitBinder x Nat) (add (var x) (numLit 1))) ;
test "forall": (forallTy (explicitBinder x Type) (arrowTy (var x) (var x))) ;
test "inductive": (inductiveDecl Term (whereCtors (ctor Var (explicitParam x Nat) (var Term)))) ;
test "def": (defDecl id (explicitParam A Type) (explicitParam x (var A)) (typeAnn (var A)) (var x)) ;
test "match": (matchExpr (termList (var x)) (matchAlt (patVar n) (add (var n) (numLit 1)))) ;

