-----------------------------------------------------
-- Lean.lego: Lean 4 Grammar Definition
--
-- This defines the Lean 4 syntax as a Lego grammar specification.
-- Used for:
-- 1. Parsing .lean files
-- 2. Code generation target (pretty-printing Lean code)
--
-- Note: Reserved keywords (def, end, namespace, etc.) are automatically
-- detected from the grammar literals and tokenized as symbols.
-----------------------------------------------------
lang Lean :=

-----------------------------------------------------
-- Token: Character-level grammar (lexer)
-- Defines Lean-specific tokenization including comments
-----------------------------------------------------
token Token
  -- Basic ASCII character classes
  digit  ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
  lower  ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
           | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
           | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
  upper  ::= 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
           | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
           | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
  alpha  ::= lower | upper | '_' ;
  
  -- Symbol characters (for operators)
  symch  ::= '+' | '-' | '*' | '/' | '=' | '<' | '>' | '!' | '@' | '#'
           | '$' | '%' | '^' | '&' | '|' | '~' | '?' | ':' | ';' | ','
           | '.' | '[' | ']' | '(' | ')' | '{' | '}' | '`' | '\\' ;
  
  -- Identifiers
  ident  ::= alpha (alpha | digit | '\'' | '?' | '!' | '«' | '»')* ;
  
  -- Numbers  
  number ::= digit+ ;
  
  -- String literals
  string ::= '"' strchar* '"' ;
  strchar ::= '\\' escape | alpha | digit | symch | ' ' | '\'' | '\t' ;
  escape ::= 'n' | 't' | 'r' | '\\' | '"' | '\'' | '0' ;
  
  -- Whitespace
  ws     ::= ' ' | '\t' | '\n' | '\r' ;
  
  -- Line comments: -- ...
  comment ::= '-' '-' nonnl* ;
  nonnl  ::= alpha | digit | symch | ' ' | '\t' | '\'' | '"' ;
  
  -- Block comments: /- ... -/
  -- Note: Block comments can contain any characters including '/' and '-'
  -- The tokenizer uses the grammar but manually handles the end sequence
  blockComment ::= '/' '-' blockInner* '-' '/' ;
  blockInner ::= alpha | digit | symch | ' ' | '\t' | '\n' | '\r' | '\'' | '"' | '-' | '/' ;
  
  -- Operators
  operator ::= #longest[
      ':' ':' '=',   -- ::=
      '~' '~' '>',   -- ~~>
      ':' '=',       -- :=
      '~' '>',       -- ~>
      '-' '>',       -- ->
      '→',           -- Unicode arrow
      '<' '-',       -- <-
      '←',           -- Unicode left arrow
      '=' '>',       -- =>
      '⇒',           -- Unicode double arrow
      '|' '>',       -- |>
      '<' '|',       -- <|
      '&' '&',       -- &&
      '|' '|',       -- ||
      '=' '=',       -- ==
      '!' '=',       -- !=
      '<' '=',       -- <=
      '≤',           -- Unicode <=
      '>' '=',       -- >=
      '≥',           -- Unicode >=
      '+' '+',       -- ++
      ':' ':',       -- ::
      '.' '1',       -- .1
      '.' '2',       -- .2
      '∀',           -- forall
      '∃',           -- exists
      'Π',           -- Pi
      'Σ',           -- Sigma
      '×',           -- product
      '⟨',           -- angle bracket open
      '⟩',           -- angle bracket close
      '↑',           -- coercion
      '#' '[',       -- array literal
      '#' 'c' 'h' 'e' 'c' 'k',  -- #check
      '#' 'e' 'v' 'a' 'l',       -- #eval
      '#' 'p' 'r' 'i' 'n' 't',   -- #print
      '@' '[',       -- attribute start
      '@',           -- explicit
      '$',           -- dollar
      '+', '-', '*', '/', '%',
      '<', '>', '=', '!',
      '(', ')', '[', ']', '{', '}',
      ',', '.', ':', ';', '|', '_'
    ] ;

-----------------------------------------------------
-- Core Terms
-- Basic Lean expressions
-- Grammar is structured to avoid left-recursion:
--   term -> arrowExpr -> orExpr -> andExpr -> cmpExpr -> addExpr -> mulExpr -> unaryExpr -> appExpr -> atomExpr
-- 
-- BIDIRECTIONAL: parse . print = print . parse = id
-- Layout markers (@nl, @indent, @dedent, @sp, @nsp) guide printing.
-----------------------------------------------------
piece CoreTerms
  -- Top level: arrow types (right-associative)
  term ::= arrowExpr                              → term ;
  
  arrowExpr ::= orExpr @sp "→" @sp arrowExpr      → arrowTy
              | orExpr @sp "×" @sp arrowExpr      → prodTy
              | orExpr                            → arrowExpr
              ;
  
  -- Logical or
  orExpr ::= andExpr @sp "||" @sp orExpr          → or
           | andExpr                              → orExpr
           ;
  
  -- Logical and
  andExpr ::= cmpExpr @sp "&&" @sp andExpr        → and
            | cmpExpr                             → andExpr
            ;
  
  -- Comparison operators (non-associative)
  cmpExpr ::= addExpr @sp "==" @sp addExpr        → beq
            | addExpr @sp "!=" @sp addExpr        → bne
            | addExpr @sp "<" @sp addExpr         → lt
            | addExpr @sp ">" @sp addExpr         → gt
            | addExpr @sp "<=" @sp addExpr        → le
            | addExpr @sp ">=" @sp addExpr        → ge
            | addExpr                             → cmpExpr
            ;
  
  -- Additive operators (left-to-right via iteration)
  addExpr ::= mulExpr addOp*                      → addExpr ;
  addOp ::= @sp "+" @sp mulExpr                   → addOp
          | @sp "-" @sp mulExpr                   → subOp
          | @sp "++" @sp mulExpr                  → appendOp
          | @sp "::" @sp mulExpr                  → consOp
          ;
  
  -- Multiplicative operators
  mulExpr ::= unaryExpr mulOp*                    → mulExpr ;
  mulOp ::= @sp "*" @sp unaryExpr                 → mulOp
          | @sp "/" @sp unaryExpr                 → divOp
          | @sp "%" @sp unaryExpr                 → modOp
          ;
  
  -- Unary operators
  unaryExpr ::= "-" unaryExpr                     → neg
              | "!" unaryExpr                     → not
              | "↑" unaryExpr                     → coeUp
              | appExpr                           → unaryExpr
              ;
  
  -- Application (juxtaposition, left-associative via iteration)
  -- Includes postfix operators like projections
  appExpr ::= primaryExpr postfixOp*              → appExpr ;
  postfixOp ::= "@" @nsp primaryExpr              → explicitArg
              | argExpr                           → appArg
              | @nsp ".1"                         → fstOp
              | @nsp ".2"                         → sndOp
              | @nsp ".fst"                       → fstOp
              | @nsp ".snd"                       → sndOp
              | @nsp "." @nsp <ident>             → projOp
              | @sp "$" @sp term                  → dollarOp
              | @sp "|>" @sp term                 → pipeRightOp
              | @sp "<|" @sp term                 → pipeLeftOp
              | @sp "with" @sp "{" fieldAssign* "}" → structUpdateOp
              ;

  -- Argument expressions: subset of primaryExpr that doesn't include
  -- control-flow keywords (do, if, match, by, fun, let)
  -- This prevents greedy consumption in contexts like "for x in xs do ..."
  argExpr ::=
    -- Universes
    "Type" level?                                 → typeUniv
    | "Prop"                                      → propUniv
    | "Sort" level?                               → sortUniv
    -- Variables and literals
    | <ident>                                     → var
    | <number>                                    → numLit
    | <string>                                    → strLit
    | "true"                                      → trueLit
    | "false"                                     → falseLit
    | "()"                                        → unitLit
    | "Unit.unit"                                 → unitLit
    -- Lists and arrays
    | "[" termList? "]"                           → listLit
    | "#[" termList? "]"                          → arrayLit
    -- Option
    | "none"                                      → noneLit
    | "some" argExpr                              → someLit
    | "Option" argExpr                            → optionTy
    -- Parenthesized expressions (can contain anything)
    | "(" term ")"                                → paren
    | "(" term "," term ")"                       → pair
    -- Anonymous constructors
    | "⟨" termList "⟩"                            → anonCtor
    -- Structure literals
    | "{" fieldAssign* "}"                        → structLit
    -- Hole
    | "_"                                         → hole
    ;
  
  -- Primary expressions (no left recursion)
  primaryExpr ::= 
    -- Universes
    "Type" level?                                 → typeUniv
    | "Prop"                                      → propUniv
    | "Sort" level?                               → sortUniv
    -- Variables and literals
    | <ident>                                     → var
    | <number>                                    → numLit
    | <string>                                    → strLit
    | "true"                                      → trueLit
    | "false"                                     → falseLit
    | "()"                                        → unitLit
    | "Unit.unit"                                 → unitLit
    -- Anonymous dot constructor (type-directed)
    | "." @nsp <ident>                            → dotCtor
    -- Lambda and function
    | "fun" binder+ @sp "=>" @sp term             → lam
    | "λ" binder+ @sp "=>" @sp term               → lamUnicode
    -- Pi/forall/sigma types
    | "∀" binder+ "," @sp term                    → forallTy
    | "Π" binder+ "," @sp term                    → piTy
    | "Σ" binder+ "," @sp term                    → sigmaTy
    -- Let expressions
    | "let" <ident> typeAnn? @sp ":=" @sp term "in"? @sp term → letExpr
    | "let" "rec" <ident> typeAnn? @sp ":=" @sp term "in"? @sp term → letRecExpr
    -- Conditionals
    | "if" term "then" @sp term @sp "else" @sp term → ifExpr
    | "if" "let" pattern @sp ":=" @sp term "then" @sp term @sp "else" @sp term → ifLetExpr
    -- Match (including monadic match with ←)
    | "match" termList "with" @nl @indent matchAlt* @dedent → matchExpr
    | "match" "←" term "with" @nl @indent matchAlt* @dedent → matchBindExpr
    -- Lists and arrays
    | "[" @nsp termList? @nsp "]"                 → listLit
    | "#[" @nsp termList? @nsp "]"                → arrayLit
    -- Option
    | "none"                                      → noneLit
    | "some" primaryExpr                          → someLit
    | "Option" primaryExpr                        → optionTy
    -- Do notation
    | "do" @nl @indent doElem+ @dedent            → doBlock
    -- Tactics
    | "by" @sp tactic+                            → byTactic
    -- Parenthesized expressions
    | "(" @nsp term @nsp ")"                      → paren
    | "(" @nsp term "," @sp term @nsp ")"         → pair
    -- Anonymous constructors
    | "⟨" @nsp termList @nsp "⟩"                  → anonCtor
    -- Structure literals
    | "{" fieldAssign* "}"                        → structLit
    -- Hole and sorry
    | "_"                                         → hole
    | "sorry"                                     → sorryTerm
    | "panic!" <string>                           → panic
    ;

  termList ::= term ("," @sp term)*               → termList ;
  level ::= <number>                              → levelLit
          | "max" level level                     → levelMax
          | "imax" level level                    → levelIMax
          | level "+" <number>                    → levelSucc
          ;

-----------------------------------------------------
-- Binders
-- Lambda/forall binders
-----------------------------------------------------
piece Binders
  binder ::= <ident>                              → simpleBinder
           | "(" @nsp <ident> @sp ":" @sp term @nsp ")" → explicitBinder
           | "{" @nsp <ident> @sp ":" @sp term @nsp "}" → implicitBinder
           | "[" @nsp <ident> @sp ":" @sp term @nsp "]" → instBinder
           | "(" @nsp <ident> @nsp ")"            → parenBinder
           ;
  typeAnn ::= @sp ":" @sp term                    → typeAnn ;

-----------------------------------------------------
-- Patterns
-- Match patterns
-----------------------------------------------------
piece Patterns
  pattern ::= <ident>                             → patVar
            | "_"                                 → patWild
            | <number>                            → patNum
            | <string>                            → patStr
            | "." @nsp <ident>                    → patCtor
            | <ident> pattern*                    → patApp
            | "some" pattern                      → patSome
            | "none"                              → patNone
            | "(" @nsp patternList @nsp ")"       → patTuple
            | "⟨" @nsp patternList @nsp "⟩"       → patAnon
            | "[" @nsp patternList? @nsp "]"      → patList
            | "#[" @nsp patternList? @nsp "]"     → patArray
            | pattern @sp "::" @sp pattern        → patCons
            | pattern @sp "+" @sp <number>        → patSucc
            ;
  patternList ::= pattern ("," @sp pattern)*      → patternList ;
  -- Match alternatives can contain either a single term or a sequence of doElems
  matchAlt ::= "|" patternList @sp "=>" @sp doElem+ → matchAltDo
             | "|" patternList @sp "=>" @sp term @nl → matchAlt
             ;

-----------------------------------------------------
-- Do Notation
-- Monadic do blocks
-----------------------------------------------------
piece DoNotation
  doElem ::= "let" <ident> @sp "←" @sp term @nl   → doLetBind
           | "let" <ident> @sp ":=" @sp term @nl  → doLetPure
           | <ident> @sp "←" @sp term @nl         → doBind
           | "return" term @nl                    → doReturn
           | "pure" term @nl                      → doPure
           | "if" term "then" @nl @indent doElem+ @dedent "else"? @nl @indent doElem* @dedent → doIf
           | "for" <ident> "in" appExpr "do" @nl @indent doElem+ @dedent → doFor
           | term @nl                             → doExpr
           ;

-----------------------------------------------------
-- Tactics
-- Proof tactics
-----------------------------------------------------
piece Tactics
  tactic ::= "rfl"                                → tacRfl
           | "sorry"                              → tacSorry
           | "trivial"                            → tacTrivial
           | "decide"                             → tacDecide
           | "assumption"                         → tacAssumption
           | "intro" <ident>*                     → tacIntro
           | "exact" term                         → tacExact
           | "apply" term                         → tacApply
           | "simp" simpArgs?                     → tacSimp
           | "cases" term                         → tacCases
           | "induction" term "with" inductAlt*  → tacInduction
           | "constructor"                        → tacConstructor
           | "rw" "[" rwRule* "]"                 → tacRewrite
           | <ident> term*                        → tacApp
           ;
  simpArgs ::= "[" term* "]"                      → simpArgs ;
  inductAlt ::= "|" <ident> <ident>* "=>" tactic+ → inductAlt ;
  rwRule ::= "←"? term                            → rwRule ;

-----------------------------------------------------
-- Declarations
-- Top-level declarations
-- Note: Layout markers (@nl, @indent, @dedent) are for pretty-printing only.
-- During parsing, they are ignored - block structure is determined by keywords.
--
-- BIDIRECTIONAL: parse . print = print . parse = id
-----------------------------------------------------
piece Declarations
  decl ::= 
    -- Inductive types
    "inductive" <ident> param* whereCtors? derivingClause? @nl
      → inductiveDecl
    -- Structures  
    | "structure" <ident> param* extendsClause? "where" @nl @indent fieldDecl* @dedent derivingClause?
      → structureDecl
    -- Classes
    | "class" <ident> param* extendsClause? "where" @nl @indent fieldDecl* @dedent
      → classDecl
    -- Instances
    | "instance" instName? @sp ":" @sp term "where" @nl @indent fieldDef* @dedent
      → instanceDecl
    -- Definitions - these are the key ones
    | "def" <ident> param* typeAnn? whereClause? @sp ":=" @sp term @nl
      → defDecl
    | "def" <ident> typeAnn? @nl @indent matchAlt+ @dedent
      → defDeclMatch
    | "partial" "def" <ident> param* typeAnn? @sp ":=" @sp term @nl
      → partialDefDecl
    | "abbrev" <ident> param* typeAnn? @sp ":=" @sp term @nl
      → abbrevDecl
    -- Theorems
    | "theorem" <ident> param* @sp ":" @sp term @sp ":=" @sp term @nl
      → theoremDecl
    | "lemma" <ident> param* @sp ":" @sp term @sp ":=" @sp term @nl
      → lemmaDecl
    | "example" @sp ":" @sp term @sp ":=" @sp term @nl
      → exampleDecl
    -- Namespaces - use 'end' keyword as explicit delimiter
    | "namespace" modulePath @nl @indent nsBody @dedent "end" modulePath @nl
      → namespaceDecl
    | "section" <ident>? @nl @indent nsBody @dedent "end" <ident>? @nl
      → sectionDecl
    -- Imports and opens  
    | "import" modulePath @nl
      → importDecl
    | "open" modulePath inClause? @nl
      → openDecl
    -- Variables
    | "variable" varDecl+ @nl
      → variableDecl
    -- Attributes
    | "attribute" "[" @nsp <ident> @nsp "]" <ident> @nl
      → attributeDecl
    -- Set options
    | "set_option" modulePath term @nl
      → setOptionDecl
    -- Notation and macros
    | "macro" <ident> param* @sp ":" @sp <ident> @sp ":=" @sp term @nl
      → macroDecl
    | "notation" <string> @sp ":=" @sp term @nl
      → notationDecl
    | "syntax" term* @sp ":" @sp <ident> @nl
      → syntaxDecl
    -- Private/protected modifiers
    | "private" decl
      → privateDecl
    | "protected" decl
      → protectedDecl
    -- @[simp] style attributes
    | "@[" @nsp <ident> @nsp "]" decl
      → attrDecl
    -- #check, #eval, #print commands
    | "#check" term @nl
      → checkCmd
    | "#eval" term @nl
      → evalCmd
    | "#print" <ident> @nl
      → printCmd
    -- Comments (for generated code)
    | "--" <ident>* @nl
      → comment
    ;

  param ::= <ident>                               → simpleParam
          | "(" @nsp <ident> ":" term ")" @sp     → explicitParam
          | "{" @nsp <ident> ":" term "}" @sp     → implicitParam
          | "[" @nsp <ident> ":" term "]" @sp     → instParam
          ;
  whereCtors ::= "where" @indent @nl ctor* @dedent → whereCtors ;
  ctor ::= "|" <ident> param* ":" term @nl        → ctor ;
  derivingClause ::= "deriving" <ident> ("," @sp <ident>)* → derivingClause ;
  fieldDecl ::= <ident> @sp ":" @sp term defaultVal? @nl → fieldDecl ;
  fieldDef ::= <ident> @sp ":=" @sp term @nl      → fieldDef ;
  -- Field assignments in struct literals
  fieldAssign ::= <ident> @sp ":=" @sp term       → fieldAssign ;
  defaultVal ::= @sp term                         → defaultVal ;
  extendsClause ::= "extends" term                → extendsClause ;
  instName ::= <ident>                            → instName ;
  modulePath ::= <ident> ("." @nsp <ident>)*      → modulePath ;
  inClause ::= "in" term                          → inClause ;
  varDecl ::= "(" @nsp <ident> @sp ":" @sp term @nsp ")" → explicitVarDecl
            | "{" @nsp <ident> @sp ":" @sp term @nsp "}" → implicitVarDecl
            ;
  whereClause ::= "where" @nl @indent letDecl* @dedent → whereClause ;
  letDecl ::= <ident> @sp ":=" @sp term @nl       → letDecl ;
  -- Namespace body: declarations until 'end' keyword
  nsBody ::= decl*                                → nsBody ;

-----------------------------------------------------
-- Module
-- Top-level module structure
-----------------------------------------------------
piece Module
  module ::= decl*                                → module ;

-----------------------------------------------------
-- Rosetta IR Support
-- These productions PARSE Rosetta IR syntax and PRINT Lean syntax.
-- For printing: the AST structure matches what Rosetta produces.
-- When emitting, we output Lean keywords but consume Rosetta structure.
--
-- Key insight: printGrammar emits literals without consuming AST.
-- So we use the SAME literals that Rosetta uses ("adt", "{", etc.)
-- but they get emitted as-is. To emit DIFFERENT text, we need
-- transformation rules BEFORE printing.
--
-- For now: just accept Rosetta IR and print it (won't look like Lean).
-----------------------------------------------------
piece RosettaIR
  -- Accept adtDef from Rosetta - prints the Rosetta syntax
  rosettaDecl ::= "adt" <ident> rosettaTypeParams? "{" rosettaConstrs "}" → adtDef ;
  rosettaTypeParams ::= "(" rosettaParamGroup* ")" → typeParams | "(" ")" → unit ;
  rosettaParamGroup ::= <ident>+ ":" rosettaType → paramGroup ;
  rosettaConstrs ::= rosettaConstr ("," rosettaConstr)* → seq ;
  rosettaConstr ::= <ident> ":" rosettaType → constr ;
  
  -- Rewrite rule from Rosetta
  rosettaDecl ::= "rewrite" <ident> ":" rosettaTerm "~>" rosettaTerm ";" → rewriteRule ;
  
  -- Type expressions  
  rosettaType ::= rosettaTypeApp (rosettaArrow rosettaType)? → typeExpr ;
  rosettaArrow ::= "→" | "->" ;
  rosettaTypeApp ::= <ident> rosettaType* → typeApp ;
  rosettaType ::= "$" <ident> → typeVar ;
  
  -- Term expressions
  rosettaTerm ::= <ident> rosettaTerm* → app
               | "$" <ident> → metavar
               | <string> → strLit
               | <number> → numLit
               ;
  
  -- A file is a sequence of declarations (for parsing Rosetta IR)
  rosettaFile ::= rosettaDecl* → seq ;

-----------------------------------------------------
-- Tests
-- Syntax validation examples
-----------------------------------------------------
test "lam": (lam (explicitBinder x Nat) (add (var x) (numLit 1))) ;
test "forall": (forallTy (explicitBinder x Type) (arrowTy (var x) (var x))) ;
test "inductive": (inductiveDecl Term (whereCtors (ctor Var (explicitParam x Nat) (var Term)))) ;
test "def": (defDecl id (explicitParam A Type) (explicitParam x (var A)) (typeAnn (var A)) (var x)) ;
test "match": (matchExpr (termList (var x)) (matchAlt (patVar n) (add (var n) (numLit 1)))) ;

