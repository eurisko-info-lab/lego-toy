-----------------------------------------------------
-- CategoryTheory.lego: Category-theoretic primitives
--
-- This provides the foundation layer that makes
-- TypeTheoryFromMath.lego valid Lego code.
--
-- Stack: Grammar → CategoryTheory → TypeTheoryFromMath
-----------------------------------------------------

import Lego.Algebra ;

lang CategoryTheory :=

-----------------------------------------------------
-- CATEGORIES
-----------------------------------------------------
piece Category
  -- A category has objects and morphisms
  cat ::= "cat" <ident> "objects" sort "morphisms" sort sort → mkCat ;
  
  -- Core structure
  rule catId: (cat $name objects $ob morphisms $mor $mor) 
    ~> (piece $name 
         obj ::= $ob ;
         hom ::= $mor ;
         rule compose: (comp (comp $f $g) $h) ~> (comp $f (comp $g $h)) ;
         rule idL: (comp id $f) ~> $f ;
         rule idR: (comp $f id) ~> $f ;
       ) ;

-----------------------------------------------------
-- FUNCTORS
-----------------------------------------------------
piece Functor
  -- A functor maps between categories
  functor ::= "functor" <ident> ":" <ident> "→" <ident> → mkFunctor
            | "forgetful" <ident> ":" sort "→" sort → forgetful ;
  
  -- Functor preserves composition
  rule functorComp: (functor $F : $C → $D)
    ~> (derive map for $F ;
        rule fComp: ($F (comp $f $g)) ~> (comp ($F $f) ($F $g)) ;
        rule fId: ($F id) ~> id ;
       ) ;
  
  -- Forgetful functor is projection
  rule forgetfulDef: (forgetful $name : ($A, $B) → $A)
    ~> (rule $name: ($name (pair $a $b)) ~> $a ;) ;

-----------------------------------------------------
-- NATURAL TRANSFORMATIONS
-----------------------------------------------------
piece NaturalTransformation
  nat ::= <ident> "=>" <ident> ":" sort "⟹" sort → mkNat ;
  
  -- Naturality square: α_B ∘ F(f) = G(f) ∘ α_A
  rule natSquare: ($alpha => $beta : $F ⟹ $G)
    ~> (rule natSq: (comp ($G $f) $alpha) ~> (comp $alpha ($F $f)) ;) ;

-----------------------------------------------------
-- ADJUNCTIONS
-----------------------------------------------------
piece Adjunction
  adj ::= "left" "adjoint" <ident> "to" <ident> → leftAdj
        | "right" "adjoint" <ident> "to" <ident> → rightAdj
        | <ident> "⊣" <ident> ":" <ident> "⇄" <ident> → adjPair ;
  
  -- Left adjoint: Hom(LA, B) ≅ Hom(A, RB)
  rule leftAdjDef: (left adjoint $L to $R)
    ~> (-- unit: A → RLA
        rule unit: $a ~> ($R ($L $a)) ;
        -- L preserves colimits
        rule lColim: ($L (colim $F)) ~> (colim (comp $L $F)) ;
       ) ;
  
  -- Right adjoint: Hom(LA, B) ≅ Hom(A, RB)
  rule rightAdjDef: (right adjoint $R to $L)
    ~> (-- counit: LRA → A
        rule counit: ($L ($R $a)) ~> $a ;
        -- R preserves limits
        rule rLim: ($R (lim $F)) ~> (lim (comp $R $F)) ;
       ) ;

-----------------------------------------------------
-- KAN EXTENSIONS
-----------------------------------------------------
piece KanExtension
  kan ::= "lan" <ident> "along" <ident> → lanDef
        | "ran" <ident> "along" <ident> → ranDef ;
  
  -- Left Kan extension: (Lan_K F)(B) = colim_{K(A)→B} F(A)
  rule lanDef: (lan $name along $K)
    ~> (-- Lan is left adjoint to precomposition
        left adjoint $name to (precomp $K) ;
        -- Pointwise formula
        rule lanPt: ($name $F $b) ~> (colim (comma $K $b) (comp $F proj)) ;
       ) ;
  
  -- Right Kan extension: (Ran_K F)(B) = lim_{B→K(A)} F(A)
  rule ranDef: (ran $name along $K)
    ~> (-- Ran is right adjoint to precomposition
        right adjoint $name to (precomp $K) ;
        -- Pointwise formula
        rule ranPt: ($name $F $b) ~> (lim (comma $b $K) (comp $F proj)) ;
       ) ;

-----------------------------------------------------
-- YONEDA EMBEDDING
-----------------------------------------------------
piece Yoneda
  yoneda ::= "yoneda" sort → yonedaEmbed ;
  
  -- y : C → [C^op, Set], y(A) = Hom(-, A)
  rule yonedaDef: (yoneda $C)
    ~> (-- Yoneda embedding
        functor y : $C → (presheaf $C) ;
        rule yObj: (y $a) ~> (hom _ $a) ;
        -- Yoneda lemma: Nat(y(A), F) ≅ F(A)
        rule yonedaLemma: (nat (y $a) $F) ~> ($F $a) ;
        -- y is fully faithful
        rule yFF: (hom (y $a) (y $b)) ~> (hom $a $b) ;
       ) ;

-----------------------------------------------------
-- OPTICS (Lenses, Prisms, Traversals)
-----------------------------------------------------
piece Optics
  optic ::= "lens" <ident> ":" sort "⟷" sort → lensDef
          | "prism" <ident> ":" sort "⟷" sort → prismDef
          | "traversal" <ident> ":" sort "⟿" sort → traversalDef
          | "getter" <ident> ":" sort "→" sort → getterDef
          | "setter" <ident> ":" sort "←" sort → setterDef ;
  
  -- Lens = getter + setter satisfying laws
  rule lensDef: (lens $name : $S ⟷ $A)
    ~> (-- Get-Put: put(get(s), s) = s
        rule getPut: (put (get $s) $s) ~> $s ;
        -- Put-Get: get(put(a, s)) = a
        rule putGet: (get (put $a $s)) ~> $a ;
        -- Put-Put: put(a, put(b, s)) = put(a, s)
        rule putPut: (put $a (put $b $s)) ~> (put $a $s) ;
       ) ;
  
  -- Prism = matching + building
  rule prismDef: (prism $name : $S ⟷ $A)
    ~> (-- Match returns Maybe
        rule matchBuild: (match (build $a)) ~> (just $a) ;
        -- Build-Match: if match succeeds, rebuild
        rule buildMatch: (build (fromJust (match $s))) ~> $s ;
       ) ;
  
  -- Traversal = effectful iteration
  rule traversalDef: (traversal $name : $S ⟿ $A)
    ~> (derive traverse for $S targeting $A ;) ;
  
  -- Getter is half of lens
  rule getterDef: (getter $name : $S → $A)
    ~> (rule $name: ($name $s) ~> (extract $A $s) ;) ;
  
  -- Setter is other half
  rule setterDef: (setter $name : $S ← $A)
    ~> (rule $name: ($name $a $s) ~> (inject $A $a $s) ;) ;

-----------------------------------------------------
-- MONADS via Adjunctions
-----------------------------------------------------
piece Monad
  monad ::= "monad" <ident> "from" <ident> "⊣" <ident> → monadFromAdj
          | "codensity" <ident> → codensityDef
          | "density" <ident> → densityDef ;
  
  -- Monad from adjunction: T = R ∘ L
  rule monadFromAdj: (monad $T from $L ⊣ $R)
    ~> (rule monadT: $T ~> (comp $R $L) ;
        rule return: (return $a) ~> (unit $a) ;
        rule bind: (bind $ma $f) ~> (join (map $f $ma)) ;
        rule join: (join $mma) ~> (counit $mma) ;
       ) ;
  
  -- Codensity monad: Ran_G G
  rule codensityDef: (codensity $name)
    ~> (ran $name along $name ;
        -- Codensity G a = ∀r. (a → G r) → G r
        rule codensityType: ($name $a) ~> (forall $r (arr (arr $a ($name $r)) ($name $r))) ;
       ) ;
  
  -- Density comonad: Lan_G G
  rule densityDef: (density $name)
    ~> (lan $name along $name ;) ;

-----------------------------------------------------
-- OPERADS
-----------------------------------------------------
piece Operad
  operad ::= "operad" <ident> "{" opbody* "}" → operadDef ;
  opbody ::= "arity" <number> ":" sort → arityDef
           | "compose" ":" sort → composeDef
           | "unit" ":" sort → unitDef ;
  
  rule operadDef: (operad $name { $ops })
    ~> (piece $name
         -- Operations at each arity
         $ops
         -- Associativity
         rule assoc: (compose (compose $f $gs) $hs) 
           ~> (compose $f (map (compose _ $hs) $gs)) ;
         -- Unit laws
         rule unitL: (compose unit $fs) ~> $fs ;
         rule unitR: (compose $f [unit, ..., unit]) ~> $f ;
       ) ;
  
  -- Algebra over an operad
  algebra ::= "algebra" <ident> "over" <ident> → algebraDef ;
  
  rule algebraDef: (algebra $A over $O)
    ~> (-- Each operation gives an action
        derive action for $A from $O ;
       ) ;

-----------------------------------------------------
-- DINATURALITY (for Cubical)
-----------------------------------------------------
piece Dinatural
  dinat ::= "dinatural" <ident> ":" sort "⤇" sort → dinatDef ;
  
  -- Dinatural transformation: wedge condition
  rule dinatDef: (dinatural $alpha : $F ⤇ $G)
    ~> (-- Wedge: F(A,A) → G(A,A) for all A
        -- with coherence for f : A → B
        rule wedge: (comp ($G $f id) $alpha) ~> (comp $alpha ($F id $f)) ;
       ) ;

-----------------------------------------------------
-- ENDS AND COENDS
-----------------------------------------------------
piece EndsCoends
  ec ::= "end" <ident> ":" sort → endDef
       | "coend" <ident> ":" sort → coendDef ;
  
  -- End: ∫_A F(A,A) = limit of F along diagonal
  rule endDef: (end $name : $F)
    ~> (rule endUniv: ($name $F) ~> (lim (diag) $F) ;
        -- Universal property: maps into end factor through
       ) ;
  
  -- Coend: ∫^A F(A,A) = colimit of F along diagonal
  rule coendDef: (coend $name : $F)
    ~> (rule coendUniv: ($name $F) ~> (colim (diag) $F) ;) ;

end

-----------------------------------------------------
-- Now TypeTheoryFromMath.lego can use:
--   yoneda, adjoint, lan, ran, lens, operad, etc.
--
-- The stack:
--   Lego.Algebra (base grammar)
--   → CategoryTheory.lego (this file)
--   → TypeTheoryFromMath.lego (high-level TT spec)
--   → Generated Lean code
-----------------------------------------------------
