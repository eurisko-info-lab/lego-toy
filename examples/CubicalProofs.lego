-- CubicalProofs.lego: Using Cubical Type Theory in .lego files
--
-- This example demonstrates how to leverage cubical TT features:
-- 1. Path types for propositional equality
-- 2. Equivalences for isomorphic representations  
-- 3. Verified rules with cubical proofs
-- 4. Transport and univalence
--
-- These features let language designers:
-- - Prove optimizations preserve semantics
-- - Switch between equivalent representations
-- - Transport properties across isomorphisms

lang CubicalProofs (Lego) :=

-----------------------------------------------------
-- PATH TYPES
-- Identity types with computational content
-----------------------------------------------------

piece PathExamples
  term ::= "Nat"                       → nat
         | "zero"                      → zero
         | "suc" term                  → suc
         | "add" term term             → add
         | "mul" term term             → mul
         | "List" term                 → list
         | "nil"                       → nil
         | "cons" term term            → cons
         | "append" term term          → append
         | "Bool"                      → bool
         | "true"                      → true
         | "false"                     → false ;

  -- Standard evaluation rules
  rule add_zero: (add zero $n) ~> $n ;
  rule add_suc: (add (suc $m) $n) ~> (suc (add $m $n)) ;
  rule append_nil: (append nil $xs) ~> $xs ;
  rule append_cons: (append (cons $x $xs) $ys) ~> (cons $x (append $xs $ys)) ;

-----------------------------------------------------
-- VERIFIED RULES WITH REFLEXIVITY
-- Using refl to prove identity preserving transforms
-----------------------------------------------------

piece ReflProofs
  -- Identity optimization: simplify redundant constructs
  -- add n zero = n (right identity)
  
  -- The proof uses refl: Path Nat (add n zero) (add n zero)
  -- Then we need to show add n zero reduces to n
  verified rule add_zero_right:
    (add $n zero) ~> $n
    via (refl $n) ;

  -- List identity: append xs nil = xs
  verified rule append_nil_right:
    (append $xs nil) ~> $xs
    via (refl $xs) ;

  -- Nested optimization: redundant double negation
  -- not (not b) = b for booleans
  verified rule double_neg:
    (not (not $b)) ~> $b
    via (refl $b) ;

-----------------------------------------------------
-- SYMMETRY PROOFS
-- Using sym to reverse equations
-----------------------------------------------------

piece SymmetryProofs
  term ::= "comm_add_proof" term term  → commAddProof
         | "comm_mul_proof" term term  → commMulProof ;

  -- If we have: add a b = add b a
  -- Then sym gives: add b a = add a b
  
  -- Commutativity of addition
  -- The proof term: sym (comm_add_proof a b) : Path Nat (add b a) (add a b)
  type commAddProofType: (comm_add_proof $a $b) : (Path Nat (add $a $b) (add $b $a))
    when $a : Nat, $b : Nat ;

  -- Verified rule using symmetry
  -- We prove add b a ~> add a b by reversing the commutativity proof
  verified rule comm_add_rev:
    (add $b $a) ~> (add $a $b)
    via (sym (comm_add_proof $a $b)) ;

-----------------------------------------------------
-- TRANSITIVITY PROOFS
-- Using trans to chain equations
-----------------------------------------------------

piece TransitivityProofs
  term ::= "assoc_proof" term term term → assocProof ;

  -- Associativity gives us a chain:
  -- (a + b) + c = a + (b + c)
  -- 
  -- With transitivity we can compose:
  -- If p : x = y and q : y = z, then trans p q : x = z

  type assocProofType: (assoc_proof $a $b $c) 
    : (Path Nat (add (add $a $b) $c) (add $a (add $b $c)))
    when $a : Nat, $b : Nat, $c : Nat ;

  -- Multi-step reasoning: ((a + b) + c) + d = a + (b + (c + d))
  -- Step 1: ((a + b) + c) + d = (a + (b + c)) + d  (assoc on inner)
  -- Step 2: (a + (b + c)) + d = a + ((b + c) + d)  (assoc on outer)  
  -- Step 3: a + ((b + c) + d) = a + (b + (c + d))  (assoc on (b+c)+d)
  
  verified rule add_reassoc:
    (add (add (add $a $b) $c) $d) ~> (add $a (add $b (add $c $d)))
    via (trans (assoc_proof (add $a $b) $c $d) 
         (trans (cong (Lam x . (add x $d)) (assoc_proof $a $b $c))
                (assoc_proof $a $b (add $c $d)))) ;

-----------------------------------------------------
-- CONGRUENCE PROOFS
-- Using cong to apply functions to equalities
-----------------------------------------------------

piece CongruenceProofs
  term ::= "double" term               → double
         | "square" term               → square ;

  rule double_def: (double $n) ~> (add $n $n) ;
  rule square_def: (square $n) ~> (mul $n $n) ;

  -- If a = b, then f(a) = f(b) via cong
  -- cong f p : Path B (f a) (f b)  when p : Path A a b

  -- Verified: if n = m then double n = double m
  -- The proof uses: cong double (proof_n_eq_m)
  
  -- Example: double (add a zero) = double a
  -- We have: add a zero = a (via add_zero_right proof)
  -- Apply cong double: double (add a zero) = double a
  verified rule double_add_zero:
    (double (add $a zero)) ~> (double $a)
    via (cong (Lam n . (double n)) (refl $a)) ;

-----------------------------------------------------
-- EQUIVALENCES
-- Quasi-invertible functions between types
-----------------------------------------------------

piece EquivalenceExamples
  term ::= "BinaryNat"                 → binaryNat
         | "bz"                        → bz
         | "b0" term                   → b0
         | "b1" term                   → b1
         | "nat_to_bin" term           → natToBin
         | "bin_to_nat" term           → binToNat ;

  -- Conversions
  rule nat_to_bin_zero: (nat_to_bin zero) ~> bz ;
  rule bin_to_nat_bz: (bin_to_nat bz) ~> zero ;

  -- Nat ≃ BinaryNat: same information, different representation
  -- idEquiv gives identity: A ≃ A
  -- compEquiv composes: A ≃ B → B ≃ C → A ≃ C
  -- invEquiv inverts: A ≃ B → B ≃ A

  -- Representation equivalence: Nat and BinaryNat are equivalent
  repr Nat ≃ BinaryNat
    via (mkEquiv nat_to_bin bin_to_nat
         (Lam n . (refl n))
         (Lam b . (refl b))) ;

-----------------------------------------------------
-- UNIVALENCE
-- Equivalence → Path in Type
-----------------------------------------------------

piece UnivalenceExamples
  term ::= "Unit"                      → unit
         | "tt"                        → tt
         | "unit_nat_equiv"            → unitNatEquiv ;

  -- ua : Equiv A B → Path Univ A B
  -- This is the univalence axiom: equivalent types are equal types

  -- Example: Bool ≃ Bool via identity
  -- ua (idEquiv Bool) : Path Univ Bool Bool
  -- This reduces to refl Bool

  -- Transport along ua lets us move values between equivalent types:
  -- If e : A ≃ B and a : A, then transport (ua e) a : B

  type unitNatEquivType: unit_nat_equiv : (Equiv Unit Nat) ;

  -- Using ua: Path Univ Unit Nat (unusual but valid if we have the equiv!)
  -- This shows types with equivalence are "the same" in the type theory

-----------------------------------------------------
-- PATH COMBINATORS IN PROOFS
-----------------------------------------------------

piece PathCombinatorProofs
  term ::= "funext_proof" term         → funextProof ;

  -- funExt : ((x : A) → Path B (f x) (g x)) → Path (A → B) f g
  -- Function extensionality: pointwise equal functions are equal

  -- If for all x, f x = g x, then f = g
  
  -- Example: (λn. add n zero) = (λn. n)
  -- Proof: funExt (λn. add_zero_right_proof n)
  type funextProofType: (funext_proof $h) 
    : (Path (Arrow Nat Nat) (Lam n . (add n zero)) (Lam n . n))
    when $h : (Arrow Nat (Path Nat (add $n zero) $n)) ;

-----------------------------------------------------
-- TESTS BLOCK
-----------------------------------------------------

piece Tests
  tests
    -- Basic arithmetic  
    "add_1_2" ~> suc(suc(suc(zero)))
    "add_zero" ~> zero
    
    -- List operations
    "append_nil" ~> nil
    "cons_elem" ~> cons(zero, nil)
    
    -- Binary representation
    "nat_to_bin_zero" ~> bz
  end

-----------------------------------------------------
-- TYPE RULES FOR CUBICAL CONSTRUCTS
-----------------------------------------------------

piece CubicalTypes
  -- Path type formation
  type pathForm: (Path $A $a $b) : Univ when $A : Univ, $a : $A, $b : $A ;
  
  -- refl: a = a
  type reflType: (refl $a) : (Path $A $a $a) when $a : $A ;
  
  -- sym: a = b → b = a  
  type symType: (sym $p) : (Path $A $b $a) when $p : (Path $A $a $b) ;
  
  -- trans: a = b → b = c → a = c
  type transType: (trans $p $q) : (Path $A $a $c) 
    when $p : (Path $A $a $b), $q : (Path $A $b $c) ;
  
  -- cong: a = b → f a = f b
  type congType: (cong $f $p) : (Path $B (App $f $a) (App $f $b))
    when $f : (Arrow $A $B), $p : (Path $A $a $b) ;
  
  -- Equivalence formation
  type equivForm: (Equiv $A $B) : Univ when $A : Univ, $B : Univ ;
  
  -- idEquiv: A ≃ A
  type idEquivType: (idEquiv $A) : (Equiv $A $A) when $A : Univ ;
  
  -- invEquiv: A ≃ B → B ≃ A
  type invEquivType: (invEquiv $e) : (Equiv $B $A) when $e : (Equiv $A $B) ;
  
  -- compEquiv: A ≃ B → B ≃ C → A ≃ C
  type compEquivType: (compEquiv $e1 $e2) : (Equiv $A $C)
    when $e1 : (Equiv $A $B), $e2 : (Equiv $B $C) ;
  
  -- ua: Equiv A B → Path Univ A B (univalence)
  type uaType: (ua $e) : (Path Univ $A $B) when $e : (Equiv $A $B) ;

-----------------------------------------------------
-- ADVANCED: QUOTIENT TYPES
-----------------------------------------------------

piece QuotientTypes
  term ::= "Quot" term term            → quot
         | "quotIn" term               → quotIn
         | "quotEq" term term term     → quotEq ;

  -- Quot A R = A quotiented by equivalence relation R
  -- quotIn a : Quot A R when a : A
  -- quotEq a b p : Path (Quot A R) (quotIn a) (quotIn b) when p : R a b

  -- Example: Integers as Nat × Nat quotiented by (a,b) ~ (c,d) iff a+d = b+c
  
  type quotForm: (Quot $A $R) : Univ when $A : Univ, $R : (Arrow $A (Arrow $A Univ)) ;
  type quotInType: (quotIn $a) : (Quot $A $R) when $a : $A ;
  type quotEqType: (quotEq $a $b $p) : (Path (Quot $A $R) (quotIn $a) (quotIn $b))
    when $a : $A, $b : $A, $p : (App (App $R $a) $b) ;

-----------------------------------------------------
-- INTERVAL TYPE
-- The abstract interval I with endpoints 0 and 1
-----------------------------------------------------

piece IntervalType
  term ::= "I"                         → interval
         | "i0"                        → i0
         | "i1"                        → i1
         | "imax" term term            → imax
         | "imin" term term            → imin
         | "ineg" term                 → ineg ;

  -- I is the interval type with:
  -- i0, i1 : I (endpoints)
  -- imax, imin : I → I → I (lattice operations)  
  -- ineg : I → I (reversal: ineg i0 = i1, ineg i1 = i0)

  -- Interval algebra
  rule ineg_i0: (ineg i0) ~> i1 ;
  rule ineg_i1: (ineg i1) ~> i0 ;
  rule ineg_ineg: (ineg (ineg $i)) ~> $i ;
  rule imax_i0: (imax i0 $j) ~> $j ;
  rule imax_i1: (imax i1 $j) ~> i1 ;
  rule imin_i0: (imin i0 $j) ~> i0 ;
  rule imin_i1: (imin i1 $j) ~> $j ;

  type intervalForm: I : Univ ;
  type i0Type: i0 : I ;
  type i1Type: i1 : I ;
  type imaxType: (imax $i $j) : I when $i : I, $j : I ;
  type iminType: (imin $i $j) : I when $i : I, $j : I ;
  type inegType: (ineg $i) : I when $i : I ;

-----------------------------------------------------
-- COFIBRATIONS (FACE FORMULAS)
-- Constraints on the interval for partial elements
-----------------------------------------------------

piece Cofibrations
  term ::= "cof_top"                   → cofTop
         | "cof_bot"                   → cofBot
         | "cof_eq" term term          → cofEq
         | "cof_and" term term         → cofAnd
         | "cof_or" term term          → cofOr ;

  -- Cofibrations are "face formulas" that describe where partial elements are defined
  -- cof_top = always true (⊤)
  -- cof_bot = always false (⊥)
  -- cof_eq i j = i = j (diagonal)
  -- cof_and φ ψ = φ ∧ ψ
  -- cof_or φ ψ = φ ∨ ψ

  -- Simplification rules
  rule cof_eq_refl: (cof_eq $i $i) ~> cof_top ;
  rule cof_eq_01: (cof_eq i0 i1) ~> cof_bot ;
  rule cof_eq_10: (cof_eq i1 i0) ~> cof_bot ;
  rule cof_and_top: (cof_and cof_top $φ) ~> $φ ;
  rule cof_and_bot: (cof_and cof_bot $φ) ~> cof_bot ;
  rule cof_or_top: (cof_or cof_top $φ) ~> cof_top ;
  rule cof_or_bot: (cof_or cof_bot $φ) ~> $φ ;

  type cofTopType: cof_top : Cof ;
  type cofBotType: cof_bot : Cof ;
  type cofEqType: (cof_eq $i $j) : Cof when $i : I, $j : I ;
  type cofAndType: (cof_and $φ $ψ) : Cof when $φ : Cof, $ψ : Cof ;
  type cofOrType: (cof_or $φ $ψ) : Cof when $φ : Cof, $ψ : Cof ;

-----------------------------------------------------
-- PATH ABSTRACTION AND APPLICATION
-- Constructing and using paths
-----------------------------------------------------

piece PathOps
  term ::= "plam" <ident> term         → plam
         | "papp" term term            → papp ;

  -- plam i. body : Path A (body[i:=0]) (body[i:=1])
  -- papp p r : A  when p : Path A a b, r : I
  
  -- Path β-reduction: applying a path abstraction
  rule papp_plam: (papp (plam $i $body) $r) ~> (subst $i $r $body) ;
  
  -- Path endpoints: papp p i0 = a, papp p i1 = b
  rule papp_i0: (papp (refl $a) i0) ~> $a ;
  rule papp_i1: (papp (refl $a) i1) ~> $a ;

  type plamType: (plam $i $body) : (Path $A $a $b)
    when $body : $A ;
  type pappType: (papp $p $r) : $A when $p : (Path $A $a $b), $r : I ;

-----------------------------------------------------
-- DEPENDENT PATHS (PathP)
-- Heterogeneous paths over a line of types
-----------------------------------------------------

piece DependentPaths
  term ::= "PathP" term term term      → pathP
         | "toPathP" term              → toPathP
         | "fromPathP" term            → fromPathP ;

  -- PathP (λi. A i) a₀ a₁ = path from a₀ : A 0 to a₁ : A 1
  -- When A is constant: PathP (λi. A) a b ≃ Path A a b
  
  -- toPathP : Path A a b → PathP (λi. A) a b
  -- fromPathP : PathP (λi. A) a b → Path A a b

  rule toPathP_fromPathP: (toPathP (fromPathP $p)) ~> $p ;
  rule fromPathP_toPathP: (fromPathP (toPathP $p)) ~> $p ;

  type pathPForm: (PathP $A $a0 $a1) : Univ
    when $A : (Arrow I Univ), $a0 : (App $A i0), $a1 : (App $A i1) ;

-----------------------------------------------------
-- KAN OPERATIONS
-- Coercion and composition for computing with paths
-----------------------------------------------------

piece KanOperations
  term ::= "coe" term term term term   → coe
         | "hcom" term term term term term → hcom
         | "transp" term term term     → transp ;

  -- coe r s A a : A s  when a : A r
  -- Coercion along a line of types
  
  -- hcom r s A [φ ↦ u] a : A
  -- Homogeneous composition: fill a cube with given boundary
  
  -- transp A φ a : A 1  when a : A 0
  -- Transport with cofibration constraint

  -- Degenerate cases (when r = s, no movement needed)
  rule coe_refl: (coe $r $r $A $a) ~> $a ;
  rule hcom_refl: (hcom $r $r $A $φ $a) ~> $a ;
  rule transp_top: (transp $A cof_top $a) ~> $a ;

  type coeType: (coe $r $s $A $a) : (App $A $s)
    when $r : I, $s : I, $A : (Arrow I Univ), $a : (App $A $r) ;
  type hcomType: (hcom $r $s $A $φ $a) : $A
    when $r : I, $s : I, $A : Univ, $φ : Cof, $a : $A ;
  type transpType: (transp $A $φ $a) : (App $A i1)
    when $A : (Arrow I Univ), $φ : Cof, $a : (App $A i0) ;

-----------------------------------------------------
-- GLUE TYPES (V-TYPES)
-- For proving univalence
-----------------------------------------------------

piece GlueTypes
  term ::= "Glue" term term term       → glue
         | "glue" term term            → glueEl
         | "unglue" term               → unglue ;

  -- Glue [φ ↦ (T, e)] A = type that looks like T on face φ, and A elsewhere
  -- glue t a : Glue [φ ↦ (T, e)] A  when t : T, a : A, e t = a on φ
  -- unglue g : A  when g : Glue [φ ↦ (T, e)] A

  -- Glue types are the key to proving univalence:
  -- ua e = Glue [i=0 ↦ (A, e), i=1 ↦ (B, idEquiv)] B

  rule unglue_glue: (unglue (glue $t $a)) ~> $a ;

  type glueForm: (Glue $φ $T $A) : Univ 
    when $φ : Cof, $T : Univ, $A : Univ ;
  type glueElType: (glue $t $a) : (Glue $φ $T $A)
    when $t : $T, $a : $A ;
  type unglueType: (unglue $g) : $A when $g : (Glue $φ $T $A) ;

-----------------------------------------------------
-- EXTENSION TYPES
-- Partial elements and their extensions
-----------------------------------------------------

piece ExtensionTypes
  term ::= "Partial" term term         → partial
         | "PartialP" term term        → partialP
         | "Sub" term term term        → sub
         | "inS" term                  → inS
         | "outS" term                 → outS ;

  -- Partial φ A = partial element of A defined on face φ
  -- Sub A φ u = elements of A that agree with u on face φ
  -- inS a : Sub A φ u  when a : A agrees with u on φ
  -- outS s : A  when s : Sub A φ u

  rule outS_inS: (outS (inS $a)) ~> $a ;

  type partialForm: (Partial $φ $A) : Univ when $φ : Cof, $A : Univ ;
  type subForm: (Sub $A $φ $u) : Univ 
    when $A : Univ, $φ : Cof, $u : (Partial $φ $A) ;
  type inSType: (inS $a) : (Sub $A $φ $u) when $a : $A ;
  type outSType: (outS $s) : $A when $s : (Sub $A $φ $u) ;

-----------------------------------------------------
-- HIGHER INDUCTIVE TYPES
-- Types with path constructors
-----------------------------------------------------

piece HigherInductives
  term ::= "S1"                        → s1
         | "base"                      → base
         | "loop"                      → loop
         | "S1elim" term term term term → s1elim
         | "Susp" term                 → susp
         | "north"                     → north
         | "south"                     → south
         | "merid" term                → merid ;

  -- S¹ (Circle): base : S¹, loop : Path S¹ base base
  -- S1elim P b l x : P x  eliminates into any type family

  -- Susp A (Suspension): north, south : Susp A, merid a : Path (Susp A) north south

  -- Loop endpoints
  rule loop_i0: (papp loop i0) ~> base ;
  rule loop_i1: (papp loop i1) ~> base ;
  
  -- Eliminator computation
  rule s1elim_base: (S1elim $P $b $l base) ~> $b ;

  type s1Form: S1 : Univ ;
  type baseType: base : S1 ;
  type loopType: loop : (Path S1 base base) ;
  type suspForm: (Susp $A) : Univ when $A : Univ ;
  type northType: north : (Susp $A) ;
  type southType: south : (Susp $A) ;
  type meridType: (merid $a) : (Path (Susp $A) north south) when $a : $A ;

-----------------------------------------------------
-- H-LEVELS (TRUNCATION LEVELS)
-- Hierarchy of type complexity
-----------------------------------------------------

piece HLevels
  term ::= "isContr" term              → isContr
         | "isProp" term               → isProp
         | "isSet" term                → isSet
         | "isGroupoid" term           → isGroupoid
         | "propTrunc" term            → propTrunc
         | "setTrunc" term             → setTrunc
         | "truncIn" term              → truncIn ;

  -- isContr A = A has exactly one element (contractible)
  -- isProp A = any two elements are equal (proposition)
  -- isSet A = any two paths are equal (set)
  -- isGroupoid A = any two path-of-paths are equal (groupoid)
  
  -- Truncations:
  -- propTrunc A = ||A|| (proposition that A is inhabited)
  -- setTrunc A = |A|₀ (set generated by A)

  type isContrForm: (isContr $A) : Univ when $A : Univ ;
  type isPropForm: (isProp $A) : Univ when $A : Univ ;
  type isSetForm: (isSet $A) : Univ when $A : Univ ;
  type isGroupoidForm: (isGroupoid $A) : Univ when $A : Univ ;
  type propTruncForm: (propTrunc $A) : Univ when $A : Univ ;
  type setTruncForm: (setTrunc $A) : Univ when $A : Univ ;
  type truncInType: (truncIn $a) : (propTrunc $A) when $a : $A ;

-----------------------------------------------------
-- CONTRACTIBILITY AND FIBERS
-- Core notions for equivalences
-----------------------------------------------------

piece Fibers
  term ::= "fiber" term term           → fiber
         | "fiberPath" term term term  → fiberPath
         | "isEquivFiber" term         → isEquivFiber
         | "contrCenter" term          → contrCenter
         | "contrPath" term term       → contrPath ;

  -- fiber f y = Σ (x : A), f x = y
  -- isEquiv f = (y : B) → isContr (fiber f y)
  
  -- For contractible types:
  -- contrCenter c : A  (the center)
  -- contrPath c a : Path A (contrCenter c) a  (path to any element)

  type fiberForm: (fiber $f $y) : Univ 
    when $f : (Arrow $A $B), $y : $B ;
  type isEquivFiberForm: (isEquivFiber $f) : Univ 
    when $f : (Arrow $A $B) ;
  type contrCenterType: (contrCenter $c) : $A when $c : (isContr $A) ;
  type contrPathType: (contrPath $c $a) : (Path $A (contrCenter $c) $a)
    when $c : (isContr $A), $a : $A ;

-----------------------------------------------------
-- SIGMA TYPES (DEPENDENT PAIRS)
-- With path characterization
-----------------------------------------------------

piece SigmaTypes
  term ::= "Sigma" term term           → sigma
         | "pair" term term            → dpair
         | "fst" term                  → dfst
         | "snd" term                  → dsnd
         | "SigmaPath" term term       → sigmaPath ;

  -- Sigma (x : A), B x = dependent pair type
  -- pair a b : Sigma A B  when a : A, b : B a
  -- SigmaPath : characterize paths in Sigma types

  rule dfst_pair: (fst (pair $a $b)) ~> $a ;
  rule dsnd_pair: (snd (pair $a $b)) ~> $b ;

  type sigmaForm: (Sigma $A $B) : Univ 
    when $A : Univ, $B : (Arrow $A Univ) ;
  type dpairType: (pair $a $b) : (Sigma $A $B) 
    when $a : $A, $b : (App $B $a) ;
  type dfstType: (fst $p) : $A when $p : (Sigma $A $B) ;
  type dsndType: (snd $p) : (App $B (fst $p)) when $p : (Sigma $A $B) ;
  type sigmaPathType: (SigmaPath $p $q) : (Path (Sigma $A $B) (pair $a $b) (pair $a2 $b2))
    when $p : (Path $A $a $a2), $q : (PathP (plam i (App $B (papp $p i))) $b $b2) ;

-----------------------------------------------------
-- PI TYPES (DEPENDENT FUNCTIONS)  
-- With function extensionality
-----------------------------------------------------

piece PiTypes
  term ::= "Pi" term term              → pi
         | "lam" <ident> term          → dlam
         | "app" term term             → dapp
         | "funExt" term               → funExt
         | "funExtPath" term term term → funExtPath ;

  -- Pi (x : A), B x = dependent function type
  -- lam x. body : Pi A B
  -- funExt : ((x : A) → f x = g x) → f = g

  rule dapp_dlam: (app (lam $x $body) $a) ~> (subst $x $a $body) ;

  type piForm: (Pi $A $B) : Univ when $A : Univ, $B : (Arrow $A Univ) ;
  type dlamType: (lam $x $body) : (Pi $A $B) when $body : (App $B $x) ;
  type dappType: (app $f $a) : (App $B $a) when $f : (Pi $A $B), $a : $A ;
  type funExtType: (funExt $h) : (Path (Pi $A $B) $f $g)
    when $h : (Pi $A (Path (App $B $x) (app $f $x) (app $g $x))) ;

-----------------------------------------------------
-- J ELIMINATOR
-- Path induction / identity elimination
-----------------------------------------------------

piece JEliminator
  term ::= "J" term term term term term → jelim
         | "JRefl" term term term      → jrefl ;

  -- J : (A : Univ) → (a : A) → (P : (x : A) → a = x → Univ) →
  --     P a refl → (x : A) → (p : a = x) → P x p
  --
  -- J A a P d x p : P x p
  -- JRefl : J A a P d a refl = d

  rule j_refl: (J $A $a $P $d $a (refl $a)) ~> $d ;

  type jType: (J $A $a $P $d $x $p) : (App (App $P $x) $p)
    when $A : Univ, $a : $A, $P : (Pi $A (Arrow (Path $A $a $y) Univ)),
         $d : (App (App $P $a) (refl $a)), $x : $A, $p : (Path $A $a $x) ;

-----------------------------------------------------
-- OBSERVATIONAL EQUALITY
-- For verifying optimizations
-----------------------------------------------------

piece ObservationalEq
  term ::= "obsEq" term term term      → obsEq
         | "obsRefl" term              → obsRefl
         | "obsSym" term               → obsSym
         | "obsTrans" term term        → obsTrans
         | "obsCong" term term         → obsCong
         | "obsToPath" term            → obsToPath ;

  -- Observational equality: two terms are equal if they behave the same
  -- obsToPath : obsEq A a b → Path A a b (convert to path)

  rule obsToPath_refl: (obsToPath (obsRefl $a)) ~> (refl $a) ;
  rule obsToPath_sym: (obsToPath (obsSym $p)) ~> (sym (obsToPath $p)) ;
  rule obsToPath_trans: (obsToPath (obsTrans $p $q)) ~> (trans (obsToPath $p) (obsToPath $q)) ;

  type obsEqForm: (obsEq $A $a $b) : Univ when $A : Univ, $a : $A, $b : $A ;
  type obsReflType: (obsRefl $a) : (obsEq $A $a $a) when $a : $A ;
  type obsSymType: (obsSym $p) : (obsEq $A $b $a) when $p : (obsEq $A $a $b) ;
  type obsTransType: (obsTrans $p $q) : (obsEq $A $a $c) 
    when $p : (obsEq $A $a $b), $q : (obsEq $A $b $c) ;
  type obsCongType: (obsCong $f $p) : (obsEq $B (app $f $a) (app $f $b))
    when $f : (Arrow $A $B), $p : (obsEq $A $a $b) ;
  type obsToPathType: (obsToPath $p) : (Path $A $a $b) when $p : (obsEq $A $a $b) ;

-----------------------------------------------------
-- SUMMARY
-- 
-- Cubical features available in .lego files:
--
-- INTERVAL:
--   I              - the interval type
--   i0, i1         - endpoints
--   imax, imin     - lattice operations
--   ineg           - negation (reversal)
--
-- COFIBRATIONS:
--   cof_top, cof_bot - trivial constraints
--   cof_eq i j     - i = j constraint
--   cof_and, cof_or - conjunction/disjunction
--
-- PATHS (equality):
--   Path A a b     - the type of paths from a to b in A
--   PathP A a₀ a₁  - dependent path over line of types
--   refl a         - reflexivity proof: a = a
--   sym p          - symmetry: a = b → b = a
--   trans p q      - transitivity: a = b → b = c → a = c
--   cong f p       - congruence: a = b → f a = f b
--   funExt h       - function extensionality
--   plam i. e      - path abstraction
--   papp p r       - path application
--
-- KAN OPERATIONS:
--   coe r s A a    - coercion along type line
--   hcom r s A φ a - homogeneous composition
--   transp A φ a   - transport with constraint
--
-- EQUIVALENCES (isomorphisms):
--   Equiv A B      - the type of equivalences between A and B
--   idEquiv A      - identity: A ≃ A
--   invEquiv e     - inversion: A ≃ B → B ≃ A
--   compEquiv e f  - composition: A ≃ B → B ≃ C → A ≃ C
--
-- UNIVALENCE:
--   ua e           - Equiv A B → Path Univ A B
--   Glue types     - for proving univalence
--
-- HIGHER INDUCTIVES:
--   S1, base, loop - the circle
--   Susp A         - suspension
--
-- H-LEVELS:
--   isContr, isProp, isSet, isGroupoid
--   propTrunc, setTrunc - truncations
--
-- EXTENSION TYPES:
--   Partial φ A    - partial elements
--   Sub A φ u      - extension types
--
-- USE IN VERIFIED RULES:
--   verified rule name: lhs ~> rhs via proof ;
--   where proof : Path _ lhs rhs
--
-- USE IN REPR EQUIVALENCES:
--   repr A ≃ B via equiv ;
--   where equiv : Equiv A B
-----------------------------------------------------
